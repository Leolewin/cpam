Index: Makefile.am
===================================================================
--- Makefile.am.orig	2007-11-07 16:30:42.000000000 +0000
+++ Makefile.am	2007-11-07 16:30:53.434245873 +0000
@@ -2,6 +2,8 @@
 
 AUTOMAKE_OPTIONS = foreign no-dependencies
 
+SUBDIRS = lib
+
 # libz release 1.2.3
 libz_la_LDFLAGS = -version-info 3:0:1 -no-undefined
 
@@ -13,6 +15,7 @@
 	deflate.h gzio.c infback.c inffast.c inffast.h inffixed.h \
 	inflate.c inflate.h inftrees.c inftrees.h trees.c trees.h \
 	uncompr.c zutil.c zutil.h
+libz_la_LIBADD = lib/libgnu.la
 
 pkgconfigdir = $(libdir)/pkgconfig
 pkgconfig_DATA = zlib.pc
Index: configure.ac
===================================================================
--- configure.ac.orig	2007-11-07 16:30:46.000000000 +0000
+++ configure.ac	2007-11-07 16:31:11.542372004 +0000
@@ -4,6 +4,7 @@
 
 dnl Checks for programs
 AC_PROG_CC
+gl_EARLY
 AC_ISC_POSIX
 AM_C_PROTOTYPES
 if test "x$U" != "x"; then
@@ -22,10 +23,12 @@
 AC_CHECK_HEADERS(errno.h, ,
   [AC_DEFINE(NO_ERRNO_H, 1, [If <errno.h> available])])
 AC_FUNC_MMAP
+gl_INIT
 
 dnl Checks for typedefs, structures, and compiler characteristics.
 AC_C_CONST
 AC_CONFIG_HEADERS([config.h zconf.h:zconf.in.h])
 AC_CONFIG_FILES([Makefile])
+AC_CONFIG_FILES([lib/Makefile])
 AC_CONFIG_FILES([zlib.pc])
 AC_OUTPUT
Index: lib/Makefile.am
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/Makefile.am	2007-11-07 16:30:53.464074936 +0000
@@ -0,0 +1,261 @@
+## DO NOT EDIT! GENERATED AUTOMATICALLY!
+## Process this file with automake to produce Makefile.in.
+# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+#
+# This file is free software, distributed under the terms of the GNU
+# General Public License.  As a special exception to the GNU General
+# Public License, this file may be distributed as part of a program
+# that contains a configuration script generated by Autoconf, under
+# the same distribution terms as the rest of that program.
+#
+# Generated by gnulib-tool.
+# Reproduce by: gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --lgpl=2 --libtool --macro-prefix=gl snprintf vsnprintf
+
+AUTOMAKE_OPTIONS = 1.5 gnits
+
+noinst_HEADERS =
+noinst_LIBRARIES =
+noinst_LTLIBRARIES =
+EXTRA_DIST =
+BUILT_SOURCES =
+SUFFIXES =
+MOSTLYCLEANFILES = core *.stackdump
+MOSTLYCLEANDIRS =
+CLEANFILES =
+DISTCLEANFILES =
+MAINTAINERCLEANFILES =
+
+AM_CPPFLAGS =
+
+noinst_LTLIBRARIES += libgnu.la
+
+libgnu_la_SOURCES =
+libgnu_la_LIBADD = $(gl_LTLIBOBJS)
+libgnu_la_DEPENDENCIES = $(gl_LTLIBOBJS)
+EXTRA_libgnu_la_SOURCES =
+libgnu_la_LDFLAGS = $(AM_LDFLAGS)
+
+## begin gnulib module alloca-opt
+
+BUILT_SOURCES += $(ALLOCA_H)
+
+# We need the following in order to create <alloca.h> when the system
+# doesn't have one that works with the given compiler.
+alloca.h: alloca.in.h
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  cat $(srcdir)/alloca.in.h; \
+	} > $@-t
+	mv -f $@-t $@
+MOSTLYCLEANFILES += alloca.h alloca.h-t
+
+EXTRA_DIST += alloca.in.h
+
+## end   gnulib module alloca-opt
+
+## begin gnulib module float
+
+BUILT_SOURCES += $(FLOAT_H)
+
+# We need the following in order to create <float.h> when the system
+# doesn't have one that works with the given compiler.
+float.h: float.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's/@''INCLUDE_NEXT''@/$(INCLUDE_NEXT)/g' \
+	      -e 's|@''NEXT_FLOAT_H''@|$(NEXT_FLOAT_H)|g' \
+	      < $(srcdir)/float.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += float.h float.h-t
+
+EXTRA_DIST += float.in.h
+
+## end   gnulib module float
+
+## begin gnulib module link-warning
+
+LINK_WARNING_H=$(top_srcdir)/./link-warning.h
+
+EXTRA_DIST += $(top_srcdir)/./link-warning.h
+
+## end   gnulib module link-warning
+
+## begin gnulib module size_max
+
+libgnu_la_SOURCES += size_max.h
+
+## end   gnulib module size_max
+
+## begin gnulib module snprintf
+
+
+EXTRA_DIST += snprintf.c
+
+EXTRA_libgnu_la_SOURCES += snprintf.c
+
+## end   gnulib module snprintf
+
+## begin gnulib module stdint
+
+BUILT_SOURCES += $(STDINT_H)
+
+# We need the following in order to create <stdint.h> when the system
+# doesn't have one that works with the given compiler.
+stdint.h: stdint.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's/@''HAVE_STDINT_H''@/$(HAVE_STDINT_H)/g' \
+	      -e 's/@''INCLUDE_NEXT''@/$(INCLUDE_NEXT)/g' \
+	      -e 's|@''NEXT_STDINT_H''@|$(NEXT_STDINT_H)|g' \
+	      -e 's/@''HAVE_SYS_TYPES_H''@/$(HAVE_SYS_TYPES_H)/g' \
+	      -e 's/@''HAVE_INTTYPES_H''@/$(HAVE_INTTYPES_H)/g' \
+	      -e 's/@''HAVE_SYS_INTTYPES_H''@/$(HAVE_SYS_INTTYPES_H)/g' \
+	      -e 's/@''HAVE_SYS_BITYPES_H''@/$(HAVE_SYS_BITYPES_H)/g' \
+	      -e 's/@''HAVE_LONG_LONG_INT''@/$(HAVE_LONG_LONG_INT)/g' \
+	      -e 's/@''HAVE_UNSIGNED_LONG_LONG_INT''@/$(HAVE_UNSIGNED_LONG_LONG_INT)/g' \
+	      -e 's/@''BITSIZEOF_PTRDIFF_T''@/$(BITSIZEOF_PTRDIFF_T)/g' \
+	      -e 's/@''PTRDIFF_T_SUFFIX''@/$(PTRDIFF_T_SUFFIX)/g' \
+	      -e 's/@''BITSIZEOF_SIG_ATOMIC_T''@/$(BITSIZEOF_SIG_ATOMIC_T)/g' \
+	      -e 's/@''HAVE_SIGNED_SIG_ATOMIC_T''@/$(HAVE_SIGNED_SIG_ATOMIC_T)/g' \
+	      -e 's/@''SIG_ATOMIC_T_SUFFIX''@/$(SIG_ATOMIC_T_SUFFIX)/g' \
+	      -e 's/@''BITSIZEOF_SIZE_T''@/$(BITSIZEOF_SIZE_T)/g' \
+	      -e 's/@''SIZE_T_SUFFIX''@/$(SIZE_T_SUFFIX)/g' \
+	      -e 's/@''BITSIZEOF_WCHAR_T''@/$(BITSIZEOF_WCHAR_T)/g' \
+	      -e 's/@''HAVE_SIGNED_WCHAR_T''@/$(HAVE_SIGNED_WCHAR_T)/g' \
+	      -e 's/@''WCHAR_T_SUFFIX''@/$(WCHAR_T_SUFFIX)/g' \
+	      -e 's/@''BITSIZEOF_WINT_T''@/$(BITSIZEOF_WINT_T)/g' \
+	      -e 's/@''HAVE_SIGNED_WINT_T''@/$(HAVE_SIGNED_WINT_T)/g' \
+	      -e 's/@''WINT_T_SUFFIX''@/$(WINT_T_SUFFIX)/g' \
+	      < $(srcdir)/stdint.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += stdint.h stdint.h-t
+
+EXTRA_DIST += stdint.in.h
+
+## end   gnulib module stdint
+
+## begin gnulib module stdio
+
+BUILT_SOURCES += stdio.h
+
+# We need the following in order to create <stdio.h> when the system
+# doesn't have one that works with the given compiler.
+stdio.h: stdio.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */' && \
+	  sed -e 's/@''INCLUDE_NEXT''@/$(INCLUDE_NEXT)/g' \
+	      -e 's|@''NEXT_STDIO_H''@|$(NEXT_STDIO_H)|g' \
+	      -e 's|@''GNULIB_FPRINTF_POSIX''@|$(GNULIB_FPRINTF_POSIX)|g' \
+	      -e 's|@''GNULIB_PRINTF_POSIX''@|$(GNULIB_PRINTF_POSIX)|g' \
+	      -e 's|@''GNULIB_SNPRINTF''@|$(GNULIB_SNPRINTF)|g' \
+	      -e 's|@''GNULIB_SPRINTF_POSIX''@|$(GNULIB_SPRINTF_POSIX)|g' \
+	      -e 's|@''GNULIB_VFPRINTF_POSIX''@|$(GNULIB_VFPRINTF_POSIX)|g' \
+	      -e 's|@''GNULIB_VPRINTF_POSIX''@|$(GNULIB_VPRINTF_POSIX)|g' \
+	      -e 's|@''GNULIB_VSNPRINTF''@|$(GNULIB_VSNPRINTF)|g' \
+	      -e 's|@''GNULIB_VSPRINTF_POSIX''@|$(GNULIB_VSPRINTF_POSIX)|g' \
+	      -e 's|@''GNULIB_VASPRINTF''@|$(GNULIB_VASPRINTF)|g' \
+	      -e 's|@''GNULIB_FOPEN''@|$(GNULIB_FOPEN)|g' \
+	      -e 's|@''GNULIB_FREOPEN''@|$(GNULIB_FREOPEN)|g' \
+	      -e 's|@''GNULIB_FSEEK''@|$(GNULIB_FSEEK)|g' \
+	      -e 's|@''GNULIB_FSEEKO''@|$(GNULIB_FSEEKO)|g' \
+	      -e 's|@''GNULIB_FTELL''@|$(GNULIB_FTELL)|g' \
+	      -e 's|@''GNULIB_FTELLO''@|$(GNULIB_FTELLO)|g' \
+	      -e 's|@''GNULIB_FFLUSH''@|$(GNULIB_FFLUSH)|g' \
+	      -e 's|@''GNULIB_GETDELIM''@|$(GNULIB_GETDELIM)|g' \
+	      -e 's|@''GNULIB_GETLINE''@|$(GNULIB_GETLINE)|g' \
+	      -e 's|@''REPLACE_FPRINTF''@|$(REPLACE_FPRINTF)|g' \
+	      -e 's|@''REPLACE_VFPRINTF''@|$(REPLACE_VFPRINTF)|g' \
+	      -e 's|@''REPLACE_PRINTF''@|$(REPLACE_PRINTF)|g' \
+	      -e 's|@''REPLACE_VPRINTF''@|$(REPLACE_VPRINTF)|g' \
+	      -e 's|@''REPLACE_SNPRINTF''@|$(REPLACE_SNPRINTF)|g' \
+	      -e 's|@''HAVE_DECL_SNPRINTF''@|$(HAVE_DECL_SNPRINTF)|g' \
+	      -e 's|@''REPLACE_VSNPRINTF''@|$(REPLACE_VSNPRINTF)|g' \
+	      -e 's|@''HAVE_DECL_VSNPRINTF''@|$(HAVE_DECL_VSNPRINTF)|g' \
+	      -e 's|@''REPLACE_SPRINTF''@|$(REPLACE_SPRINTF)|g' \
+	      -e 's|@''REPLACE_VSPRINTF''@|$(REPLACE_VSPRINTF)|g' \
+	      -e 's|@''HAVE_VASPRINTF''@|$(HAVE_VASPRINTF)|g' \
+	      -e 's|@''REPLACE_VASPRINTF''@|$(REPLACE_VASPRINTF)|g' \
+	      -e 's|@''REPLACE_FOPEN''@|$(REPLACE_FOPEN)|g' \
+	      -e 's|@''REPLACE_FREOPEN''@|$(REPLACE_FREOPEN)|g' \
+	      -e 's|@''REPLACE_FSEEKO''@|$(REPLACE_FSEEKO)|g' \
+	      -e 's|@''REPLACE_FSEEK''@|$(REPLACE_FSEEK)|g' \
+	      -e 's|@''REPLACE_FTELLO''@|$(REPLACE_FTELLO)|g' \
+	      -e 's|@''REPLACE_FTELL''@|$(REPLACE_FTELL)|g' \
+	      -e 's|@''REPLACE_FFLUSH''@|$(REPLACE_FFLUSH)|g' \
+	      -e 's|@''HAVE_DECL_GETDELIM''@|$(HAVE_DECL_GETDELIM)|g' \
+	      -e 's|@''HAVE_DECL_GETLINE''@|$(HAVE_DECL_GETLINE)|g' \
+	      -e 's|@''REPLACE_GETLINE''@|$(REPLACE_GETLINE)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	      < $(srcdir)/stdio.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += stdio.h stdio.h-t
+
+EXTRA_DIST += stdio.in.h
+
+## end   gnulib module stdio
+
+## begin gnulib module vasnprintf
+
+
+EXTRA_DIST += asnprintf.c float+.h printf-args.c printf-args.h printf-parse.c printf-parse.h vasnprintf.c vasnprintf.h
+
+EXTRA_libgnu_la_SOURCES += asnprintf.c printf-args.c printf-parse.c vasnprintf.c
+
+## end   gnulib module vasnprintf
+
+## begin gnulib module vsnprintf
+
+
+EXTRA_DIST += vsnprintf.c
+
+EXTRA_libgnu_la_SOURCES += vsnprintf.c
+
+## end   gnulib module vsnprintf
+
+## begin gnulib module wchar
+
+BUILT_SOURCES += $(WCHAR_H)
+
+# We need the following in order to create <wchar.h> when the system
+# version does not work standalone.
+wchar.h: wchar.in.h
+	rm -f $@-t $@
+	{ echo '/* DO NOT EDIT! GENERATED AUTOMATICALLY! */'; \
+	  sed -e 's/@''INCLUDE_NEXT''@/$(INCLUDE_NEXT)/g' \
+	      -e 's|@''NEXT_WCHAR_H''@|$(NEXT_WCHAR_H)|g' \
+	      -e 's/@''HAVE_WCHAR_H''@/$(HAVE_WCHAR_H)/g' \
+	      -e 's|@''GNULIB_WCWIDTH''@|$(GNULIB_WCWIDTH)|g' \
+	      -e 's|@''HAVE_DECL_WCWIDTH''@|$(HAVE_DECL_WCWIDTH)|g' \
+	      -e 's|@''REPLACE_WCWIDTH''@|$(REPLACE_WCWIDTH)|g' \
+	      -e '/definition of GL_LINK_WARNING/r $(LINK_WARNING_H)' \
+	    < $(srcdir)/wchar.in.h; \
+	} > $@-t
+	mv $@-t $@
+MOSTLYCLEANFILES += wchar.h wchar.h-t
+
+EXTRA_DIST += wchar.in.h
+
+## end   gnulib module wchar
+
+## begin gnulib module xsize
+
+libgnu_la_SOURCES += xsize.h
+
+## end   gnulib module xsize
+
+## begin gnulib module dummy
+
+libgnu_la_SOURCES += dummy.c
+
+## end   gnulib module dummy
+
+
+mostlyclean-local: mostlyclean-generic
+	@for dir in '' $(MOSTLYCLEANDIRS); do \
+	  if test -n "$$dir" && test -d $$dir; then \
+	    echo "rmdir $$dir"; rmdir $$dir; \
+	  fi; \
+	done; \
+	:
Index: lib/alloca.in.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/alloca.in.h	2007-11-07 16:30:53.471997587 +0000
@@ -0,0 +1,54 @@
+/* Memory allocation on the stack.
+
+   Copyright (C) 1995, 1999, 2001-2004, 2006-2007 Free Software
+   Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify it
+   under the terms of the GNU Lesser General Public License as published
+   by the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with this program; if not, write to the Free Software
+   Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301,
+   USA.  */
+
+/* Avoid using the symbol _ALLOCA_H here, as Bison assumes _ALLOCA_H
+   means there is a real alloca function.  */
+#ifndef _GL_ALLOCA_H
+#define _GL_ALLOCA_H
+
+/* alloca (N) returns a pointer to N bytes of memory
+   allocated on the stack, which will last until the function returns.
+   Use of alloca should be avoided:
+     - inside arguments of function calls - undefined behaviour,
+     - in inline functions - the allocation may actually last until the
+       calling function returns,
+     - for huge N (say, N >= 65536) - you never know how large (or small)
+       the stack is, and when the stack cannot fulfill the memory allocation
+       request, the program just crashes.
+ */
+
+#ifndef alloca
+# ifdef __GNUC__
+#  define alloca __builtin_alloca
+# elif defined _AIX
+#  define alloca __alloca
+# elif defined _MSC_VER
+#  include <malloc.h>
+#  define alloca _alloca
+# else
+#  include <stddef.h>
+#  ifdef  __cplusplus
+extern "C"
+#  endif
+void *alloca (size_t);
+# endif
+#endif
+
+#endif /* _GL_ALLOCA_H */
Index: lib/asnprintf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/asnprintf.c	2007-11-07 16:30:53.479266515 +0000
@@ -0,0 +1,35 @@
+/* Formatted output to strings.
+   Copyright (C) 1999, 2002, 2006 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include "vasnprintf.h"
+
+#include <stdarg.h>
+
+char *
+asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)
+{
+  va_list args;
+  char *result;
+
+  va_start (args, format);
+  result = vasnprintf (resultbuf, lengthp, format, args);
+  va_end (args);
+  return result;
+}
Index: lib/dummy.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/dummy.c	2007-11-07 16:30:53.487331240 +0000
@@ -0,0 +1,42 @@
+/* A dummy file, to prevent empty libraries from breaking builds.
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+/* Some systems, reportedly OpenBSD and Mac OS X, refuse to create
+   libraries without any object files.  You might get an error like:
+
+   > ar cru .libs/libgl.a
+   > ar: no archive members specified
+
+   Compiling this file, and adding its object file to the library, will
+   prevent the library from being empty.  */
+
+/* Some systems, such as Solaris with cc 5.0, refuse to work with libraries
+   that don't export any symbol.  You might get an error like:
+
+   > cc ... libgnu.a
+   > ild: (bad file) garbled symbol table in archive ../gllib/libgnu.a
+
+   Compiling this file, and adding its object file to the library, will
+   prevent the library from exporting no symbols.  */
+
+#ifdef __sun
+/* This declaration ensures that the library will export at least 1 symbol.  */
+int gl_dummy_symbol;
+#else
+/* This declaration is solely to ensure that after preprocessing
+   this file is never empty.  */
+typedef int dummy;
+#endif
Index: lib/float+.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/float+.h	2007-11-07 16:30:53.494161443 +0000
@@ -0,0 +1,148 @@
+/* Supplemental information about the floating-point formats.
+   Copyright (C) 2007 Free Software Foundation, Inc.
+   Written by Bruno Haible <bruno@clisp.org>, 2007.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _FLOATPLUS_H
+#define _FLOATPLUS_H
+
+#include <float.h>
+#include <limits.h>
+
+/* Number of bits in the mantissa of a floating-point number, including the
+   "hidden bit".  */
+#if FLT_RADIX == 2
+# define FLT_MANT_BIT FLT_MANT_DIG
+# define DBL_MANT_BIT DBL_MANT_DIG
+# define LDBL_MANT_BIT LDBL_MANT_DIG
+#elif FLT_RADIX == 4
+# define FLT_MANT_BIT (FLT_MANT_DIG * 2)
+# define DBL_MANT_BIT (DBL_MANT_DIG * 2)
+# define LDBL_MANT_BIT (LDBL_MANT_DIG * 2)
+#elif FLT_RADIX == 16
+# define FLT_MANT_BIT (FLT_MANT_DIG * 4)
+# define DBL_MANT_BIT (DBL_MANT_DIG * 4)
+# define LDBL_MANT_BIT (LDBL_MANT_DIG * 4)
+#endif
+
+/* Bit mask that can be used to mask the exponent, as an unsigned number.  */
+#define FLT_EXP_MASK ((FLT_MAX_EXP - FLT_MIN_EXP) | 7)
+#define DBL_EXP_MASK ((DBL_MAX_EXP - DBL_MIN_EXP) | 7)
+#define LDBL_EXP_MASK ((LDBL_MAX_EXP - LDBL_MIN_EXP) | 7)
+
+/* Number of bits used for the exponent of a floating-point number, including
+   the exponent's sign.  */
+#define FLT_EXP_BIT \
+  (FLT_EXP_MASK < 0x100 ? 8 : \
+   FLT_EXP_MASK < 0x200 ? 9 : \
+   FLT_EXP_MASK < 0x400 ? 10 : \
+   FLT_EXP_MASK < 0x800 ? 11 : \
+   FLT_EXP_MASK < 0x1000 ? 12 : \
+   FLT_EXP_MASK < 0x2000 ? 13 : \
+   FLT_EXP_MASK < 0x4000 ? 14 : \
+   FLT_EXP_MASK < 0x8000 ? 15 : \
+   FLT_EXP_MASK < 0x10000 ? 16 : \
+   FLT_EXP_MASK < 0x20000 ? 17 : \
+   FLT_EXP_MASK < 0x40000 ? 18 : \
+   FLT_EXP_MASK < 0x80000 ? 19 : \
+   FLT_EXP_MASK < 0x100000 ? 20 : \
+   FLT_EXP_MASK < 0x200000 ? 21 : \
+   FLT_EXP_MASK < 0x400000 ? 22 : \
+   FLT_EXP_MASK < 0x800000 ? 23 : \
+   FLT_EXP_MASK < 0x1000000 ? 24 : \
+   FLT_EXP_MASK < 0x2000000 ? 25 : \
+   FLT_EXP_MASK < 0x4000000 ? 26 : \
+   FLT_EXP_MASK < 0x8000000 ? 27 : \
+   FLT_EXP_MASK < 0x10000000 ? 28 : \
+   FLT_EXP_MASK < 0x20000000 ? 29 : \
+   FLT_EXP_MASK < 0x40000000 ? 30 : \
+   FLT_EXP_MASK <= 0x7fffffff ? 31 : \
+   32)
+#define DBL_EXP_BIT \
+  (DBL_EXP_MASK < 0x100 ? 8 : \
+   DBL_EXP_MASK < 0x200 ? 9 : \
+   DBL_EXP_MASK < 0x400 ? 10 : \
+   DBL_EXP_MASK < 0x800 ? 11 : \
+   DBL_EXP_MASK < 0x1000 ? 12 : \
+   DBL_EXP_MASK < 0x2000 ? 13 : \
+   DBL_EXP_MASK < 0x4000 ? 14 : \
+   DBL_EXP_MASK < 0x8000 ? 15 : \
+   DBL_EXP_MASK < 0x10000 ? 16 : \
+   DBL_EXP_MASK < 0x20000 ? 17 : \
+   DBL_EXP_MASK < 0x40000 ? 18 : \
+   DBL_EXP_MASK < 0x80000 ? 19 : \
+   DBL_EXP_MASK < 0x100000 ? 20 : \
+   DBL_EXP_MASK < 0x200000 ? 21 : \
+   DBL_EXP_MASK < 0x400000 ? 22 : \
+   DBL_EXP_MASK < 0x800000 ? 23 : \
+   DBL_EXP_MASK < 0x1000000 ? 24 : \
+   DBL_EXP_MASK < 0x2000000 ? 25 : \
+   DBL_EXP_MASK < 0x4000000 ? 26 : \
+   DBL_EXP_MASK < 0x8000000 ? 27 : \
+   DBL_EXP_MASK < 0x10000000 ? 28 : \
+   DBL_EXP_MASK < 0x20000000 ? 29 : \
+   DBL_EXP_MASK < 0x40000000 ? 30 : \
+   DBL_EXP_MASK <= 0x7fffffff ? 31 : \
+   32)
+#define LDBL_EXP_BIT \
+  (LDBL_EXP_MASK < 0x100 ? 8 : \
+   LDBL_EXP_MASK < 0x200 ? 9 : \
+   LDBL_EXP_MASK < 0x400 ? 10 : \
+   LDBL_EXP_MASK < 0x800 ? 11 : \
+   LDBL_EXP_MASK < 0x1000 ? 12 : \
+   LDBL_EXP_MASK < 0x2000 ? 13 : \
+   LDBL_EXP_MASK < 0x4000 ? 14 : \
+   LDBL_EXP_MASK < 0x8000 ? 15 : \
+   LDBL_EXP_MASK < 0x10000 ? 16 : \
+   LDBL_EXP_MASK < 0x20000 ? 17 : \
+   LDBL_EXP_MASK < 0x40000 ? 18 : \
+   LDBL_EXP_MASK < 0x80000 ? 19 : \
+   LDBL_EXP_MASK < 0x100000 ? 20 : \
+   LDBL_EXP_MASK < 0x200000 ? 21 : \
+   LDBL_EXP_MASK < 0x400000 ? 22 : \
+   LDBL_EXP_MASK < 0x800000 ? 23 : \
+   LDBL_EXP_MASK < 0x1000000 ? 24 : \
+   LDBL_EXP_MASK < 0x2000000 ? 25 : \
+   LDBL_EXP_MASK < 0x4000000 ? 26 : \
+   LDBL_EXP_MASK < 0x8000000 ? 27 : \
+   LDBL_EXP_MASK < 0x10000000 ? 28 : \
+   LDBL_EXP_MASK < 0x20000000 ? 29 : \
+   LDBL_EXP_MASK < 0x40000000 ? 30 : \
+   LDBL_EXP_MASK <= 0x7fffffff ? 31 : \
+   32)
+
+/* Number of bits used for a floating-point number: the mantissa (not
+   counting the "hidden bit", since it may or may not be explicit), the
+   exponent, and the sign.  */
+#define FLT_TOTAL_BIT ((FLT_MANT_BIT - 1) + FLT_EXP_BIT + 1)
+#define DBL_TOTAL_BIT ((DBL_MANT_BIT - 1) + DBL_EXP_BIT + 1)
+#define LDBL_TOTAL_BIT ((LDBL_MANT_BIT - 1) + LDBL_EXP_BIT + 1)
+
+/* Number of bytes used for a floating-point number.
+   This can be smaller than the 'sizeof'.  For example, on i386 systems,
+   'long double' most often have LDBL_MANT_BIT = 64, LDBL_EXP_BIT = 16, hence
+   LDBL_TOTAL_BIT = 80 bits, i.e. 10 bytes of consecutive memory, but
+   sizeof (long double) = 12 or = 16.  */
+#define SIZEOF_FLT ((FLT_TOTAL_BIT + CHAR_BIT - 1) / CHAR_BIT)
+#define SIZEOF_DBL ((DBL_TOTAL_BIT + CHAR_BIT - 1) / CHAR_BIT)
+#define SIZEOF_LDBL ((LDBL_TOTAL_BIT + CHAR_BIT - 1) / CHAR_BIT)
+
+/* Verify that SIZEOF_FLT <= sizeof (float) etc.  */
+typedef int verify_sizeof_flt[2 * (SIZEOF_FLT <= sizeof (float)) - 1];
+typedef int verify_sizeof_dbl[2 * (SIZEOF_DBL <= sizeof (double)) - 1];
+typedef int verify_sizeof_ldbl[2 * (SIZEOF_LDBL <= sizeof (long double)) - 1];
+
+#endif /* _FLOATPLUS_H */
Index: lib/float.in.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/float.in.h	2007-11-07 16:30:53.509812070 +0000
@@ -0,0 +1,58 @@
+/* A correct <float.h>.
+
+   Copyright (C) 2007 Free Software Foundation, Inc.
+
+   This program is free software: you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1 of the License, or
+   (at your option) any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */
+
+#ifndef _GL_FLOAT_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_FLOAT_H@
+
+#ifndef _GL_FLOAT_H
+#define _GL_FLOAT_H
+
+/* 'long double' properties.  */
+#if defined __i386__ && defined __BEOS__
+/* Number of mantissa units, in base FLT_RADIX.  */
+# undef LDBL_MANT_DIG
+# define LDBL_MANT_DIG   64
+/* Number of decimal digits that is sufficient for representing a number.  */
+# undef LDBL_DIG
+# define LDBL_DIG        18
+/* x-1 where x is the smallest representable number > 1.  */
+# undef LDBL_EPSILON
+# define LDBL_EPSILON    1.0842021724855044340E-19L
+/* Minimum e such that FLT_RADIX^(e-1) is a normalized number.  */
+# undef LDBL_MIN_EXP
+# define LDBL_MIN_EXP    (-16381)
+/* Maximum e such that FLT_RADIX^(e-1) is a representable finite number.  */
+# undef LDBL_MAX_EXP
+# define LDBL_MAX_EXP    16384
+/* Minimum positive normalized number.  */
+# undef LDBL_MIN
+# define LDBL_MIN        3.3621031431120935063E-4932L
+/* Maximum representable finite number.  */
+# undef LDBL_MAX
+# define LDBL_MAX        1.1897314953572317650E+4932L
+/* Minimum e such that 10^e is in the range of normalized numbers.  */
+# undef LDBL_MIN_10_EXP
+# define LDBL_MIN_10_EXP (-4931)
+/* Maximum e such that 10^e is in the range of representable finite numbers.  */
+# undef LDBL_MAX_10_EXP
+# define LDBL_MAX_10_EXP 4932
+#endif
+
+#endif /* _GL_FLOAT_H */
+#endif /* _GL_FLOAT_H */
Index: lib/printf-args.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/printf-args.c	2007-11-07 16:30:53.516376095 +0000
@@ -0,0 +1,187 @@
+/* Decomposed printf argument list.
+   Copyright (C) 1999, 2002-2003, 2005-2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* This file can be parametrized with the following macros:
+     ENABLE_UNISTDIO    Set to 1 to enable the unistdio extensions.
+     PRINTF_FETCHARGS   Name of the function to be defined.
+     STATIC             Set to 'static' to declare the function static.  */
+
+#ifndef PRINTF_FETCHARGS
+# include <config.h>
+#endif
+
+/* Specification.  */
+#ifndef PRINTF_FETCHARGS
+# include "printf-args.h"
+#endif
+
+#ifdef STATIC
+STATIC
+#endif
+int
+PRINTF_FETCHARGS (va_list args, arguments *a)
+{
+  size_t i;
+  argument *ap;
+
+  for (i = 0, ap = &a->arg[0]; i < a->count; i++, ap++)
+    switch (ap->type)
+      {
+      case TYPE_SCHAR:
+	ap->a.a_schar = va_arg (args, /*signed char*/ int);
+	break;
+      case TYPE_UCHAR:
+	ap->a.a_uchar = va_arg (args, /*unsigned char*/ int);
+	break;
+      case TYPE_SHORT:
+	ap->a.a_short = va_arg (args, /*short*/ int);
+	break;
+      case TYPE_USHORT:
+	ap->a.a_ushort = va_arg (args, /*unsigned short*/ int);
+	break;
+      case TYPE_INT:
+	ap->a.a_int = va_arg (args, int);
+	break;
+      case TYPE_UINT:
+	ap->a.a_uint = va_arg (args, unsigned int);
+	break;
+      case TYPE_LONGINT:
+	ap->a.a_longint = va_arg (args, long int);
+	break;
+      case TYPE_ULONGINT:
+	ap->a.a_ulongint = va_arg (args, unsigned long int);
+	break;
+#if HAVE_LONG_LONG_INT
+      case TYPE_LONGLONGINT:
+	ap->a.a_longlongint = va_arg (args, long long int);
+	break;
+      case TYPE_ULONGLONGINT:
+	ap->a.a_ulonglongint = va_arg (args, unsigned long long int);
+	break;
+#endif
+      case TYPE_DOUBLE:
+	ap->a.a_double = va_arg (args, double);
+	break;
+      case TYPE_LONGDOUBLE:
+	ap->a.a_longdouble = va_arg (args, long double);
+	break;
+      case TYPE_CHAR:
+	ap->a.a_char = va_arg (args, int);
+	break;
+#if HAVE_WINT_T
+      case TYPE_WIDE_CHAR:
+	/* Although ISO C 99 7.24.1.(2) says that wint_t is "unchanged by
+	   default argument promotions", this is not the case in mingw32,
+	   where wint_t is 'unsigned short'.  */
+	ap->a.a_wide_char =
+	  (sizeof (wint_t) < sizeof (int)
+	   ? va_arg (args, int)
+	   : va_arg (args, wint_t));
+	break;
+#endif
+      case TYPE_STRING:
+	ap->a.a_string = va_arg (args, const char *);
+	/* A null pointer is an invalid argument for "%s", but in practice
+	   it occurs quite frequently in printf statements that produce
+	   debug output.  Use a fallback in this case.  */
+	if (ap->a.a_string == NULL)
+	  ap->a.a_string = "(NULL)";
+	break;
+#if HAVE_WCHAR_T
+      case TYPE_WIDE_STRING:
+	ap->a.a_wide_string = va_arg (args, const wchar_t *);
+	/* A null pointer is an invalid argument for "%ls", but in practice
+	   it occurs quite frequently in printf statements that produce
+	   debug output.  Use a fallback in this case.  */
+	if (ap->a.a_wide_string == NULL)
+	  {
+	    static const wchar_t wide_null_string[] =
+	      {
+		(wchar_t)'(',
+		(wchar_t)'N', (wchar_t)'U', (wchar_t)'L', (wchar_t)'L',
+		(wchar_t)')',
+		(wchar_t)0
+	      };
+	    ap->a.a_wide_string = wide_null_string;
+	  }
+	break;
+#endif
+      case TYPE_POINTER:
+	ap->a.a_pointer = va_arg (args, void *);
+	break;
+      case TYPE_COUNT_SCHAR_POINTER:
+	ap->a.a_count_schar_pointer = va_arg (args, signed char *);
+	break;
+      case TYPE_COUNT_SHORT_POINTER:
+	ap->a.a_count_short_pointer = va_arg (args, short *);
+	break;
+      case TYPE_COUNT_INT_POINTER:
+	ap->a.a_count_int_pointer = va_arg (args, int *);
+	break;
+      case TYPE_COUNT_LONGINT_POINTER:
+	ap->a.a_count_longint_pointer = va_arg (args, long int *);
+	break;
+#if HAVE_LONG_LONG_INT
+      case TYPE_COUNT_LONGLONGINT_POINTER:
+	ap->a.a_count_longlongint_pointer = va_arg (args, long long int *);
+	break;
+#endif
+#if ENABLE_UNISTDIO
+      /* The unistdio extensions.  */
+      case TYPE_U8_STRING:
+	ap->a.a_u8_string = va_arg (args, const uint8_t *);
+	/* A null pointer is an invalid argument for "%U", but in practice
+	   it occurs quite frequently in printf statements that produce
+	   debug output.  Use a fallback in this case.  */
+	if (ap->a.a_u8_string == NULL)
+	  {
+	    static const uint8_t u8_null_string[] =
+	      { '(', 'N', 'U', 'L', 'L', ')', 0 };
+	    ap->a.a_u8_string = u8_null_string;
+	  }
+	break;
+      case TYPE_U16_STRING:
+	ap->a.a_u16_string = va_arg (args, const uint16_t *);
+	/* A null pointer is an invalid argument for "%lU", but in practice
+	   it occurs quite frequently in printf statements that produce
+	   debug output.  Use a fallback in this case.  */
+	if (ap->a.a_u16_string == NULL)
+	  {
+	    static const uint16_t u16_null_string[] =
+	      { '(', 'N', 'U', 'L', 'L', ')', 0 };
+	    ap->a.a_u16_string = u16_null_string;
+	  }
+	break;
+      case TYPE_U32_STRING:
+	ap->a.a_u32_string = va_arg (args, const uint32_t *);
+	/* A null pointer is an invalid argument for "%llU", but in practice
+	   it occurs quite frequently in printf statements that produce
+	   debug output.  Use a fallback in this case.  */
+	if (ap->a.a_u32_string == NULL)
+	  {
+	    static const uint32_t u32_null_string[] =
+	      { '(', 'N', 'U', 'L', 'L', ')', 0 };
+	    ap->a.a_u32_string = u32_null_string;
+	  }
+	break;
+#endif
+      default:
+	/* Unknown type.  */
+	return -1;
+      }
+  return 0;
+}
Index: lib/printf-args.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/printf-args.h	2007-11-07 16:30:53.524950339 +0000
@@ -0,0 +1,154 @@
+/* Decomposed printf argument list.
+   Copyright (C) 1999, 2002-2003, 2006-2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _PRINTF_ARGS_H
+#define _PRINTF_ARGS_H
+
+/* This file can be parametrized with the following macros:
+     ENABLE_UNISTDIO    Set to 1 to enable the unistdio extensions.
+     PRINTF_FETCHARGS   Name of the function to be declared.
+     STATIC             Set to 'static' to declare the function static.  */
+
+/* Default parameters.  */
+#ifndef PRINTF_FETCHARGS
+# define PRINTF_FETCHARGS printf_fetchargs
+#endif
+
+/* Get size_t.  */
+#include <stddef.h>
+
+/* Get wchar_t.  */
+#if HAVE_WCHAR_T
+# include <stddef.h>
+#endif
+
+/* Get wint_t.  */
+#if HAVE_WINT_T
+# include <wchar.h>
+#endif
+
+/* Get va_list.  */
+#include <stdarg.h>
+
+
+/* Argument types */
+typedef enum
+{
+  TYPE_NONE,
+  TYPE_SCHAR,
+  TYPE_UCHAR,
+  TYPE_SHORT,
+  TYPE_USHORT,
+  TYPE_INT,
+  TYPE_UINT,
+  TYPE_LONGINT,
+  TYPE_ULONGINT,
+#if HAVE_LONG_LONG_INT
+  TYPE_LONGLONGINT,
+  TYPE_ULONGLONGINT,
+#endif
+  TYPE_DOUBLE,
+  TYPE_LONGDOUBLE,
+  TYPE_CHAR,
+#if HAVE_WINT_T
+  TYPE_WIDE_CHAR,
+#endif
+  TYPE_STRING,
+#if HAVE_WCHAR_T
+  TYPE_WIDE_STRING,
+#endif
+  TYPE_POINTER,
+  TYPE_COUNT_SCHAR_POINTER,
+  TYPE_COUNT_SHORT_POINTER,
+  TYPE_COUNT_INT_POINTER,
+  TYPE_COUNT_LONGINT_POINTER
+#if HAVE_LONG_LONG_INT
+, TYPE_COUNT_LONGLONGINT_POINTER
+#endif
+#if ENABLE_UNISTDIO
+  /* The unistdio extensions.  */
+, TYPE_U8_STRING
+, TYPE_U16_STRING
+, TYPE_U32_STRING
+#endif
+} arg_type;
+
+/* Polymorphic argument */
+typedef struct
+{
+  arg_type type;
+  union
+  {
+    signed char			a_schar;
+    unsigned char		a_uchar;
+    short			a_short;
+    unsigned short		a_ushort;
+    int				a_int;
+    unsigned int		a_uint;
+    long int			a_longint;
+    unsigned long int		a_ulongint;
+#if HAVE_LONG_LONG_INT
+    long long int		a_longlongint;
+    unsigned long long int	a_ulonglongint;
+#endif
+    float			a_float;
+    double			a_double;
+    long double			a_longdouble;
+    int				a_char;
+#if HAVE_WINT_T
+    wint_t			a_wide_char;
+#endif
+    const char*			a_string;
+#if HAVE_WCHAR_T
+    const wchar_t*		a_wide_string;
+#endif
+    void*			a_pointer;
+    signed char *		a_count_schar_pointer;
+    short *			a_count_short_pointer;
+    int *			a_count_int_pointer;
+    long int *			a_count_longint_pointer;
+#if HAVE_LONG_LONG_INT
+    long long int *		a_count_longlongint_pointer;
+#endif
+#if ENABLE_UNISTDIO
+    /* The unistdio extensions.  */
+    const uint8_t *		a_u8_string;
+    const uint16_t *		a_u16_string;
+    const uint32_t *		a_u32_string;
+#endif
+  }
+  a;
+}
+argument;
+
+typedef struct
+{
+  size_t count;
+  argument *arg;
+}
+arguments;
+
+
+/* Fetch the arguments, putting them into a. */
+#ifdef STATIC
+STATIC
+#else
+extern
+#endif
+int PRINTF_FETCHARGS (va_list args, arguments *a);
+
+#endif /* _PRINTF_ARGS_H */
Index: lib/printf-parse.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/printf-parse.c	2007-11-07 16:30:53.532629124 +0000
@@ -0,0 +1,576 @@
+/* Formatted output to strings.
+   Copyright (C) 1999-2000, 2002-2003, 2006-2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* This file can be parametrized with the following macros:
+     CHAR_T             The element type of the format string.
+     CHAR_T_ONLY_ASCII  Set to 1 to enable verification that all characters
+                        in the format string are ASCII.
+     DIRECTIVE          Structure denoting a format directive.
+                        Depends on CHAR_T.
+     DIRECTIVES         Structure denoting the set of format directives of a
+                        format string.  Depends on CHAR_T.
+     PRINTF_PARSE       Function that parses a format string.
+                        Depends on CHAR_T.
+     STATIC             Set to 'static' to declare the function static.
+     ENABLE_UNISTDIO    Set to 1 to enable the unistdio extensions.  */
+
+#ifndef PRINTF_PARSE
+# include <config.h>
+#endif
+
+/* Specification.  */
+#ifndef PRINTF_PARSE
+# include "printf-parse.h"
+#endif
+
+/* Default parameters.  */
+#ifndef PRINTF_PARSE
+# define PRINTF_PARSE printf_parse
+# define CHAR_T char
+# define DIRECTIVE char_directive
+# define DIRECTIVES char_directives
+#endif
+
+/* Get size_t, NULL.  */
+#include <stddef.h>
+
+/* Get intmax_t.  */
+#if defined IN_LIBINTL || defined IN_LIBASPRINTF
+# if HAVE_STDINT_H_WITH_UINTMAX
+#  include <stdint.h>
+# endif
+# if HAVE_INTTYPES_H_WITH_UINTMAX
+#  include <inttypes.h>
+# endif
+#else
+# include <stdint.h>
+#endif
+
+/* malloc(), realloc(), free().  */
+#include <stdlib.h>
+
+/* Checked size_t computations.  */
+#include "xsize.h"
+
+#if CHAR_T_ONLY_ASCII
+/* c_isascii().  */
+# include "c-ctype.h"
+#endif
+
+#ifdef STATIC
+STATIC
+#endif
+int
+PRINTF_PARSE (const CHAR_T *format, DIRECTIVES *d, arguments *a)
+{
+  const CHAR_T *cp = format;		/* pointer into format */
+  size_t arg_posn = 0;		/* number of regular arguments consumed */
+  size_t d_allocated;			/* allocated elements of d->dir */
+  size_t a_allocated;			/* allocated elements of a->arg */
+  size_t max_width_length = 0;
+  size_t max_precision_length = 0;
+
+  d->count = 0;
+  d_allocated = 1;
+  d->dir = (DIRECTIVE *) malloc (d_allocated * sizeof (DIRECTIVE));
+  if (d->dir == NULL)
+    /* Out of memory.  */
+    return -1;
+
+  a->count = 0;
+  a_allocated = 0;
+  a->arg = NULL;
+
+#define REGISTER_ARG(_index_,_type_) \
+  {									\
+    size_t n = (_index_);						\
+    if (n >= a_allocated)						\
+      {									\
+	size_t memory_size;						\
+	argument *memory;						\
+									\
+	a_allocated = xtimes (a_allocated, 2);				\
+	if (a_allocated <= n)						\
+	  a_allocated = xsum (n, 1);					\
+	memory_size = xtimes (a_allocated, sizeof (argument));		\
+	if (size_overflow_p (memory_size))				\
+	  /* Overflow, would lead to out of memory.  */			\
+	  goto error;							\
+	memory = (argument *) (a->arg					\
+			       ? realloc (a->arg, memory_size)		\
+			       : malloc (memory_size));			\
+	if (memory == NULL)						\
+	  /* Out of memory.  */						\
+	  goto error;							\
+	a->arg = memory;						\
+      }									\
+    while (a->count <= n)						\
+      a->arg[a->count++].type = TYPE_NONE;				\
+    if (a->arg[n].type == TYPE_NONE)					\
+      a->arg[n].type = (_type_);					\
+    else if (a->arg[n].type != (_type_))				\
+      /* Ambiguous type for positional argument.  */			\
+      goto error;							\
+  }
+
+  while (*cp != '\0')
+    {
+      CHAR_T c = *cp++;
+      if (c == '%')
+	{
+	  size_t arg_index = ARG_NONE;
+	  DIRECTIVE *dp = &d->dir[d->count]; /* pointer to next directive */
+
+	  /* Initialize the next directive.  */
+	  dp->dir_start = cp - 1;
+	  dp->flags = 0;
+	  dp->width_start = NULL;
+	  dp->width_end = NULL;
+	  dp->width_arg_index = ARG_NONE;
+	  dp->precision_start = NULL;
+	  dp->precision_end = NULL;
+	  dp->precision_arg_index = ARG_NONE;
+	  dp->arg_index = ARG_NONE;
+
+	  /* Test for positional argument.  */
+	  if (*cp >= '0' && *cp <= '9')
+	    {
+	      const CHAR_T *np;
+
+	      for (np = cp; *np >= '0' && *np <= '9'; np++)
+		;
+	      if (*np == '$')
+		{
+		  size_t n = 0;
+
+		  for (np = cp; *np >= '0' && *np <= '9'; np++)
+		    n = xsum (xtimes (n, 10), *np - '0');
+		  if (n == 0)
+		    /* Positional argument 0.  */
+		    goto error;
+		  if (size_overflow_p (n))
+		    /* n too large, would lead to out of memory later.  */
+		    goto error;
+		  arg_index = n - 1;
+		  cp = np + 1;
+		}
+	    }
+
+	  /* Read the flags.  */
+	  for (;;)
+	    {
+	      if (*cp == '\'')
+		{
+		  dp->flags |= FLAG_GROUP;
+		  cp++;
+		}
+	      else if (*cp == '-')
+		{
+		  dp->flags |= FLAG_LEFT;
+		  cp++;
+		}
+	      else if (*cp == '+')
+		{
+		  dp->flags |= FLAG_SHOWSIGN;
+		  cp++;
+		}
+	      else if (*cp == ' ')
+		{
+		  dp->flags |= FLAG_SPACE;
+		  cp++;
+		}
+	      else if (*cp == '#')
+		{
+		  dp->flags |= FLAG_ALT;
+		  cp++;
+		}
+	      else if (*cp == '0')
+		{
+		  dp->flags |= FLAG_ZERO;
+		  cp++;
+		}
+	      else
+		break;
+	    }
+
+	  /* Parse the field width.  */
+	  if (*cp == '*')
+	    {
+	      dp->width_start = cp;
+	      cp++;
+	      dp->width_end = cp;
+	      if (max_width_length < 1)
+		max_width_length = 1;
+
+	      /* Test for positional argument.  */
+	      if (*cp >= '0' && *cp <= '9')
+		{
+		  const CHAR_T *np;
+
+		  for (np = cp; *np >= '0' && *np <= '9'; np++)
+		    ;
+		  if (*np == '$')
+		    {
+		      size_t n = 0;
+
+		      for (np = cp; *np >= '0' && *np <= '9'; np++)
+			n = xsum (xtimes (n, 10), *np - '0');
+		      if (n == 0)
+			/* Positional argument 0.  */
+			goto error;
+		      if (size_overflow_p (n))
+			/* n too large, would lead to out of memory later.  */
+			goto error;
+		      dp->width_arg_index = n - 1;
+		      cp = np + 1;
+		    }
+		}
+	      if (dp->width_arg_index == ARG_NONE)
+		{
+		  dp->width_arg_index = arg_posn++;
+		  if (dp->width_arg_index == ARG_NONE)
+		    /* arg_posn wrapped around.  */
+		    goto error;
+		}
+	      REGISTER_ARG (dp->width_arg_index, TYPE_INT);
+	    }
+	  else if (*cp >= '0' && *cp <= '9')
+	    {
+	      size_t width_length;
+
+	      dp->width_start = cp;
+	      for (; *cp >= '0' && *cp <= '9'; cp++)
+		;
+	      dp->width_end = cp;
+	      width_length = dp->width_end - dp->width_start;
+	      if (max_width_length < width_length)
+		max_width_length = width_length;
+	    }
+
+	  /* Parse the precision.  */
+	  if (*cp == '.')
+	    {
+	      cp++;
+	      if (*cp == '*')
+		{
+		  dp->precision_start = cp - 1;
+		  cp++;
+		  dp->precision_end = cp;
+		  if (max_precision_length < 2)
+		    max_precision_length = 2;
+
+		  /* Test for positional argument.  */
+		  if (*cp >= '0' && *cp <= '9')
+		    {
+		      const CHAR_T *np;
+
+		      for (np = cp; *np >= '0' && *np <= '9'; np++)
+			;
+		      if (*np == '$')
+			{
+			  size_t n = 0;
+
+			  for (np = cp; *np >= '0' && *np <= '9'; np++)
+			    n = xsum (xtimes (n, 10), *np - '0');
+			  if (n == 0)
+			    /* Positional argument 0.  */
+			    goto error;
+			  if (size_overflow_p (n))
+			    /* n too large, would lead to out of memory
+			       later.  */
+			    goto error;
+			  dp->precision_arg_index = n - 1;
+			  cp = np + 1;
+			}
+		    }
+		  if (dp->precision_arg_index == ARG_NONE)
+		    {
+		      dp->precision_arg_index = arg_posn++;
+		      if (dp->precision_arg_index == ARG_NONE)
+			/* arg_posn wrapped around.  */
+			goto error;
+		    }
+		  REGISTER_ARG (dp->precision_arg_index, TYPE_INT);
+		}
+	      else
+		{
+		  size_t precision_length;
+
+		  dp->precision_start = cp - 1;
+		  for (; *cp >= '0' && *cp <= '9'; cp++)
+		    ;
+		  dp->precision_end = cp;
+		  precision_length = dp->precision_end - dp->precision_start;
+		  if (max_precision_length < precision_length)
+		    max_precision_length = precision_length;
+		}
+	    }
+
+	  {
+	    arg_type type;
+
+	    /* Parse argument type/size specifiers.  */
+	    {
+	      int flags = 0;
+
+	      for (;;)
+		{
+		  if (*cp == 'h')
+		    {
+		      flags |= (1 << (flags & 1));
+		      cp++;
+		    }
+		  else if (*cp == 'L')
+		    {
+		      flags |= 4;
+		      cp++;
+		    }
+		  else if (*cp == 'l')
+		    {
+		      flags += 8;
+		      cp++;
+		    }
+		  else if (*cp == 'j')
+		    {
+		      if (sizeof (intmax_t) > sizeof (long))
+			{
+			  /* intmax_t = long long */
+			  flags += 16;
+			}
+		      else if (sizeof (intmax_t) > sizeof (int))
+			{
+			  /* intmax_t = long */
+			  flags += 8;
+			}
+		      cp++;
+		    }
+		  else if (*cp == 'z' || *cp == 'Z')
+		    {
+		      /* 'z' is standardized in ISO C 99, but glibc uses 'Z'
+			 because the warning facility in gcc-2.95.2 understands
+			 only 'Z' (see gcc-2.95.2/gcc/c-common.c:1784).  */
+		      if (sizeof (size_t) > sizeof (long))
+			{
+			  /* size_t = long long */
+			  flags += 16;
+			}
+		      else if (sizeof (size_t) > sizeof (int))
+			{
+			  /* size_t = long */
+			  flags += 8;
+			}
+		      cp++;
+		    }
+		  else if (*cp == 't')
+		    {
+		      if (sizeof (ptrdiff_t) > sizeof (long))
+			{
+			  /* ptrdiff_t = long long */
+			  flags += 16;
+			}
+		      else if (sizeof (ptrdiff_t) > sizeof (int))
+			{
+			  /* ptrdiff_t = long */
+			  flags += 8;
+			}
+		      cp++;
+		    }
+		  else
+		    break;
+		}
+
+	      /* Read the conversion character.  */
+	      c = *cp++;
+	      switch (c)
+		{
+		case 'd': case 'i':
+#if HAVE_LONG_LONG_INT
+		  /* If 'long long' exists and is larger than 'long':  */
+		  if (flags >= 16 || (flags & 4))
+		    type = TYPE_LONGLONGINT;
+		  else
+#endif
+		  /* If 'long long' exists and is the same as 'long', we parse
+		     "lld" into TYPE_LONGINT.  */
+		  if (flags >= 8)
+		    type = TYPE_LONGINT;
+		  else if (flags & 2)
+		    type = TYPE_SCHAR;
+		  else if (flags & 1)
+		    type = TYPE_SHORT;
+		  else
+		    type = TYPE_INT;
+		  break;
+		case 'o': case 'u': case 'x': case 'X':
+#if HAVE_LONG_LONG_INT
+		  /* If 'long long' exists and is larger than 'long':  */
+		  if (flags >= 16 || (flags & 4))
+		    type = TYPE_ULONGLONGINT;
+		  else
+#endif
+		  /* If 'unsigned long long' exists and is the same as
+		     'unsigned long', we parse "llu" into TYPE_ULONGINT.  */
+		  if (flags >= 8)
+		    type = TYPE_ULONGINT;
+		  else if (flags & 2)
+		    type = TYPE_UCHAR;
+		  else if (flags & 1)
+		    type = TYPE_USHORT;
+		  else
+		    type = TYPE_UINT;
+		  break;
+		case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':
+		case 'a': case 'A':
+		  if (flags >= 16 || (flags & 4))
+		    type = TYPE_LONGDOUBLE;
+		  else
+		    type = TYPE_DOUBLE;
+		  break;
+		case 'c':
+		  if (flags >= 8)
+#if HAVE_WINT_T
+		    type = TYPE_WIDE_CHAR;
+#else
+		    goto error;
+#endif
+		  else
+		    type = TYPE_CHAR;
+		  break;
+#if HAVE_WINT_T
+		case 'C':
+		  type = TYPE_WIDE_CHAR;
+		  c = 'c';
+		  break;
+#endif
+		case 's':
+		  if (flags >= 8)
+#if HAVE_WCHAR_T
+		    type = TYPE_WIDE_STRING;
+#else
+		    goto error;
+#endif
+		  else
+		    type = TYPE_STRING;
+		  break;
+#if HAVE_WCHAR_T
+		case 'S':
+		  type = TYPE_WIDE_STRING;
+		  c = 's';
+		  break;
+#endif
+		case 'p':
+		  type = TYPE_POINTER;
+		  break;
+		case 'n':
+#if HAVE_LONG_LONG_INT
+		  /* If 'long long' exists and is larger than 'long':  */
+		  if (flags >= 16 || (flags & 4))
+		    type = TYPE_COUNT_LONGLONGINT_POINTER;
+		  else
+#endif
+		  /* If 'long long' exists and is the same as 'long', we parse
+		     "lln" into TYPE_COUNT_LONGINT_POINTER.  */
+		  if (flags >= 8)
+		    type = TYPE_COUNT_LONGINT_POINTER;
+		  else if (flags & 2)
+		    type = TYPE_COUNT_SCHAR_POINTER;
+		  else if (flags & 1)
+		    type = TYPE_COUNT_SHORT_POINTER;
+		  else
+		    type = TYPE_COUNT_INT_POINTER;
+		  break;
+#if ENABLE_UNISTDIO
+		/* The unistdio extensions.  */
+		case 'U':
+		  if (flags >= 16)
+		    type = TYPE_U32_STRING;
+		  else if (flags >= 8)
+		    type = TYPE_U16_STRING;
+		  else
+		    type = TYPE_U8_STRING;
+		  break;
+#endif
+		case '%':
+		  type = TYPE_NONE;
+		  break;
+		default:
+		  /* Unknown conversion character.  */
+		  goto error;
+		}
+	    }
+
+	    if (type != TYPE_NONE)
+	      {
+		dp->arg_index = arg_index;
+		if (dp->arg_index == ARG_NONE)
+		  {
+		    dp->arg_index = arg_posn++;
+		    if (dp->arg_index == ARG_NONE)
+		      /* arg_posn wrapped around.  */
+		      goto error;
+		  }
+		REGISTER_ARG (dp->arg_index, type);
+	      }
+	    dp->conversion = c;
+	    dp->dir_end = cp;
+	  }
+
+	  d->count++;
+	  if (d->count >= d_allocated)
+	    {
+	      size_t memory_size;
+	      DIRECTIVE *memory;
+
+	      d_allocated = xtimes (d_allocated, 2);
+	      memory_size = xtimes (d_allocated, sizeof (DIRECTIVE));
+	      if (size_overflow_p (memory_size))
+		/* Overflow, would lead to out of memory.  */
+		goto error;
+	      memory = (DIRECTIVE *) realloc (d->dir, memory_size);
+	      if (memory == NULL)
+		/* Out of memory.  */
+		goto error;
+	      d->dir = memory;
+	    }
+	}
+#if CHAR_T_ONLY_ASCII
+      else if (!c_isascii (c))
+	{
+	  /* Non-ASCII character.  Not supported.  */
+	  goto error;
+	}
+#endif
+    }
+  d->dir[d->count].dir_start = cp;
+
+  d->max_width_length = max_width_length;
+  d->max_precision_length = max_precision_length;
+  return 0;
+
+error:
+  if (a->arg)
+    free (a->arg);
+  if (d->dir)
+    free (d->dir);
+  return -1;
+}
+
+#undef PRINTF_PARSE
+#undef DIRECTIVES
+#undef DIRECTIVE
+#undef CHAR_T_ONLY_ASCII
+#undef CHAR_T
Index: lib/printf-parse.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/printf-parse.h	2007-11-07 16:30:53.540612299 +0000
@@ -0,0 +1,179 @@
+/* Parse printf format string.
+   Copyright (C) 1999, 2002-2003, 2005, 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _PRINTF_PARSE_H
+#define _PRINTF_PARSE_H
+
+/* This file can be parametrized with the following macros:
+     ENABLE_UNISTDIO    Set to 1 to enable the unistdio extensions.
+     STATIC             Set to 'static' to declare the function static.  */
+
+#include "printf-args.h"
+
+
+/* Flags */
+#define FLAG_GROUP	 1	/* ' flag */
+#define FLAG_LEFT	 2	/* - flag */
+#define FLAG_SHOWSIGN	 4	/* + flag */
+#define FLAG_SPACE	 8	/* space flag */
+#define FLAG_ALT	16	/* # flag */
+#define FLAG_ZERO	32
+
+/* arg_index value indicating that no argument is consumed.  */
+#define ARG_NONE	(~(size_t)0)
+
+/* xxx_directive: A parsed directive.
+   xxx_directives: A parsed format string.  */
+
+/* A parsed directive.  */
+typedef struct
+{
+  const char* dir_start;
+  const char* dir_end;
+  int flags;
+  const char* width_start;
+  const char* width_end;
+  size_t width_arg_index;
+  const char* precision_start;
+  const char* precision_end;
+  size_t precision_arg_index;
+  char conversion; /* d i o u x X f F e E g G a A c s p n U % but not C S */
+  size_t arg_index;
+}
+char_directive;
+
+/* A parsed format string.  */
+typedef struct
+{
+  size_t count;
+  char_directive *dir;
+  size_t max_width_length;
+  size_t max_precision_length;
+}
+char_directives;
+
+#if ENABLE_UNISTDIO
+
+/* A parsed directive.  */
+typedef struct
+{
+  const uint8_t* dir_start;
+  const uint8_t* dir_end;
+  int flags;
+  const uint8_t* width_start;
+  const uint8_t* width_end;
+  size_t width_arg_index;
+  const uint8_t* precision_start;
+  const uint8_t* precision_end;
+  size_t precision_arg_index;
+  uint8_t conversion; /* d i o u x X f F e E g G a A c s p n U % but not C S */
+  size_t arg_index;
+}
+u8_directive;
+
+/* A parsed format string.  */
+typedef struct
+{
+  size_t count;
+  u8_directive *dir;
+  size_t max_width_length;
+  size_t max_precision_length;
+}
+u8_directives;
+
+/* A parsed directive.  */
+typedef struct
+{
+  const uint16_t* dir_start;
+  const uint16_t* dir_end;
+  int flags;
+  const uint16_t* width_start;
+  const uint16_t* width_end;
+  size_t width_arg_index;
+  const uint16_t* precision_start;
+  const uint16_t* precision_end;
+  size_t precision_arg_index;
+  uint16_t conversion; /* d i o u x X f F e E g G a A c s p n U % but not C S */
+  size_t arg_index;
+}
+u16_directive;
+
+/* A parsed format string.  */
+typedef struct
+{
+  size_t count;
+  u16_directive *dir;
+  size_t max_width_length;
+  size_t max_precision_length;
+}
+u16_directives;
+
+/* A parsed directive.  */
+typedef struct
+{
+  const uint32_t* dir_start;
+  const uint32_t* dir_end;
+  int flags;
+  const uint32_t* width_start;
+  const uint32_t* width_end;
+  size_t width_arg_index;
+  const uint32_t* precision_start;
+  const uint32_t* precision_end;
+  size_t precision_arg_index;
+  uint32_t conversion; /* d i o u x X f F e E g G a A c s p n U % but not C S */
+  size_t arg_index;
+}
+u32_directive;
+
+/* A parsed format string.  */
+typedef struct
+{
+  size_t count;
+  u32_directive *dir;
+  size_t max_width_length;
+  size_t max_precision_length;
+}
+u32_directives;
+
+#endif
+
+
+/* Parses the format string.  Fills in the number N of directives, and fills
+   in directives[0], ..., directives[N-1], and sets directives[N].dir_start
+   to the end of the format string.  Also fills in the arg_type fields of the
+   arguments and the needed count of arguments.  */
+#if ENABLE_UNISTDIO
+extern int
+       ulc_printf_parse (const char *format, char_directives *d, arguments *a);
+extern int
+       u8_printf_parse (const uint8_t *format, u8_directives *d, arguments *a);
+extern int
+       u16_printf_parse (const uint16_t *format, u16_directives *d,
+			 arguments *a);
+extern int
+       u32_printf_parse (const uint32_t *format, u32_directives *d,
+			 arguments *a);
+#else
+# ifdef STATIC
+STATIC
+# else
+extern
+# endif
+int printf_parse (const char *format, char_directives *d, arguments *a);
+#endif
+
+#endif /* _PRINTF_PARSE_H */
Index: lib/size_max.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/size_max.h	2007-11-07 16:30:53.548403059 +0000
@@ -0,0 +1,31 @@
+/* size_max.h -- declare SIZE_MAX through system headers
+   Copyright (C) 2005-2006 Free Software Foundation, Inc.
+   Written by Simon Josefsson.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef GNULIB_SIZE_MAX_H
+#define GNULIB_SIZE_MAX_H
+
+/* Get SIZE_MAX declaration on systems like Solaris 7/8/9.  */
+# include <limits.h>
+/* Get SIZE_MAX declaration on systems like glibc 2.  */
+# if HAVE_STDINT_H
+#  include <stdint.h>
+# endif
+/* On systems where these include files don't define it, SIZE_MAX is defined
+   in config.h.  */
+
+#endif /* GNULIB_SIZE_MAX_H */
Index: lib/snprintf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/snprintf.c	2007-11-07 16:30:53.555566487 +0000
@@ -0,0 +1,77 @@
+/* Formatted output to strings.
+   Copyright (C) 2004, 2006-2007 Free Software Foundation, Inc.
+   Written by Simon Josefsson and Paul Eggert.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#include <config.h>
+
+/* Specification.  */
+#include <stdio.h>
+
+#include <errno.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "vasnprintf.h"
+
+/* Some systems, like OSF/1 4.0 and Woe32, don't have EOVERFLOW.  */
+#ifndef EOVERFLOW
+# define EOVERFLOW E2BIG
+#endif
+
+/* Print formatted output to string STR.  Similar to sprintf, but
+   additional length SIZE limit how much is written into STR.  Returns
+   string length of formatted string (which may be larger than SIZE).
+   STR may be NULL, in which case nothing will be written.  On error,
+   return a negative value.  */
+int
+snprintf (char *str, size_t size, const char *format, ...)
+{
+  char *output;
+  size_t len;
+  size_t lenbuf = size;
+  va_list args;
+
+  va_start (args, format);
+  output = vasnprintf (str, &lenbuf, format, args);
+  len = lenbuf;
+  va_end (args);
+
+  if (!output)
+    return -1;
+
+  if (output != str)
+    {
+      if (size)
+	{
+	  size_t pruned_len = (len < size ? len : size - 1);
+	  memcpy (str, output, pruned_len);
+	  str[pruned_len] = '\0';
+	}
+
+      free (output);
+    }
+
+  if (INT_MAX < len)
+    {
+      errno = EOVERFLOW;
+      return -1;
+    }
+
+  return len;
+}
Index: lib/stdint.in.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/stdint.in.h	2007-11-07 16:30:53.563296409 +0000
@@ -0,0 +1,516 @@
+/* Copyright (C) 2001-2002, 2004-2007 Free Software Foundation, Inc.
+   Written by Paul Eggert, Bruno Haible, Sam Steingold, Peter Burwood.
+   This file is part of gnulib.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/*
+ * ISO C 99 <stdint.h> for platforms that lack it.
+ * <http://www.opengroup.org/susv3xbd/stdint.h.html>
+ */
+
+#ifndef _GL_STDINT_H
+
+/* Get those types that are already defined in other system include
+   files, so that we can "#define int8_t signed char" below without
+   worrying about a later system include file containing a "typedef
+   signed char int8_t;" that will get messed up by our macro.  Our
+   macros should all be consistent with the system versions, except
+   for the "fast" types and macros, which we recommend against using
+   in public interfaces due to compiler differences.  */
+
+#if @HAVE_STDINT_H@
+# if defined __sgi && ! defined __c99
+   /* Bypass IRIX's <stdint.h> if in C89 mode, since it merely annoys users
+      with "This header file is to be used only for c99 mode compilations"
+      diagnostics.  */
+#  define __STDINT_H__
+# endif
+  /* Other systems may have an incomplete or buggy <stdint.h>.
+     Include it before <inttypes.h>, since any "#include <stdint.h>"
+     in <inttypes.h> would reinclude us, skipping our contents because
+     _GL_STDINT_H is defined.
+     The include_next requires a split double-inclusion guard.  */
+# @INCLUDE_NEXT@ @NEXT_STDINT_H@
+#endif
+
+#if ! defined _GL_STDINT_H && ! defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H
+#define _GL_STDINT_H
+
+/* <sys/types.h> defines some of the stdint.h types as well, on glibc,
+   IRIX 6.5, and OpenBSD 3.8 (via <machine/types.h>).
+   AIX 5.2 <sys/types.h> isn't needed and causes troubles.
+   MacOS X 10.4.6 <sys/types.h> includes <stdint.h> (which is us), but
+   relies on the system <stdint.h> definitions, so include
+   <sys/types.h> after @NEXT_STDINT_H@.  */
+#if @HAVE_SYS_TYPES_H@ && ! defined _AIX
+# include <sys/types.h>
+#endif
+
+/* Get LONG_MIN, LONG_MAX, ULONG_MAX.  */
+#include <limits.h>
+
+#if @HAVE_INTTYPES_H@
+  /* In OpenBSD 3.8, <inttypes.h> includes <machine/types.h>, which defines
+     int{8,16,32,64}_t, uint{8,16,32,64}_t and __BIT_TYPES_DEFINED__.
+     <inttypes.h> also defines intptr_t and uintptr_t.  */
+# define _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+# include <inttypes.h>
+# undef _GL_JUST_INCLUDE_SYSTEM_INTTYPES_H
+#elif @HAVE_SYS_INTTYPES_H@
+  /* Solaris 7 <sys/inttypes.h> has the types except the *_fast*_t types, and
+     the macros except for *_FAST*_*, INTPTR_MIN, PTRDIFF_MIN, PTRDIFF_MAX.  */
+# include <sys/inttypes.h>
+#endif
+
+#if @HAVE_SYS_BITYPES_H@ && ! defined __BIT_TYPES_DEFINED__
+  /* Linux libc4 >= 4.6.7 and libc5 have a <sys/bitypes.h> that defines
+     int{8,16,32,64}_t and __BIT_TYPES_DEFINED__.  In libc5 >= 5.2.2 it is
+     included by <sys/types.h>.  */
+# include <sys/bitypes.h>
+#endif
+
+#if ! defined __cplusplus || defined __STDC_CONSTANT_MACROS
+
+/* Get WCHAR_MIN, WCHAR_MAX.  */
+# if ! (defined WCHAR_MIN && defined WCHAR_MAX)
+#  include <wchar.h>
+# endif
+
+#endif
+
+/* Minimum and maximum values for a integer type under the usual assumption.
+   Return an unspecified value if BITS == 0, adding a check to pacify
+   picky compilers.  */
+
+#define _STDINT_MIN(signed, bits, zero) \
+  ((signed) ? (- ((zero) + 1) << ((bits) ? (bits) - 1 : 0)) : (zero))
+
+#define _STDINT_MAX(signed, bits, zero) \
+  ((signed) \
+   ? ~ _STDINT_MIN (signed, bits, zero) \
+   : /* The expression for the unsigned case.  The subtraction of (signed) \
+	is a nop in the unsigned case and avoids "signed integer overflow" \
+	warnings in the signed case.  */ \
+     ((((zero) + 1) << ((bits) ? (bits) - 1 - (signed) : 0)) - 1) * 2 + 1)
+
+/* 7.18.1.1. Exact-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits.  */
+
+#undef int8_t
+#undef uint8_t
+#define int8_t signed char
+#define uint8_t unsigned char
+
+#undef int16_t
+#undef uint16_t
+#define int16_t short int
+#define uint16_t unsigned short int
+
+#undef int32_t
+#undef uint32_t
+#define int32_t int
+#define uint32_t unsigned int
+
+/* Do not undefine int64_t if gnulib is not being used with 64-bit
+   types, since otherwise it breaks platforms like Tandem/NSK.  */
+#if LONG_MAX >> 31 >> 31 == 1
+# undef int64_t
+# define int64_t long int
+# define GL_INT64_T
+#elif defined _MSC_VER
+# undef int64_t
+# define int64_t __int64
+# define GL_INT64_T
+#elif @HAVE_LONG_LONG_INT@
+# undef int64_t
+# define int64_t long long int
+# define GL_INT64_T
+#endif
+
+#if ULONG_MAX >> 31 >> 31 >> 1 == 1
+# undef uint64_t
+# define uint64_t unsigned long int
+# define GL_UINT64_T
+#elif defined _MSC_VER
+# undef uint64_t
+# define uint64_t unsigned __int64
+# define GL_UINT64_T
+#elif @HAVE_UNSIGNED_LONG_LONG_INT@
+# undef uint64_t
+# define uint64_t unsigned long long int
+# define GL_UINT64_T
+#endif
+
+/* Avoid collision with Solaris 2.5.1 <pthread.h> etc.  */
+#define _UINT8_T
+#define _UINT32_T
+#define _UINT64_T
+
+
+/* 7.18.1.2. Minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types
+   are the same as the corresponding N_t types.  */
+
+#undef int_least8_t
+#undef uint_least8_t
+#undef int_least16_t
+#undef uint_least16_t
+#undef int_least32_t
+#undef uint_least32_t
+#undef int_least64_t
+#undef uint_least64_t
+#define int_least8_t int8_t
+#define uint_least8_t uint8_t
+#define int_least16_t int16_t
+#define uint_least16_t uint16_t
+#define int_least32_t int32_t
+#define uint_least32_t uint32_t
+#ifdef GL_INT64_T
+# define int_least64_t int64_t
+#endif
+#ifdef GL_UINT64_T
+# define uint_least64_t uint64_t
+#endif
+
+/* 7.18.1.3. Fastest minimum-width integer types */
+
+/* Note: Other <stdint.h> substitutes may define these types differently.
+   It is not recommended to use these types in public header files. */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types
+   are taken from the same list of types.  Assume that 'long int'
+   is fast enough for all narrower integers.  */
+
+#undef int_fast8_t
+#undef uint_fast8_t
+#undef int_fast16_t
+#undef uint_fast16_t
+#undef int_fast32_t
+#undef uint_fast32_t
+#undef int_fast64_t
+#undef uint_fast64_t
+#define int_fast8_t long int
+#define uint_fast8_t unsigned int_fast8_t
+#define int_fast16_t long int
+#define uint_fast16_t unsigned int_fast16_t
+#define int_fast32_t long int
+#define uint_fast32_t unsigned int_fast32_t
+#ifdef GL_INT64_T
+# define int_fast64_t int64_t
+#endif
+#ifdef GL_UINT64_T
+# define uint_fast64_t uint64_t
+#endif
+
+/* 7.18.1.4. Integer types capable of holding object pointers */
+
+#undef intptr_t
+#undef uintptr_t
+#define intptr_t long int
+#define uintptr_t unsigned long int
+
+/* 7.18.1.5. Greatest-width integer types */
+
+/* Note: These types are compiler dependent. It may be unwise to use them in
+   public header files. */
+
+#undef intmax_t
+#if @HAVE_LONG_LONG_INT@ && LONG_MAX >> 30 == 1
+# define intmax_t long long int
+#elif defined GL_INT64_T
+# define intmax_t int64_t
+#else
+# define intmax_t long int
+#endif
+
+#undef uintmax_t
+#if @HAVE_UNSIGNED_LONG_LONG_INT@ && ULONG_MAX >> 31 == 1
+# define uintmax_t unsigned long long int
+#elif defined GL_UINT64_T
+# define uintmax_t uint64_t
+#else
+# define uintmax_t unsigned long int
+#endif
+
+/* Verify that intmax_t and uintmax_t have the same size.  Too much code
+   breaks if this is not the case.  If this check fails, the reason is likely
+   to be found in the autoconf macros.  */
+typedef int _verify_intmax_size[2 * (sizeof (intmax_t) == sizeof (uintmax_t)) - 1];
+
+/* 7.18.2. Limits of specified-width integer types */
+
+#if ! defined __cplusplus || defined __STDC_LIMIT_MACROS
+
+/* 7.18.2.1. Limits of exact-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits.  */
+
+#undef INT8_MIN
+#undef INT8_MAX
+#undef UINT8_MAX
+#define INT8_MIN  (~ INT8_MAX)
+#define INT8_MAX  127
+#define UINT8_MAX  255
+
+#undef INT16_MIN
+#undef INT16_MAX
+#undef UINT16_MAX
+#define INT16_MIN  (~ INT16_MAX)
+#define INT16_MAX  32767
+#define UINT16_MAX  65535
+
+#undef INT32_MIN
+#undef INT32_MAX
+#undef UINT32_MAX
+#define INT32_MIN  (~ INT32_MAX)
+#define INT32_MAX  2147483647
+#define UINT32_MAX  4294967295U
+
+#undef INT64_MIN
+#undef INT64_MAX
+#ifdef GL_INT64_T
+/* Prefer (- INTMAX_C (1) << 63) over (~ INT64_MAX) because SunPRO C 5.0
+   evaluates the latter incorrectly in preprocessor expressions.  */
+# define INT64_MIN  (- INTMAX_C (1) << 63)
+# define INT64_MAX  INTMAX_C (9223372036854775807)
+#endif
+
+#undef UINT64_MAX
+#ifdef GL_UINT64_T
+# define UINT64_MAX  UINTMAX_C (18446744073709551615)
+#endif
+
+/* 7.18.2.2. Limits of minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the leastN_t types
+   are the same as the corresponding N_t types.  */
+
+#undef INT_LEAST8_MIN
+#undef INT_LEAST8_MAX
+#undef UINT_LEAST8_MAX
+#define INT_LEAST8_MIN  INT8_MIN
+#define INT_LEAST8_MAX  INT8_MAX
+#define UINT_LEAST8_MAX  UINT8_MAX
+
+#undef INT_LEAST16_MIN
+#undef INT_LEAST16_MAX
+#undef UINT_LEAST16_MAX
+#define INT_LEAST16_MIN  INT16_MIN
+#define INT_LEAST16_MAX  INT16_MAX
+#define UINT_LEAST16_MAX  UINT16_MAX
+
+#undef INT_LEAST32_MIN
+#undef INT_LEAST32_MAX
+#undef UINT_LEAST32_MAX
+#define INT_LEAST32_MIN  INT32_MIN
+#define INT_LEAST32_MAX  INT32_MAX
+#define UINT_LEAST32_MAX  UINT32_MAX
+
+#undef INT_LEAST64_MIN
+#undef INT_LEAST64_MAX
+#ifdef GL_INT64_T
+# define INT_LEAST64_MIN  INT64_MIN
+# define INT_LEAST64_MAX  INT64_MAX
+#endif
+
+#undef UINT_LEAST64_MAX
+#ifdef GL_UINT64_T
+# define UINT_LEAST64_MAX  UINT64_MAX
+#endif
+
+/* 7.18.2.3. Limits of fastest minimum-width integer types */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits. Therefore the fastN_t types
+   are taken from the same list of types.  */
+
+#undef INT_FAST8_MIN
+#undef INT_FAST8_MAX
+#undef UINT_FAST8_MAX
+#define INT_FAST8_MIN  LONG_MIN
+#define INT_FAST8_MAX  LONG_MAX
+#define UINT_FAST8_MAX  ULONG_MAX
+
+#undef INT_FAST16_MIN
+#undef INT_FAST16_MAX
+#undef UINT_FAST16_MAX
+#define INT_FAST16_MIN  LONG_MIN
+#define INT_FAST16_MAX  LONG_MAX
+#define UINT_FAST16_MAX  ULONG_MAX
+
+#undef INT_FAST32_MIN
+#undef INT_FAST32_MAX
+#undef UINT_FAST32_MAX
+#define INT_FAST32_MIN  LONG_MIN
+#define INT_FAST32_MAX  LONG_MAX
+#define UINT_FAST32_MAX  ULONG_MAX
+
+#undef INT_FAST64_MIN
+#undef INT_FAST64_MAX
+#ifdef GL_INT64_T
+# define INT_FAST64_MIN  INT64_MIN
+# define INT_FAST64_MAX  INT64_MAX
+#endif
+
+#undef UINT_FAST64_MAX
+#ifdef GL_UINT64_T
+# define UINT_FAST64_MAX  UINT64_MAX
+#endif
+
+/* 7.18.2.4. Limits of integer types capable of holding object pointers */
+
+#undef INTPTR_MIN
+#undef INTPTR_MAX
+#undef UINTPTR_MAX
+#define INTPTR_MIN  LONG_MIN
+#define INTPTR_MAX  LONG_MAX
+#define UINTPTR_MAX  ULONG_MAX
+
+/* 7.18.2.5. Limits of greatest-width integer types */
+
+#undef INTMAX_MIN
+#undef INTMAX_MAX
+#ifdef INT64_MAX
+# define INTMAX_MIN  INT64_MIN
+# define INTMAX_MAX  INT64_MAX
+#else
+# define INTMAX_MIN  INT32_MIN
+# define INTMAX_MAX  INT32_MAX
+#endif
+
+#undef UINTMAX_MAX
+#ifdef UINT64_MAX
+# define UINTMAX_MAX  UINT64_MAX
+#else
+# define UINTMAX_MAX  UINT32_MAX
+#endif
+
+/* 7.18.3. Limits of other integer types */
+
+/* ptrdiff_t limits */
+#undef PTRDIFF_MIN
+#undef PTRDIFF_MAX
+#define PTRDIFF_MIN  \
+   _STDINT_MIN (1, @BITSIZEOF_PTRDIFF_T@, 0@PTRDIFF_T_SUFFIX@)
+#define PTRDIFF_MAX  \
+   _STDINT_MAX (1, @BITSIZEOF_PTRDIFF_T@, 0@PTRDIFF_T_SUFFIX@)
+
+/* sig_atomic_t limits */
+#undef SIG_ATOMIC_MIN
+#undef SIG_ATOMIC_MAX
+#define SIG_ATOMIC_MIN  \
+   _STDINT_MIN (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \
+		0@SIG_ATOMIC_T_SUFFIX@)
+#define SIG_ATOMIC_MAX  \
+   _STDINT_MAX (@HAVE_SIGNED_SIG_ATOMIC_T@, @BITSIZEOF_SIG_ATOMIC_T@, \
+		0@SIG_ATOMIC_T_SUFFIX@)
+
+
+/* size_t limit */
+#undef SIZE_MAX
+#define SIZE_MAX  _STDINT_MAX (0, @BITSIZEOF_SIZE_T@, 0@SIZE_T_SUFFIX@)
+
+/* wchar_t limits */
+#undef WCHAR_MIN
+#undef WCHAR_MAX
+#define WCHAR_MIN  \
+   _STDINT_MIN (@HAVE_SIGNED_WCHAR_T@, @BITSIZEOF_WCHAR_T@, 0@WCHAR_T_SUFFIX@)
+#define WCHAR_MAX  \
+   _STDINT_MAX (@HAVE_SIGNED_WCHAR_T@, @BITSIZEOF_WCHAR_T@, 0@WCHAR_T_SUFFIX@)
+
+/* wint_t limits */
+#undef WINT_MIN
+#undef WINT_MAX
+#define WINT_MIN  \
+   _STDINT_MIN (@HAVE_SIGNED_WINT_T@, @BITSIZEOF_WINT_T@, 0@WINT_T_SUFFIX@)
+#define WINT_MAX  \
+   _STDINT_MAX (@HAVE_SIGNED_WINT_T@, @BITSIZEOF_WINT_T@, 0@WINT_T_SUFFIX@)
+
+#endif /* !defined __cplusplus || defined __STDC_LIMIT_MACROS */
+
+/* 7.18.4. Macros for integer constants */
+
+#if ! defined __cplusplus || defined __STDC_CONSTANT_MACROS
+
+/* 7.18.4.1. Macros for minimum-width integer constants */
+/* According to ISO C 99 Technical Corrigendum 1 */
+
+/* Here we assume a standard architecture where the hardware integer
+   types have 8, 16, 32, optionally 64 bits, and int is 32 bits.  */
+
+#undef INT8_C
+#undef UINT8_C
+#define INT8_C(x) x
+#define UINT8_C(x) x
+
+#undef INT16_C
+#undef UINT16_C
+#define INT16_C(x) x
+#define UINT16_C(x) x
+
+#undef INT32_C
+#undef UINT32_C
+#define INT32_C(x) x
+#define UINT32_C(x) x ## U
+
+#undef INT64_C
+#undef UINT64_C
+#if LONG_MAX >> 31 >> 31 == 1
+# define INT64_C(x) x##L
+#elif defined _MSC_VER
+# define INT64_C(x) x##i64
+#elif @HAVE_LONG_LONG_INT@
+# define INT64_C(x) x##LL
+#endif
+#if ULONG_MAX >> 31 >> 31 >> 1 == 1
+# define UINT64_C(x) x##UL
+#elif defined _MSC_VER
+# define UINT64_C(x) x##ui64
+#elif @HAVE_UNSIGNED_LONG_LONG_INT@
+# define UINT64_C(x) x##ULL
+#endif
+
+/* 7.18.4.2. Macros for greatest-width integer constants */
+
+#undef INTMAX_C
+#if @HAVE_LONG_LONG_INT@ && LONG_MAX >> 30 == 1
+# define INTMAX_C(x)   x##LL
+#elif defined GL_INT64_T
+# define INTMAX_C(x)   INT64_C(x)
+#else
+# define INTMAX_C(x)   x##L
+#endif
+
+#undef UINTMAX_C
+#if @HAVE_UNSIGNED_LONG_LONG_INT@ && ULONG_MAX >> 31 == 1
+# define UINTMAX_C(x)  x##ULL
+#elif defined GL_UINT64_T
+# define UINTMAX_C(x)  UINT64_C(x)
+#else
+# define UINTMAX_C(x)  x##UL
+#endif
+
+#endif /* !defined __cplusplus || defined __STDC_CONSTANT_MACROS */
+
+#endif /* _GL_STDINT_H */
+#endif /* !defined _GL_STDINT_H && !defined _GL_JUST_INCLUDE_SYSTEM_STDINT_H */
Index: lib/stdio.in.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/stdio.in.h	2007-11-07 16:30:53.571556688 +0000
@@ -0,0 +1,382 @@
+/* A GNU-like <stdio.h>.
+
+   Copyright (C) 2004, 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#if defined __need_FILE || defined __need___FILE
+/* Special invocation convention inside glibc header files.  */
+
+#@INCLUDE_NEXT@ @NEXT_STDIO_H@
+
+#else
+/* Normal invocation convention.  */
+
+#ifndef _GL_STDIO_H
+
+/* The include_next requires a split double-inclusion guard.  */
+#@INCLUDE_NEXT@ @NEXT_STDIO_H@
+
+#ifndef _GL_STDIO_H
+#define _GL_STDIO_H
+
+#include <stdarg.h>
+#include <stddef.h>
+
+#if (@GNULIB_FSEEKO@ && @REPLACE_FSEEKO@) \
+  || (@GNULIB_FTELLO@ && @REPLACE_FTELLO@) \
+  || (@GNULIB_GETDELIM@ && !@HAVE_DECL_GETDELIM@) \
+  || (@GNULIB_GETLINE@ && (!@HAVE_DECL_GETLINE@ || @REPLACE_GETLINE@))
+/* Get off_t and ssize_t.  */
+# include <sys/types.h>
+#endif
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
+#  define __attribute__(Spec) /* empty */
+# endif
+/* The __-protected variants of `format' and `printf' attributes
+   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+#  define __format__ format
+#  define __printf__ printf
+# endif
+#endif
+
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+#if @GNULIB_FPRINTF_POSIX@
+# if @REPLACE_FPRINTF@
+#  define fprintf rpl_fprintf
+extern int fprintf (FILE *fp, const char *format, ...)
+       __attribute__ ((__format__ (__printf__, 2, 3)));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef fprintf
+# define fprintf \
+    (GL_LINK_WARNING ("fprintf is not always POSIX compliant - " \
+                      "use gnulib module fprintf-posix for portable " \
+                      "POSIX compliance"), \
+     fprintf)
+#endif
+
+#if @GNULIB_VFPRINTF_POSIX@
+# if @REPLACE_VFPRINTF@
+#  define vfprintf rpl_vfprintf
+extern int vfprintf (FILE *fp, const char *format, va_list args)
+       __attribute__ ((__format__ (__printf__, 2, 0)));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef vfprintf
+# define vfprintf(s,f,a) \
+    (GL_LINK_WARNING ("vfprintf is not always POSIX compliant - " \
+                      "use gnulib module vfprintf-posix for portable " \
+                      "POSIX compliance"), \
+     vfprintf (s, f, a))
+#endif
+
+#if @GNULIB_PRINTF_POSIX@
+# if @REPLACE_PRINTF@
+/* Don't break __attribute__((format(printf,M,N))).  */
+#  define printf __printf__
+extern int printf (const char *format, ...)
+       __attribute__ ((__format__ (__printf__, 1, 2)));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef printf
+# define printf \
+    (GL_LINK_WARNING ("printf is not always POSIX compliant - " \
+                      "use gnulib module printf-posix for portable " \
+                      "POSIX compliance"), \
+     printf)
+/* Don't break __attribute__((format(printf,M,N))).  */
+# define format(kind,m,n) format (__##kind##__, m, n)
+# define __format__(kind,m,n) __format__ (__##kind##__, m, n)
+# define ____printf____ __printf__
+# define ____scanf____ __scanf__
+# define ____strftime____ __strftime__
+# define ____strfmon____ __strfmon__
+#endif
+
+#if @GNULIB_VPRINTF_POSIX@
+# if @REPLACE_VPRINTF@
+#  define vprintf rpl_vprintf
+extern int vprintf (const char *format, va_list args)
+       __attribute__ ((__format__ (__printf__, 1, 0)));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef vprintf
+# define vprintf(f,a) \
+    (GL_LINK_WARNING ("vprintf is not always POSIX compliant - " \
+                      "use gnulib module vprintf-posix for portable " \
+                      "POSIX compliance"), \
+     vprintf (f, a))
+#endif
+
+#if @GNULIB_SNPRINTF@
+# if @REPLACE_SNPRINTF@
+#  define snprintf rpl_snprintf
+# endif
+# if @REPLACE_SNPRINTF@ || !@HAVE_DECL_SNPRINTF@
+extern int snprintf (char *str, size_t size, const char *format, ...)
+       __attribute__ ((__format__ (__printf__, 3, 4)));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef snprintf
+# define snprintf \
+    (GL_LINK_WARNING ("snprintf is unportable - " \
+                      "use gnulib module snprintf for portability"), \
+     snprintf)
+#endif
+
+#if @GNULIB_VSNPRINTF@
+# if @REPLACE_VSNPRINTF@
+#  define vsnprintf rpl_vsnprintf
+# endif
+# if @REPLACE_VSNPRINTF@ || !@HAVE_DECL_VSNPRINTF@
+extern int vsnprintf (char *str, size_t size, const char *format, va_list args)
+       __attribute__ ((__format__ (__printf__, 3, 0)));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef vsnprintf
+# define vsnprintf(b,s,f,a) \
+    (GL_LINK_WARNING ("vsnprintf is unportable - " \
+                      "use gnulib module vsnprintf for portability"), \
+     vsnprintf (b, s, f, a))
+#endif
+
+#if @GNULIB_SPRINTF_POSIX@
+# if @REPLACE_SPRINTF@
+#  define sprintf rpl_sprintf
+extern int sprintf (char *str, const char *format, ...)
+       __attribute__ ((__format__ (__printf__, 2, 3)));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef sprintf
+# define sprintf \
+    (GL_LINK_WARNING ("sprintf is not always POSIX compliant - " \
+                      "use gnulib module sprintf-posix for portable " \
+                      "POSIX compliance"), \
+     sprintf)
+#endif
+
+#if @GNULIB_VSPRINTF_POSIX@
+# if @REPLACE_VSPRINTF@
+#  define vsprintf rpl_vsprintf
+extern int vsprintf (char *str, const char *format, va_list args)
+       __attribute__ ((__format__ (__printf__, 2, 0)));
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef vsprintf
+# define vsprintf(b,f,a) \
+    (GL_LINK_WARNING ("vsprintf is not always POSIX compliant - " \
+                      "use gnulib module vsprintf-posix for portable " \
+                      "POSIX compliance"), \
+     vsprintf (b, f, a))
+#endif
+
+#if @GNULIB_VASPRINTF@
+# if @REPLACE_VASPRINTF@
+#  define asprintf rpl_asprintf
+#  define vasprintf rpl_vasprintf
+# endif
+# if @REPLACE_VASPRINTF@ || !@HAVE_VASPRINTF@
+  /* Write formatted output to a string dynamically allocated with malloc().
+     If the memory allocation succeeds, store the address of the string in
+     *RESULT and return the number of resulting bytes, excluding the trailing
+     NUL.  Upon memory allocation error, or some other error, return -1.  */
+  extern int asprintf (char **result, const char *format, ...)
+    __attribute__ ((__format__ (__printf__, 2, 3)));
+  extern int vasprintf (char **result, const char *format, va_list args)
+    __attribute__ ((__format__ (__printf__, 2, 0)));
+# endif
+#endif
+
+#if @GNULIB_FOPEN@
+# if @REPLACE_FOPEN@
+#  define fopen rpl_fopen
+extern FILE * fopen (const char *filename, const char *mode);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef fopen
+# define fopen(f,m) \
+   (GL_LINK_WARNING ("fopen on Win32 platforms is not POSIX compatible - " \
+                     "use gnulib module fopen for portability"), \
+    fopen (f, m))
+#endif
+
+#if @GNULIB_FREOPEN@
+# if @REPLACE_FREOPEN@
+#  define freopen rpl_freopen
+extern FILE * freopen (const char *filename, const char *mode, FILE *stream);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef freopen
+# define freopen(f,m,s) \
+   (GL_LINK_WARNING ("freopen on Win32 platforms is not POSIX compatible - " \
+                     "use gnulib module freopen for portability"), \
+    freopen (f, m, s))
+#endif
+
+#if @GNULIB_FSEEKO@
+# if @REPLACE_FSEEKO@
+/* Provide fseek, fseeko functions that are aware of a preceding
+   fflush(), and which detect pipes.  */
+#  define fseeko rpl_fseeko
+extern int fseeko (FILE *fp, off_t offset, int whence);
+#  define fseek(fp, offset, whence) fseeko (fp, (off_t)(offset), whence)
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef fseeko
+# define fseeko(f,o,w) \
+   (GL_LINK_WARNING ("fseeko is unportable - " \
+                     "use gnulib module fseeko for portability"), \
+    fseeko (f, o, w))
+#endif
+
+#if @GNULIB_FSEEK@ && @REPLACE_FSEEK@
+extern int rpl_fseek (FILE *fp, long offset, int whence);
+# undef fseek
+# if defined GNULIB_POSIXCHECK
+#  define fseek(f,o,w) \
+     (GL_LINK_WARNING ("fseek cannot handle files larger than 4 GB " \
+                       "on 32-bit platforms - " \
+                       "use fseeko function for handling of large files"), \
+      rpl_fseek (f, o, w))
+# else
+#  define fseek rpl_fseek
+# endif
+#elif defined GNULIB_POSIXCHECK
+# ifndef fseek
+#  define fseek(f,o,w) \
+     (GL_LINK_WARNING ("fseek cannot handle files larger than 4 GB " \
+                       "on 32-bit platforms - " \
+                       "use fseeko function for handling of large files"), \
+      fseek (f, o, w))
+# endif
+#endif
+
+#if @GNULIB_FTELLO@
+# if @REPLACE_FTELLO@
+#  define ftello rpl_ftello
+extern off_t ftello (FILE *fp);
+#  define ftell(fp) ftello (fp)
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef ftello
+# define ftello(f) \
+   (GL_LINK_WARNING ("ftello is unportable - " \
+                     "use gnulib module ftello for portability"), \
+    ftello (f))
+#endif
+
+#if @GNULIB_FTELL@ && @REPLACE_FTELL@
+extern long rpl_ftell (FILE *fp);
+# undef ftell
+# if GNULIB_POSIXCHECK
+#  define ftell(f) \
+     (GL_LINK_WARNING ("ftell cannot handle files larger than 4 GB " \
+                       "on 32-bit platforms - " \
+                       "use ftello function for handling of large files"), \
+      rpl_ftell (f))
+# else
+#  define ftell rpl_ftell
+# endif
+#elif defined GNULIB_POSIXCHECK
+# ifndef ftell
+#  define ftell(f) \
+     (GL_LINK_WARNING ("ftell cannot handle files larger than 4 GB " \
+                       "on 32-bit platforms - " \
+                       "use ftello function for handling of large files"), \
+      ftell (f))
+# endif
+#endif
+
+#if @GNULIB_FFLUSH@
+# if @REPLACE_FFLUSH@
+#  define fflush rpl_fflush
+  /* Flush all pending data on STREAM according to POSIX rules.  Both
+     output and seekable input streams are supported.
+     Note! LOSS OF DATA can occur if fflush is applied on an input stream
+     that is _not_seekable_ or on an update stream that is _not_seekable_
+     and in which the most recent operation was input.  Seekability can
+     be tested with lseek(fileno(fp),0,SEEK_CUR).  */
+  extern int fflush (FILE *gl_stream);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef fflush
+# define fflush(f) \
+   (GL_LINK_WARNING ("fflush is not always POSIX compliant - " \
+                     "use gnulib module fflush for portable " \
+                     "POSIX compliance"), \
+    fflush (f))
+#endif
+
+#if @GNULIB_GETDELIM@
+# if !@HAVE_DECL_GETDELIM@
+/* Read input, up to (and including) the next occurrence of DELIMITER, from
+   STREAM, store it in *LINEPTR (and NUL-terminate it).
+   *LINEPTR is a pointer returned from malloc (or NULL), pointing to *LINESIZE
+   bytes of space.  It is realloc'd as necessary.
+   Return the number of bytes read and stored at *LINEPTR (not including the
+   NUL terminator), or -1 on error or EOF.  */
+extern ssize_t getdelim (char **lineptr, size_t *linesize, int delimiter,
+			 FILE *stream);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getdelim
+# define getdelim(l, s, d, f)					    \
+  (GL_LINK_WARNING ("getdelim is unportable - "			    \
+		    "use gnulib module getdelim for portability"),  \
+   getdelim (l, s, d, f))
+#endif
+
+#if @GNULIB_GETLINE@
+# if @REPLACE_GETLINE@
+#  undef getline
+#  define getline rpl_getline
+# endif
+# if !@HAVE_DECL_GETLINE@ || @REPLACE_GETLINE@
+/* Read a line, up to (and including) the next newline, from STREAM, store it
+   in *LINEPTR (and NUL-terminate it).
+   *LINEPTR is a pointer returned from malloc (or NULL), pointing to *LINESIZE
+   bytes of space.  It is realloc'd as necessary.
+   Return the number of bytes read and stored at *LINEPTR (not including the
+   NUL terminator), or -1 on error or EOF.  */
+extern ssize_t getline (char **lineptr, size_t *linesize, FILE *stream);
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef getline
+# define getline(l, s, f)						\
+  (GL_LINK_WARNING ("getline is unportable - "				\
+		    "use gnulib module getline for portability"),	\
+   getline (l, s, f))
+#endif
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _GL_STDIO_H */
+#endif /* _GL_STDIO_H */
+#endif
Index: lib/vasnprintf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/vasnprintf.c	2007-11-07 16:30:53.583298298 +0000
@@ -0,0 +1,3987 @@
+/* vsprintf with automatic memory allocation.
+   Copyright (C) 1999, 2002-2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* This file can be parametrized with the following macros:
+     VASNPRINTF         The name of the function being defined.
+     FCHAR_T            The element type of the format string.
+     DCHAR_T            The element type of the destination (result) string.
+     FCHAR_T_ONLY_ASCII Set to 1 to enable verification that all characters
+                        in the format string are ASCII. MUST be set if
+                        FCHAR_T and DCHAR_T are not the same type.
+     DIRECTIVE          Structure denoting a format directive.
+                        Depends on FCHAR_T.
+     DIRECTIVES         Structure denoting the set of format directives of a
+                        format string.  Depends on FCHAR_T.
+     PRINTF_PARSE       Function that parses a format string.
+                        Depends on FCHAR_T.
+     DCHAR_CPY          memcpy like function for DCHAR_T[] arrays.
+     DCHAR_SET          memset like function for DCHAR_T[] arrays.
+     DCHAR_MBSNLEN      mbsnlen like function for DCHAR_T[] arrays.
+     SNPRINTF           The system's snprintf (or similar) function.
+                        This may be either snprintf or swprintf.
+     TCHAR_T            The element type of the argument and result string
+                        of the said SNPRINTF function.  This may be either
+                        char or wchar_t.  The code exploits that
+                        sizeof (TCHAR_T) | sizeof (DCHAR_T) and
+                        alignof (TCHAR_T) <= alignof (DCHAR_T).
+     DCHAR_IS_TCHAR     Set to 1 if DCHAR_T and TCHAR_T are the same type.
+     DCHAR_CONV_FROM_ENCODING A function to convert from char[] to DCHAR[].
+     DCHAR_IS_UINT8_T   Set to 1 if DCHAR_T is uint8_t.
+     DCHAR_IS_UINT16_T  Set to 1 if DCHAR_T is uint16_t.
+     DCHAR_IS_UINT32_T  Set to 1 if DCHAR_T is uint32_t.  */
+
+/* Tell glibc's <stdio.h> to provide a prototype for snprintf().
+   This must come before <config.h> because <config.h> may include
+   <features.h>, and once <features.h> has been included, it's too late.  */
+#ifndef _GNU_SOURCE
+# define _GNU_SOURCE    1
+#endif
+
+#ifndef VASNPRINTF
+# include <config.h>
+#endif
+#ifndef IN_LIBINTL
+# include <alloca.h>
+#endif
+
+/* Specification.  */
+#ifndef VASNPRINTF
+# if WIDE_CHAR_VERSION
+#  include "vasnwprintf.h"
+# else
+#  include "vasnprintf.h"
+# endif
+#endif
+
+#include <locale.h>	/* localeconv() */
+#include <stdio.h>	/* snprintf(), sprintf() */
+#include <stdlib.h>	/* abort(), malloc(), realloc(), free() */
+#include <string.h>	/* memcpy(), strlen() */
+#include <errno.h>	/* errno */
+#include <limits.h>	/* CHAR_BIT */
+#include <float.h>	/* DBL_MAX_EXP, LDBL_MAX_EXP */
+#if HAVE_NL_LANGINFO
+# include <langinfo.h>
+#endif
+#ifndef VASNPRINTF
+# if WIDE_CHAR_VERSION
+#  include "wprintf-parse.h"
+# else
+#  include "printf-parse.h"
+# endif
+#endif
+
+/* Checked size_t computations.  */
+#include "xsize.h"
+
+#if NEED_PRINTF_LONG_DOUBLE && !defined IN_LIBINTL
+# include <math.h>
+# include "float+.h"
+# include "fpucw.h"
+#endif
+
+#if NEED_PRINTF_INFINITE_DOUBLE && !defined IN_LIBINTL
+# include <math.h>
+# include "isnan.h"
+#endif
+
+#if NEED_PRINTF_INFINITE_LONG_DOUBLE && !defined IN_LIBINTL
+# include <math.h>
+# include "isnanl-nolibm.h"
+# include "fpucw.h"
+#endif
+
+#if NEED_PRINTF_DIRECTIVE_A && !defined IN_LIBINTL
+# include <math.h>
+# include "isnan.h"
+# include "printf-frexp.h"
+# include "isnanl-nolibm.h"
+# include "printf-frexpl.h"
+# include "fpucw.h"
+#endif
+
+/* Some systems, like OSF/1 4.0 and Woe32, don't have EOVERFLOW.  */
+#ifndef EOVERFLOW
+# define EOVERFLOW E2BIG
+#endif
+
+#if HAVE_WCHAR_T
+# if HAVE_WCSLEN
+#  define local_wcslen wcslen
+# else
+   /* Solaris 2.5.1 has wcslen() in a separate library libw.so. To avoid
+      a dependency towards this library, here is a local substitute.
+      Define this substitute only once, even if this file is included
+      twice in the same compilation unit.  */
+#  ifndef local_wcslen_defined
+#   define local_wcslen_defined 1
+static size_t
+local_wcslen (const wchar_t *s)
+{
+  const wchar_t *ptr;
+
+  for (ptr = s; *ptr != (wchar_t) 0; ptr++)
+    ;
+  return ptr - s;
+}
+#  endif
+# endif
+#endif
+
+/* Default parameters.  */
+#ifndef VASNPRINTF
+# if WIDE_CHAR_VERSION
+#  define VASNPRINTF vasnwprintf
+#  define FCHAR_T wchar_t
+#  define DCHAR_T wchar_t
+#  define TCHAR_T wchar_t
+#  define DCHAR_IS_TCHAR 1
+#  define DIRECTIVE wchar_t_directive
+#  define DIRECTIVES wchar_t_directives
+#  define PRINTF_PARSE wprintf_parse
+#  define DCHAR_CPY wmemcpy
+# else
+#  define VASNPRINTF vasnprintf
+#  define FCHAR_T char
+#  define DCHAR_T char
+#  define TCHAR_T char
+#  define DCHAR_IS_TCHAR 1
+#  define DIRECTIVE char_directive
+#  define DIRECTIVES char_directives
+#  define PRINTF_PARSE printf_parse
+#  define DCHAR_CPY memcpy
+# endif
+#endif
+#if WIDE_CHAR_VERSION
+  /* TCHAR_T is wchar_t.  */
+# define USE_SNPRINTF 1
+# if HAVE_DECL__SNWPRINTF
+   /* On Windows, the function swprintf() has a different signature than
+      on Unix; we use the _snwprintf() function instead.  */
+#  define SNPRINTF _snwprintf
+# else
+   /* Unix.  */
+#  define SNPRINTF swprintf
+# endif
+#else
+  /* TCHAR_T is char.  */
+# /* Use snprintf if it exists under the name 'snprintf' or '_snprintf'.
+     But don't use it on BeOS, since BeOS snprintf produces no output if the
+     size argument is >= 0x3000000.  */
+# if (HAVE_DECL__SNPRINTF || HAVE_SNPRINTF) && !defined __BEOS__
+#  define USE_SNPRINTF 1
+# else
+#  define USE_SNPRINTF 0
+# endif
+# if HAVE_DECL__SNPRINTF
+   /* Windows.  */
+#  define SNPRINTF _snprintf
+# else
+   /* Unix.  */
+#  define SNPRINTF snprintf
+   /* Here we need to call the native snprintf, not rpl_snprintf.  */
+#  undef snprintf
+# endif
+#endif
+/* Here we need to call the native sprintf, not rpl_sprintf.  */
+#undef sprintf
+
+#if (NEED_PRINTF_DIRECTIVE_A || NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_DOUBLE) && !defined IN_LIBINTL
+/* Determine the decimal-point character according to the current locale.  */
+# ifndef decimal_point_char_defined
+#  define decimal_point_char_defined 1
+static char
+decimal_point_char ()
+{
+  const char *point;
+  /* Determine it in a multithread-safe way.  We know nl_langinfo is
+     multithread-safe on glibc systems, but is not required to be multithread-
+     safe by POSIX.  sprintf(), however, is multithread-safe.  localeconv()
+     is rarely multithread-safe.  */
+#  if HAVE_NL_LANGINFO && __GLIBC__
+  point = nl_langinfo (RADIXCHAR);
+#  elif 1
+  char pointbuf[5];
+  sprintf (pointbuf, "%#.0f", 1.0);
+  point = &pointbuf[1];
+#  else
+  point = localeconv () -> decimal_point;
+#  endif
+  /* The decimal point is always a single byte: either '.' or ','.  */
+  return (point[0] != '\0' ? point[0] : '.');
+}
+# endif
+#endif
+
+#if NEED_PRINTF_INFINITE_DOUBLE && !defined IN_LIBINTL
+
+/* Equivalent to !isfinite(x) || x == 0, but does not require libm.  */
+static int
+is_infinite_or_zero (double x)
+{
+  return isnan (x) || x + x == x;
+}
+
+#endif
+
+#if NEED_PRINTF_INFINITE_LONG_DOUBLE && !defined IN_LIBINTL
+
+/* Equivalent to !isfinite(x), but does not require libm.  */
+static int
+is_infinitel (long double x)
+{
+  return isnanl (x) || (x + x == x && x != 0.0L);
+}
+
+#endif
+
+#if NEED_PRINTF_LONG_DOUBLE && !defined IN_LIBINTL
+
+/* Converting 'long double' to decimal without rare rounding bugs requires
+   real bignums.  We use the naming conventions of GNU gmp, but vastly simpler
+   (and slower) algorithms.  */
+
+typedef unsigned int mp_limb_t;
+# define GMP_LIMB_BITS 32
+typedef int mp_limb_verify[2 * (sizeof (mp_limb_t) * CHAR_BIT == GMP_LIMB_BITS) - 1];
+
+typedef unsigned long long mp_twolimb_t;
+# define GMP_TWOLIMB_BITS 64
+typedef int mp_twolimb_verify[2 * (sizeof (mp_twolimb_t) * CHAR_BIT == GMP_TWOLIMB_BITS) - 1];
+
+/* Representation of a bignum >= 0.  */
+typedef struct
+{
+  size_t nlimbs;
+  mp_limb_t *limbs; /* Bits in little-endian order, allocated with malloc().  */
+} mpn_t;
+
+/* Compute the product of two bignums >= 0.
+   Return the allocated memory in case of success, NULL in case of memory
+   allocation failure.  */
+static void *
+multiply (mpn_t src1, mpn_t src2, mpn_t *dest)
+{
+  const mp_limb_t *p1;
+  const mp_limb_t *p2;
+  size_t len1;
+  size_t len2;
+
+  if (src1.nlimbs <= src2.nlimbs)
+    {
+      len1 = src1.nlimbs;
+      p1 = src1.limbs;
+      len2 = src2.nlimbs;
+      p2 = src2.limbs;
+    }
+  else
+    {
+      len1 = src2.nlimbs;
+      p1 = src2.limbs;
+      len2 = src1.nlimbs;
+      p2 = src1.limbs;
+    }
+  /* Now 0 <= len1 <= len2.  */
+  if (len1 == 0)
+    {
+      /* src1 or src2 is zero.  */
+      dest->nlimbs = 0;
+      dest->limbs = (mp_limb_t *) malloc (1);
+    }
+  else
+    {
+      /* Here 1 <= len1 <= len2.  */
+      size_t dlen;
+      mp_limb_t *dp;
+      size_t k, i, j;
+
+      dlen = len1 + len2;
+      dp = (mp_limb_t *) malloc (dlen * sizeof (mp_limb_t));
+      if (dp == NULL)
+	return NULL;
+      for (k = len2; k > 0; )
+	dp[--k] = 0;
+      for (i = 0; i < len1; i++)
+	{
+	  mp_limb_t digit1 = p1[i];
+	  mp_twolimb_t carry = 0;
+	  for (j = 0; j < len2; j++)
+	    {
+	      mp_limb_t digit2 = p2[j];
+	      carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;
+	      carry += dp[i + j];
+	      dp[i + j] = (mp_limb_t) carry;
+	      carry = carry >> GMP_LIMB_BITS;
+	    }
+	  dp[i + len2] = (mp_limb_t) carry;
+	}
+      /* Normalise.  */
+      while (dlen > 0 && dp[dlen - 1] == 0)
+	dlen--;
+      dest->nlimbs = dlen;
+      dest->limbs = dp;
+    }
+  return dest->limbs;
+}
+
+/* Compute the quotient of a bignum a >= 0 and a bignum b > 0.
+   a is written as  a = q * b + r  with 0 <= r < b.  q is the quotient, r
+   the remainder.
+   Finally, round-to-even is performed: If r > b/2 or if r = b/2 and q is odd,
+   q is incremented.
+   Return the allocated memory in case of success, NULL in case of memory
+   allocation failure.  */
+static void *
+divide (mpn_t a, mpn_t b, mpn_t *q)
+{
+  /* Algorithm:
+     First normalise a and b: a=[a[m-1],...,a[0]], b=[b[n-1],...,b[0]]
+     with m>=0 and n>0 (in base beta = 2^GMP_LIMB_BITS).
+     If m<n, then q:=0 and r:=a.
+     If m>=n=1, perform a single-precision division:
+       r:=0, j:=m,
+       while j>0 do
+         {Here (q[m-1]*beta^(m-1)+...+q[j]*beta^j) * b[0] + r*beta^j =
+               = a[m-1]*beta^(m-1)+...+a[j]*beta^j und 0<=r<b[0]<beta}
+         j:=j-1, r:=r*beta+a[j], q[j]:=floor(r/b[0]), r:=r-b[0]*q[j].
+       Normalise [q[m-1],...,q[0]], yields q.
+     If m>=n>1, perform a multiple-precision division:
+       We have a/b < beta^(m-n+1).
+       s:=intDsize-1-(hightest bit in b[n-1]), 0<=s<intDsize.
+       Shift a and b left by s bits, copying them. r:=a.
+       r=[r[m],...,r[0]], b=[b[n-1],...,b[0]] with b[n-1]>=beta/2.
+       For j=m-n,...,0: {Here 0 <= r < b*beta^(j+1).}
+         Compute q* :
+           q* := floor((r[j+n]*beta+r[j+n-1])/b[n-1]).
+           In case of overflow (q* >= beta) set q* := beta-1.
+           Compute c2 := ((r[j+n]*beta+r[j+n-1]) - q* * b[n-1])*beta + r[j+n-2]
+           and c3 := b[n-2] * q*.
+           {We have 0 <= c2 < 2*beta^2, even 0 <= c2 < beta^2 if no overflow
+            occurred.  Furthermore 0 <= c3 < beta^2.
+            If there was overflow and
+            r[j+n]*beta+r[j+n-1] - q* * b[n-1] >= beta, i.e. c2 >= beta^2,
+            the next test can be skipped.}
+           While c3 > c2, {Here 0 <= c2 < c3 < beta^2}
+             Put q* := q* - 1, c2 := c2 + b[n-1]*beta, c3 := c3 - b[n-2].
+           If q* > 0:
+             Put r := r - b * q* * beta^j. In detail:
+               [r[n+j],...,r[j]] := [r[n+j],...,r[j]] - q* * [b[n-1],...,b[0]].
+               hence: u:=0, for i:=0 to n-1 do
+                              u := u + q* * b[i],
+                              r[j+i]:=r[j+i]-(u mod beta) (+ beta, if carry),
+                              u:=u div beta (+ 1, if carry in subtraction)
+                      r[n+j]:=r[n+j]-u.
+               {Since always u = (q* * [b[i-1],...,b[0]] div beta^i) + 1
+                               < q* + 1 <= beta,
+                the carry u does not overflow.}
+             If a negative carry occurs, put q* := q* - 1
+               and [r[n+j],...,r[j]] := [r[n+j],...,r[j]] + [0,b[n-1],...,b[0]].
+         Set q[j] := q*.
+       Normalise [q[m-n],..,q[0]]; this yields the quotient q.
+       Shift [r[n-1],...,r[0]] right by s bits and normalise; this yields the
+       rest r.
+       The room for q[j] can be allocated at the memory location of r[n+j].
+     Finally, round-to-even:
+       Shift r left by 1 bit.
+       If r > b or if r = b and q[0] is odd, q := q+1.
+   */
+  const mp_limb_t *a_ptr = a.limbs;
+  size_t a_len = a.nlimbs;
+  const mp_limb_t *b_ptr = b.limbs;
+  size_t b_len = b.nlimbs;
+  mp_limb_t *roomptr;
+  mp_limb_t *tmp_roomptr = NULL;
+  mp_limb_t *q_ptr;
+  size_t q_len;
+  mp_limb_t *r_ptr;
+  size_t r_len;
+
+  /* Allocate room for a_len+2 digits.
+     (Need a_len+1 digits for the real division and 1 more digit for the
+     final rounding of q.)  */
+  roomptr = (mp_limb_t *) malloc ((a_len + 2) * sizeof (mp_limb_t));
+  if (roomptr == NULL)
+    return NULL;
+
+  /* Normalise a.  */
+  while (a_len > 0 && a_ptr[a_len - 1] == 0)
+    a_len--;
+
+  /* Normalise b.  */
+  for (;;)
+    {
+      if (b_len == 0)
+	/* Division by zero.  */
+	abort ();
+      if (b_ptr[b_len - 1] == 0)
+	b_len--;
+      else
+	break;
+    }
+
+  /* Here m = a_len >= 0 and n = b_len > 0.  */
+
+  if (a_len < b_len)
+    {
+      /* m<n: trivial case.  q=0, r := copy of a.  */
+      r_ptr = roomptr;
+      r_len = a_len;
+      memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));
+      q_ptr = roomptr + a_len;
+      q_len = 0;
+    }
+  else if (b_len == 1)
+    {
+      /* n=1: single precision division.
+	 beta^(m-1) <= a < beta^m  ==>  beta^(m-2) <= a/b < beta^m  */
+      r_ptr = roomptr;
+      q_ptr = roomptr + 1;
+      {
+	mp_limb_t den = b_ptr[0];
+	mp_limb_t remainder = 0;
+	const mp_limb_t *sourceptr = a_ptr + a_len;
+	mp_limb_t *destptr = q_ptr + a_len;
+	size_t count;
+	for (count = a_len; count > 0; count--)
+	  {
+	    mp_twolimb_t num =
+	      ((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--sourceptr;
+	    *--destptr = num / den;
+	    remainder = num % den;
+	  }
+	/* Normalise and store r.  */
+	if (remainder > 0)
+	  {
+	    r_ptr[0] = remainder;
+	    r_len = 1;
+	  }
+	else
+	  r_len = 0;
+	/* Normalise q.  */
+	q_len = a_len;
+	if (q_ptr[q_len - 1] == 0)
+	  q_len--;
+      }
+    }
+  else
+    {
+      /* n>1: multiple precision division.
+	 beta^(m-1) <= a < beta^m, beta^(n-1) <= b < beta^n  ==>
+	 beta^(m-n-1) <= a/b < beta^(m-n+1).  */
+      /* Determine s.  */
+      size_t s;
+      {
+	mp_limb_t msd = b_ptr[b_len - 1]; /* = b[n-1], > 0 */
+	s = 31;
+	if (msd >= 0x10000)
+	  {
+	    msd = msd >> 16;
+	    s -= 16;
+	  }
+	if (msd >= 0x100)
+	  {
+	    msd = msd >> 8;
+	    s -= 8;
+	  }
+	if (msd >= 0x10)
+	  {
+	    msd = msd >> 4;
+	    s -= 4;
+	  }
+	if (msd >= 0x4)
+	  {
+	    msd = msd >> 2;
+	    s -= 2;
+	  }
+	if (msd >= 0x2)
+	  {
+	    msd = msd >> 1;
+	    s -= 1;
+	  }
+      }
+      /* 0 <= s < GMP_LIMB_BITS.
+	 Copy b, shifting it left by s bits.  */
+      if (s > 0)
+	{
+	  tmp_roomptr = (mp_limb_t *) malloc (b_len * sizeof (mp_limb_t));
+	  if (tmp_roomptr == NULL)
+	    {
+	      free (roomptr);
+	      return NULL;
+	    }
+	  {
+	    const mp_limb_t *sourceptr = b_ptr;
+	    mp_limb_t *destptr = tmp_roomptr;
+	    mp_twolimb_t accu = 0;
+	    size_t count;
+	    for (count = b_len; count > 0; count--)
+	      {
+		accu += (mp_twolimb_t) *sourceptr++ << s;
+		*destptr++ = (mp_limb_t) accu;
+		accu = accu >> GMP_LIMB_BITS;
+	      }
+	    /* accu must be zero, since that was how s was determined.  */
+	    if (accu != 0)
+	      abort ();
+	  }
+	  b_ptr = tmp_roomptr;
+	}
+      /* Copy a, shifting it left by s bits, yields r.
+	 Memory layout:
+	 At the beginning: r = roomptr[0..a_len],
+	 at the end: r = roomptr[0..b_len-1], q = roomptr[b_len..a_len]  */
+      r_ptr = roomptr;
+      if (s == 0)
+	{
+	  memcpy (r_ptr, a_ptr, a_len * sizeof (mp_limb_t));
+	  r_ptr[a_len] = 0;
+	}
+      else
+	{
+	  const mp_limb_t *sourceptr = a_ptr;
+	  mp_limb_t *destptr = r_ptr;
+	  mp_twolimb_t accu = 0;
+	  size_t count;
+	  for (count = a_len; count > 0; count--)
+	    {
+	      accu += (mp_twolimb_t) *sourceptr++ << s;
+	      *destptr++ = (mp_limb_t) accu;
+	      accu = accu >> GMP_LIMB_BITS;
+	    }
+	  *destptr++ = (mp_limb_t) accu;
+	}
+      q_ptr = roomptr + b_len;
+      q_len = a_len - b_len + 1; /* q will have m-n+1 limbs */
+      {
+	size_t j = a_len - b_len; /* m-n */
+	mp_limb_t b_msd = b_ptr[b_len - 1]; /* b[n-1] */
+	mp_limb_t b_2msd = b_ptr[b_len - 2]; /* b[n-2] */
+	mp_twolimb_t b_msdd = /* b[n-1]*beta+b[n-2] */
+	  ((mp_twolimb_t) b_msd << GMP_LIMB_BITS) | b_2msd;
+	/* Division loop, traversed m-n+1 times.
+	   j counts down, b is unchanged, beta/2 <= b[n-1] < beta.  */
+	for (;;)
+	  {
+	    mp_limb_t q_star;
+	    mp_limb_t c1;
+	    if (r_ptr[j + b_len] < b_msd) /* r[j+n] < b[n-1] ? */
+	      {
+		/* Divide r[j+n]*beta+r[j+n-1] by b[n-1], no overflow.  */
+		mp_twolimb_t num =
+		  ((mp_twolimb_t) r_ptr[j + b_len] << GMP_LIMB_BITS)
+		  | r_ptr[j + b_len - 1];
+		q_star = num / b_msd;
+		c1 = num % b_msd;
+	      }
+	    else
+	      {
+		/* Overflow, hence r[j+n]*beta+r[j+n-1] >= beta*b[n-1].  */
+		q_star = (mp_limb_t)~(mp_limb_t)0; /* q* = beta-1 */
+		/* Test whether r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] >= beta
+		   <==> r[j+n]*beta+r[j+n-1] + b[n-1] >= beta*b[n-1]+beta
+		   <==> b[n-1] < floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta)
+		        {<= beta !}.
+		   If yes, jump directly to the subtraction loop.
+		   (Otherwise, r[j+n]*beta+r[j+n-1] - (beta-1)*b[n-1] < beta
+		    <==> floor((r[j+n]*beta+r[j+n-1]+b[n-1])/beta) = b[n-1] ) */
+		if (r_ptr[j + b_len] > b_msd
+		    || (c1 = r_ptr[j + b_len - 1] + b_msd) < b_msd)
+		  /* r[j+n] >= b[n-1]+1 or
+		     r[j+n] = b[n-1] and the addition r[j+n-1]+b[n-1] gives a
+		     carry.  */
+		  goto subtract;
+	      }
+	    /* q_star = q*,
+	       c1 = (r[j+n]*beta+r[j+n-1]) - q* * b[n-1] (>=0, <beta).  */
+	    {
+	      mp_twolimb_t c2 = /* c1*beta+r[j+n-2] */
+		((mp_twolimb_t) c1 << GMP_LIMB_BITS) | r_ptr[j + b_len - 2];
+	      mp_twolimb_t c3 = /* b[n-2] * q* */
+		(mp_twolimb_t) b_2msd * (mp_twolimb_t) q_star;
+	      /* While c2 < c3, increase c2 and decrease c3.
+		 Consider c3-c2.  While it is > 0, decrease it by
+		 b[n-1]*beta+b[n-2].  Because of b[n-1]*beta+b[n-2] >= beta^2/2
+		 this can happen only twice.  */
+	      if (c3 > c2)
+		{
+		  q_star = q_star - 1; /* q* := q* - 1 */
+		  if (c3 - c2 > b_msdd)
+		    q_star = q_star - 1; /* q* := q* - 1 */
+		}
+	    }
+	    if (q_star > 0)
+	      subtract:
+	      {
+		/* Subtract r := r - b * q* * beta^j.  */
+		mp_limb_t cr;
+		{
+		  const mp_limb_t *sourceptr = b_ptr;
+		  mp_limb_t *destptr = r_ptr + j;
+		  mp_twolimb_t carry = 0;
+		  size_t count;
+		  for (count = b_len; count > 0; count--)
+		    {
+		      /* Here 0 <= carry <= q*.  */
+		      carry =
+			carry
+			+ (mp_twolimb_t) q_star * (mp_twolimb_t) *sourceptr++
+			+ (mp_limb_t) ~(*destptr);
+		      /* Here 0 <= carry <= beta*q* + beta-1.  */
+		      *destptr++ = ~(mp_limb_t) carry;
+		      carry = carry >> GMP_LIMB_BITS; /* <= q* */
+		    }
+		  cr = (mp_limb_t) carry;
+		}
+		/* Subtract cr from r_ptr[j + b_len], then forget about
+		   r_ptr[j + b_len].  */
+		if (cr > r_ptr[j + b_len])
+		  {
+		    /* Subtraction gave a carry.  */
+		    q_star = q_star - 1; /* q* := q* - 1 */
+		    /* Add b back.  */
+		    {
+		      const mp_limb_t *sourceptr = b_ptr;
+		      mp_limb_t *destptr = r_ptr + j;
+		      mp_limb_t carry = 0;
+		      size_t count;
+		      for (count = b_len; count > 0; count--)
+			{
+			  mp_limb_t source1 = *sourceptr++;
+			  mp_limb_t source2 = *destptr;
+			  *destptr++ = source1 + source2 + carry;
+			  carry =
+			    (carry
+			     ? source1 >= (mp_limb_t) ~source2
+			     : source1 > (mp_limb_t) ~source2);
+			}
+		    }
+		    /* Forget about the carry and about r[j+n].  */
+		  }
+	      }
+	    /* q* is determined.  Store it as q[j].  */
+	    q_ptr[j] = q_star;
+	    if (j == 0)
+	      break;
+	    j--;
+	  }
+      }
+      r_len = b_len;
+      /* Normalise q.  */
+      if (q_ptr[q_len - 1] == 0)
+	q_len--;
+# if 0 /* Not needed here, since we need r only to compare it with b/2, and
+	  b is shifted left by s bits.  */
+      /* Shift r right by s bits.  */
+      if (s > 0)
+	{
+	  mp_limb_t ptr = r_ptr + r_len;
+	  mp_twolimb_t accu = 0;
+	  size_t count;
+	  for (count = r_len; count > 0; count--)
+	    {
+	      accu = (mp_twolimb_t) (mp_limb_t) accu << GMP_LIMB_BITS;
+	      accu += (mp_twolimb_t) *--ptr << (GMP_LIMB_BITS - s);
+	      *ptr = (mp_limb_t) (accu >> GMP_LIMB_BITS);
+	    }
+	}
+# endif
+      /* Normalise r.  */
+      while (r_len > 0 && r_ptr[r_len - 1] == 0)
+	r_len--;
+    }
+  /* Compare r << 1 with b.  */
+  if (r_len > b_len)
+    goto increment_q;
+  {
+    size_t i;
+    for (i = b_len;;)
+      {
+	mp_limb_t r_i =
+	  (i <= r_len && i > 0 ? r_ptr[i - 1] >> (GMP_LIMB_BITS - 1) : 0)
+	  | (i < r_len ? r_ptr[i] << 1 : 0);
+	mp_limb_t b_i = (i < b_len ? b_ptr[i] : 0);
+	if (r_i > b_i)
+	  goto increment_q;
+	if (r_i < b_i)
+	  goto keep_q;
+	if (i == 0)
+	  break;
+	i--;
+      }
+  }
+  if (q_len > 0 && ((q_ptr[0] & 1) != 0))
+    /* q is odd.  */
+    increment_q:
+    {
+      size_t i;
+      for (i = 0; i < q_len; i++)
+	if (++(q_ptr[i]) != 0)
+	  goto keep_q;
+      q_ptr[q_len++] = 1;
+    }
+  keep_q:
+  if (tmp_roomptr != NULL)
+    free (tmp_roomptr);
+  q->limbs = q_ptr;
+  q->nlimbs = q_len;
+  return roomptr;
+}
+
+/* Convert a bignum a >= 0, multiplied with 10^extra_zeroes, to decimal
+   representation.
+   Destroys the contents of a.
+   Return the allocated memory - containing the decimal digits in low-to-high
+   order, terminated with a NUL character - in case of success, NULL in case
+   of memory allocation failure.  */
+static char *
+convert_to_decimal (mpn_t a, size_t extra_zeroes)
+{
+  mp_limb_t *a_ptr = a.limbs;
+  size_t a_len = a.nlimbs;
+  /* 0.03345 is slightly larger than log(2)/(9*log(10)).  */
+  size_t c_len = 9 * ((size_t)(a_len * (GMP_LIMB_BITS * 0.03345f)) + 1);
+  char *c_ptr = (char *) malloc (xsum (c_len, extra_zeroes));
+  if (c_ptr != NULL)
+    {
+      char *d_ptr = c_ptr;
+      for (; extra_zeroes > 0; extra_zeroes--)
+	*d_ptr++ = '0';
+      while (a_len > 0)
+	{
+	  /* Divide a by 10^9, in-place.  */
+	  mp_limb_t remainder = 0;
+	  mp_limb_t *ptr = a_ptr + a_len;
+	  size_t count;
+	  for (count = a_len; count > 0; count--)
+	    {
+	      mp_twolimb_t num =
+		((mp_twolimb_t) remainder << GMP_LIMB_BITS) | *--ptr;
+	      *ptr = num / 1000000000;
+	      remainder = num % 1000000000;
+	    }
+	  /* Store the remainder as 9 decimal digits.  */
+	  for (count = 9; count > 0; count--)
+	    {
+	      *d_ptr++ = '0' + (remainder % 10);
+	      remainder = remainder / 10;
+	    }
+	  /* Normalize a.  */
+	  if (a_ptr[a_len - 1] == 0)
+	    a_len--;
+	}
+      /* Remove leading zeroes.  */
+      while (d_ptr > c_ptr && d_ptr[-1] == '0')
+	d_ptr--;
+      /* But keep at least one zero.  */
+      if (d_ptr == c_ptr)
+	*d_ptr++ = '0';
+      /* Terminate the string.  */
+      *d_ptr = '\0';
+    }
+  return c_ptr;
+}
+
+/* Assuming x is finite and >= 0:
+   write x as x = 2^e * m, where m is a bignum.
+   Return the allocated memory in case of success, NULL in case of memory
+   allocation failure.  */
+static void *
+decode_long_double (long double x, int *ep, mpn_t *mp)
+{
+  mpn_t m;
+  int exp;
+  long double y;
+  size_t i;
+
+  /* Allocate memory for result.  */
+  m.nlimbs = (LDBL_MANT_BIT + GMP_LIMB_BITS - 1) / GMP_LIMB_BITS;
+  m.limbs = (mp_limb_t *) malloc (m.nlimbs * sizeof (mp_limb_t));
+  if (m.limbs == NULL)
+    return NULL;
+  /* Split into exponential part and mantissa.  */
+  y = frexpl (x, &exp);
+  if (!(y >= 0.0L && y < 1.0L))
+    abort ();
+  /* x = 2^exp * y = 2^(exp - LDBL_MANT_BIT) * (y * LDBL_MANT_BIT), and the
+     latter is an integer.  */
+  /* Convert the mantissa (y * LDBL_MANT_BIT) to a sequence of limbs.
+     I'm not sure whether it's safe to cast a 'long double' value between
+     2^31 and 2^32 to 'unsigned int', therefore play safe and cast only
+     'long double' values between 0 and 2^16 (to 'unsigned int' or 'int',
+     doesn't matter).  */
+# if (LDBL_MANT_BIT % GMP_LIMB_BITS) != 0
+#  if (LDBL_MANT_BIT % GMP_LIMB_BITS) > GMP_LIMB_BITS / 2
+    {
+      mp_limb_t hi, lo;
+      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % (GMP_LIMB_BITS / 2));
+      hi = (int) y;
+      y -= hi;
+      if (!(y >= 0.0L && y < 1.0L))
+	abort ();
+      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
+      lo = (int) y;
+      y -= lo;
+      if (!(y >= 0.0L && y < 1.0L))
+	abort ();
+      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = (hi << (GMP_LIMB_BITS / 2)) | lo;
+    }
+#  else
+    {
+      mp_limb_t d;
+      y *= (mp_limb_t) 1 << (LDBL_MANT_BIT % GMP_LIMB_BITS);
+      d = (int) y;
+      y -= d;
+      if (!(y >= 0.0L && y < 1.0L))
+	abort ();
+      m.limbs[LDBL_MANT_BIT / GMP_LIMB_BITS] = d;
+    }
+#  endif
+# endif
+  for (i = LDBL_MANT_BIT / GMP_LIMB_BITS; i > 0; )
+    {
+      mp_limb_t hi, lo;
+      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
+      hi = (int) y;
+      y -= hi;
+      if (!(y >= 0.0L && y < 1.0L))
+	abort ();
+      y *= (mp_limb_t) 1 << (GMP_LIMB_BITS / 2);
+      lo = (int) y;
+      y -= lo;
+      if (!(y >= 0.0L && y < 1.0L))
+	abort ();
+      m.limbs[--i] = (hi << (GMP_LIMB_BITS / 2)) | lo;
+    }
+  if (!(y == 0.0L))
+    abort ();
+  /* Normalise.  */
+  while (m.nlimbs > 0 && m.limbs[m.nlimbs - 1] == 0)
+    m.nlimbs--;
+  *mp = m;
+  *ep = exp - LDBL_MANT_BIT;
+  return m.limbs;
+}
+
+/* Assuming x is finite and >= 0, and n is an integer:
+   Returns the decimal representation of round (x * 10^n).
+   Return the allocated memory - containing the decimal digits in low-to-high
+   order, terminated with a NUL character - in case of success, NULL in case
+   of memory allocation failure.  */
+static char *
+scale10_round_decimal_long_double (long double x, int n)
+{
+  int e;
+  mpn_t m;
+  void *memory = decode_long_double (x, &e, &m);
+  int s;
+  size_t extra_zeroes;
+  unsigned int abs_n;
+  unsigned int abs_s;
+  mp_limb_t *pow5_ptr;
+  size_t pow5_len;
+  unsigned int s_limbs;
+  unsigned int s_bits;
+  mpn_t pow5;
+  mpn_t z;
+  void *z_memory;
+  char *digits;
+
+  if (memory == NULL)
+    return NULL;
+  /* x = 2^e * m, hence
+     y = round (2^e * 10^n * m) = round (2^(e+n) * 5^n * m)
+       = round (2^s * 5^n * m).  */
+  s = e + n;
+  extra_zeroes = 0;
+  /* Factor out a common power of 10 if possible.  */
+  if (s > 0 && n > 0)
+    {
+      extra_zeroes = (s < n ? s : n);
+      s -= extra_zeroes;
+      n -= extra_zeroes;
+    }
+  /* Here y = round (2^s * 5^n * m) * 10^extra_zeroes.
+     Before converting to decimal, we need to compute
+     z = round (2^s * 5^n * m).  */
+  /* Compute 5^|n|, possibly shifted by |s| bits if n and s have the same
+     sign.  2.322 is slightly larger than log(5)/log(2).  */
+  abs_n = (n >= 0 ? n : -n);
+  abs_s = (s >= 0 ? s : -s);
+  pow5_ptr = (mp_limb_t *) malloc (((int)(abs_n * (2.322f / GMP_LIMB_BITS)) + 1
+				    + abs_s / GMP_LIMB_BITS + 1)
+				   * sizeof (mp_limb_t));
+  if (pow5_ptr == NULL)
+    {
+      free (memory);
+      return NULL;
+    }
+  /* Initialize with 1.  */
+  pow5_ptr[0] = 1;
+  pow5_len = 1;
+  /* Multiply with 5^|n|.  */
+  if (abs_n > 0)
+    {
+      static mp_limb_t const small_pow5[13 + 1] =
+	{
+	  1, 5, 25, 125, 625, 3125, 15625, 78125, 390625, 1953125, 9765625,
+	  48828125, 244140625, 1220703125
+	};
+      unsigned int n13;
+      for (n13 = 0; n13 <= abs_n; n13 += 13)
+	{
+	  mp_limb_t digit1 = small_pow5[n13 + 13 <= abs_n ? 13 : abs_n - n13];
+	  size_t j;
+	  mp_twolimb_t carry = 0;
+	  for (j = 0; j < pow5_len; j++)
+	    {
+	      mp_limb_t digit2 = pow5_ptr[j];
+	      carry += (mp_twolimb_t) digit1 * (mp_twolimb_t) digit2;
+	      pow5_ptr[j] = (mp_limb_t) carry;
+	      carry = carry >> GMP_LIMB_BITS;
+	    }
+	  if (carry > 0)
+	    pow5_ptr[pow5_len++] = (mp_limb_t) carry;
+	}
+    }
+  s_limbs = abs_s / GMP_LIMB_BITS;
+  s_bits = abs_s % GMP_LIMB_BITS;
+  if (n >= 0 ? s >= 0 : s <= 0)
+    {
+      /* Multiply with 2^|s|.  */
+      if (s_bits > 0)
+	{
+	  mp_limb_t *ptr = pow5_ptr;
+	  mp_twolimb_t accu = 0;
+	  size_t count;
+	  for (count = pow5_len; count > 0; count--)
+	    {
+	      accu += (mp_twolimb_t) *ptr << s_bits;
+	      *ptr++ = (mp_limb_t) accu;
+	      accu = accu >> GMP_LIMB_BITS;
+	    }
+	  if (accu > 0)
+	    {
+	      *ptr = (mp_limb_t) accu;
+	      pow5_len++;
+	    }
+	}
+      if (s_limbs > 0)
+	{
+	  size_t count;
+	  for (count = pow5_len; count > 0;)
+	    {
+	      count--;
+	      pow5_ptr[s_limbs + count] = pow5_ptr[count];
+	    }
+	  for (count = s_limbs; count > 0;)
+	    {
+	      count--;
+	      pow5_ptr[count] = 0;
+	    }
+	  pow5_len += s_limbs;
+	}
+      pow5.limbs = pow5_ptr;
+      pow5.nlimbs = pow5_len;
+      if (n >= 0)
+	{
+	  /* Multiply m with pow5.  No division needed.  */
+	  z_memory = multiply (m, pow5, &z);
+	}
+      else
+	{
+	  /* Divide m by pow5 and round.  */
+	  z_memory = divide (m, pow5, &z);
+	}
+    }
+  else
+    {
+      pow5.limbs = pow5_ptr;
+      pow5.nlimbs = pow5_len;
+      if (n >= 0)
+	{
+	  /* n >= 0, s < 0.
+	     Multiply m with pow5, then divide by 2^|s|.  */
+	  mpn_t numerator;
+	  mpn_t denominator;
+	  void *tmp_memory;
+	  tmp_memory = multiply (m, pow5, &numerator);
+	  if (tmp_memory == NULL)
+	    {
+	      free (pow5_ptr);
+	      free (memory);
+	      return NULL;
+	    }
+	  /* Construct 2^|s|.  */
+	  {
+	    mp_limb_t *ptr = pow5_ptr + pow5_len;
+	    size_t i;
+	    for (i = 0; i < s_limbs; i++)
+	      ptr[i] = 0;
+	    ptr[s_limbs] = (mp_limb_t) 1 << s_bits;
+	    denominator.limbs = ptr;
+	    denominator.nlimbs = s_limbs + 1;
+	  }
+	  z_memory = divide (numerator, denominator, &z);
+	  free (tmp_memory);
+	}
+      else
+	{
+	  /* n < 0, s > 0.
+	     Multiply m with 2^s, then divide by pow5.  */
+	  mpn_t numerator;
+	  mp_limb_t *num_ptr;
+	  num_ptr = (mp_limb_t *) malloc ((m.nlimbs + s_limbs + 1)
+					  * sizeof (mp_limb_t));
+	  if (num_ptr == NULL)
+	    {
+	      free (pow5_ptr);
+	      free (memory);
+	      return NULL;
+	    }
+	  {
+	    mp_limb_t *destptr = num_ptr;
+	    {
+	      size_t i;
+	      for (i = 0; i < s_limbs; i++)
+		*destptr++ = 0;
+	    }
+	    if (s_bits > 0)
+	      {
+		const mp_limb_t *sourceptr = m.limbs;
+		mp_twolimb_t accu = 0;
+		size_t count;
+		for (count = m.nlimbs; count > 0; count--)
+		  {
+		    accu += (mp_twolimb_t) *sourceptr++ << s;
+		    *destptr++ = (mp_limb_t) accu;
+		    accu = accu >> GMP_LIMB_BITS;
+		  }
+		if (accu > 0)
+		  *destptr++ = (mp_limb_t) accu;
+	      }
+	    else
+	      {
+		const mp_limb_t *sourceptr = m.limbs;
+		size_t count;
+		for (count = m.nlimbs; count > 0; count--)
+		  *destptr++ = *sourceptr++;
+	      }
+	    numerator.limbs = num_ptr;
+	    numerator.nlimbs = destptr - num_ptr;
+	  }
+	  z_memory = divide (numerator, pow5, &z);
+	  free (num_ptr);
+	}
+    }
+  free (pow5_ptr);
+  free (memory);
+
+  /* Here y = round (x * 10^n) = z * 10^extra_zeroes.  */
+
+  if (z_memory == NULL)
+    return NULL;
+  digits = convert_to_decimal (z, extra_zeroes);
+  free (z_memory);
+  return digits;
+}
+
+/* Assuming x is finite and > 0:
+   Return an approximation for n with 10^n <= x < 10^(n+1).
+   The approximation is usually the right n, but may be off by 1 sometimes.  */
+static int
+floorlog10l (long double x)
+{
+  int exp;
+  long double y;
+  double z;
+  double l;
+
+  /* Split into exponential part and mantissa.  */
+  y = frexpl (x, &exp);
+  if (!(y >= 0.0L && y < 1.0L))
+    abort ();
+  if (y == 0.0L)
+    return INT_MIN;
+  if (y < 0.5L)
+    {
+      while (y < (1.0L / (1 << (GMP_LIMB_BITS / 2)) / (1 << (GMP_LIMB_BITS / 2))))
+	{
+	  y *= 1.0L * (1 << (GMP_LIMB_BITS / 2)) * (1 << (GMP_LIMB_BITS / 2));
+	  exp -= GMP_LIMB_BITS;
+	}
+      if (y < (1.0L / (1 << 16)))
+	{
+	  y *= 1.0L * (1 << 16);
+	  exp -= 16;
+	}
+      if (y < (1.0L / (1 << 8)))
+	{
+	  y *= 1.0L * (1 << 8);
+	  exp -= 8;
+	}
+      if (y < (1.0L / (1 << 4)))
+	{
+	  y *= 1.0L * (1 << 4);
+	  exp -= 4;
+	}
+      if (y < (1.0L / (1 << 2)))
+	{
+	  y *= 1.0L * (1 << 2);
+	  exp -= 2;
+	}
+      if (y < (1.0L / (1 << 1)))
+	{
+	  y *= 1.0L * (1 << 1);
+	  exp -= 1;
+	}
+    }
+  if (!(y >= 0.5L && y < 1.0L))
+    abort ();
+  /* Compute an approximation for l = log2(x) = exp + log2(y).  */
+  l = exp;
+  z = y;
+  if (z < 0.70710678118654752444)
+    {
+      z *= 1.4142135623730950488;
+      l -= 0.5;
+    }
+  if (z < 0.8408964152537145431)
+    {
+      z *= 1.1892071150027210667;
+      l -= 0.25;
+    }
+  if (z < 0.91700404320467123175)
+    {
+      z *= 1.0905077326652576592;
+      l -= 0.125;
+    }
+  if (z < 0.9576032806985736469)
+    {
+      z *= 1.0442737824274138403;
+      l -= 0.0625;
+    }
+  /* Now 0.95 <= z <= 1.01.  */
+  z = 1 - z;
+  /* log(1-z) = - z - z^2/2 - z^3/3 - z^4/4 - ...
+     Four terms are enough to get an approximation with error < 10^-7.  */
+  l -= z * (1.0 + z * (0.5 + z * ((1.0 / 3) + z * 0.25)));
+  /* Finally multiply with log(2)/log(10), yields an approximation for
+     log10(x).  */
+  l *= 0.30102999566398119523;
+  /* Round down to the next integer.  */
+  return (int) l + (l < 0 ? -1 : 0);
+}
+
+#endif
+
+DCHAR_T *
+VASNPRINTF (DCHAR_T *resultbuf, size_t *lengthp,
+	    const FCHAR_T *format, va_list args)
+{
+  DIRECTIVES d;
+  arguments a;
+
+  if (PRINTF_PARSE (format, &d, &a) < 0)
+    {
+      errno = EINVAL;
+      return NULL;
+    }
+
+#define CLEANUP() \
+  free (d.dir);								\
+  if (a.arg)								\
+    free (a.arg);
+
+  if (PRINTF_FETCHARGS (args, &a) < 0)
+    {
+      CLEANUP ();
+      errno = EINVAL;
+      return NULL;
+    }
+
+  {
+    size_t buf_neededlength;
+    TCHAR_T *buf;
+    TCHAR_T *buf_malloced;
+    const FCHAR_T *cp;
+    size_t i;
+    DIRECTIVE *dp;
+    /* Output string accumulator.  */
+    DCHAR_T *result;
+    size_t allocated;
+    size_t length;
+
+    /* Allocate a small buffer that will hold a directive passed to
+       sprintf or snprintf.  */
+    buf_neededlength =
+      xsum4 (7, d.max_width_length, d.max_precision_length, 6);
+#if HAVE_ALLOCA
+    if (buf_neededlength < 4000 / sizeof (TCHAR_T))
+      {
+	buf = (TCHAR_T *) alloca (buf_neededlength * sizeof (TCHAR_T));
+	buf_malloced = NULL;
+      }
+    else
+#endif
+      {
+	size_t buf_memsize = xtimes (buf_neededlength, sizeof (TCHAR_T));
+	if (size_overflow_p (buf_memsize))
+	  goto out_of_memory_1;
+	buf = (TCHAR_T *) malloc (buf_memsize);
+	if (buf == NULL)
+	  goto out_of_memory_1;
+	buf_malloced = buf;
+      }
+
+    if (resultbuf != NULL)
+      {
+	result = resultbuf;
+	allocated = *lengthp;
+      }
+    else
+      {
+	result = NULL;
+	allocated = 0;
+      }
+    length = 0;
+    /* Invariants:
+       result is either == resultbuf or == NULL or malloc-allocated.
+       If length > 0, then result != NULL.  */
+
+    /* Ensures that allocated >= needed.  Aborts through a jump to
+       out_of_memory if needed is SIZE_MAX or otherwise too big.  */
+#define ENSURE_ALLOCATION(needed) \
+    if ((needed) > allocated)						     \
+      {									     \
+	size_t memory_size;						     \
+	DCHAR_T *memory;						     \
+									     \
+	allocated = (allocated > 0 ? xtimes (allocated, 2) : 12);	     \
+	if ((needed) > allocated)					     \
+	  allocated = (needed);						     \
+	memory_size = xtimes (allocated, sizeof (DCHAR_T));		     \
+	if (size_overflow_p (memory_size))				     \
+	  goto out_of_memory;						     \
+	if (result == resultbuf || result == NULL)			     \
+	  memory = (DCHAR_T *) malloc (memory_size);			     \
+	else								     \
+	  memory = (DCHAR_T *) realloc (result, memory_size);		     \
+	if (memory == NULL)						     \
+	  goto out_of_memory;						     \
+	if (result == resultbuf && length > 0)				     \
+	  DCHAR_CPY (memory, result, length);				     \
+	result = memory;						     \
+      }
+
+    for (cp = format, i = 0, dp = &d.dir[0]; ; cp = dp->dir_end, i++, dp++)
+      {
+	if (cp != dp->dir_start)
+	  {
+	    size_t n = dp->dir_start - cp;
+	    size_t augmented_length = xsum (length, n);
+
+	    ENSURE_ALLOCATION (augmented_length);
+	    /* This copies a piece of FCHAR_T[] into a DCHAR_T[].  Here we
+	       need that the format string contains only ASCII characters
+	       if FCHAR_T and DCHAR_T are not the same type.  */
+	    if (sizeof (FCHAR_T) == sizeof (DCHAR_T))
+	      {
+		DCHAR_CPY (result + length, (const DCHAR_T *) cp, n);
+		length = augmented_length;
+	      }
+	    else
+	      {
+		do
+		  result[length++] = (unsigned char) *cp++;
+		while (--n > 0);
+	      }
+	  }
+	if (i == d.count)
+	  break;
+
+	/* Execute a single directive.  */
+	if (dp->conversion == '%')
+	  {
+	    size_t augmented_length;
+
+	    if (!(dp->arg_index == ARG_NONE))
+	      abort ();
+	    augmented_length = xsum (length, 1);
+	    ENSURE_ALLOCATION (augmented_length);
+	    result[length] = '%';
+	    length = augmented_length;
+	  }
+	else
+	  {
+	    if (!(dp->arg_index != ARG_NONE))
+	      abort ();
+
+	    if (dp->conversion == 'n')
+	      {
+		switch (a.arg[dp->arg_index].type)
+		  {
+		  case TYPE_COUNT_SCHAR_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_schar_pointer = length;
+		    break;
+		  case TYPE_COUNT_SHORT_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_short_pointer = length;
+		    break;
+		  case TYPE_COUNT_INT_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_int_pointer = length;
+		    break;
+		  case TYPE_COUNT_LONGINT_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_longint_pointer = length;
+		    break;
+#if HAVE_LONG_LONG_INT
+		  case TYPE_COUNT_LONGLONGINT_POINTER:
+		    *a.arg[dp->arg_index].a.a_count_longlongint_pointer = length;
+		    break;
+#endif
+		  default:
+		    abort ();
+		  }
+	      }
+#if ENABLE_UNISTDIO
+	    /* The unistdio extensions.  */
+	    else if (dp->conversion == 'U')
+	      {
+		arg_type type = a.arg[dp->arg_index].type;
+		int flags = dp->flags;
+		int has_width;
+		size_t width;
+		int has_precision;
+		size_t precision;
+
+		has_width = 0;
+		width = 0;
+		if (dp->width_start != dp->width_end)
+		  {
+		    if (dp->width_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->width_arg_index].a.a_int;
+			if (arg < 0)
+			  {
+			    /* "A negative field width is taken as a '-' flag
+			        followed by a positive field width."  */
+			    flags |= FLAG_LEFT;
+			    width = (unsigned int) (-arg);
+			  }
+			else
+			  width = arg;
+		      }
+		    else
+		      {
+			const FCHAR_T *digitp = dp->width_start;
+
+			do
+			  width = xsum (xtimes (width, 10), *digitp++ - '0');
+			while (digitp != dp->width_end);
+		      }
+		    has_width = 1;
+		  }
+
+		has_precision = 0;
+		precision = 0;
+		if (dp->precision_start != dp->precision_end)
+		  {
+		    if (dp->precision_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->precision_arg_index].a.a_int;
+			/* "A negative precision is taken as if the precision
+			    were omitted."  */
+			if (arg >= 0)
+			  {
+			    precision = arg;
+			    has_precision = 1;
+			  }
+		      }
+		    else
+		      {
+			const FCHAR_T *digitp = dp->precision_start + 1;
+
+			precision = 0;
+			while (digitp != dp->precision_end)
+			  precision = xsum (xtimes (precision, 10), *digitp++ - '0');
+			has_precision = 1;
+		      }
+		  }
+
+		switch (type)
+		  {
+		  case TYPE_U8_STRING:
+		    {
+		      const uint8_t *arg = a.arg[dp->arg_index].a.a_u8_string;
+		      const uint8_t *arg_end;
+		      size_t characters;
+
+		      if (has_precision)
+			{
+			  /* Use only PRECISION characters, from the left.  */
+			  arg_end = arg;
+			  characters = 0;
+			  for (; precision > 0; precision--)
+			    {
+			      int count = u8_strmblen (arg_end);
+			      if (count == 0)
+				break;
+			      if (count < 0)
+				{
+				  if (!(result == resultbuf || result == NULL))
+				    free (result);
+				  if (buf_malloced != NULL)
+				    free (buf_malloced);
+				  CLEANUP ();
+				  errno = EILSEQ;
+				  return NULL;
+				}
+			      arg_end += count;
+			      characters++;
+			    }
+			}
+		      else if (has_width)
+			{
+			  /* Use the entire string, and count the number of
+			     characters.  */
+			  arg_end = arg;
+			  characters = 0;
+			  for (;;)
+			    {
+			      int count = u8_strmblen (arg_end);
+			      if (count == 0)
+				break;
+			      if (count < 0)
+				{
+				  if (!(result == resultbuf || result == NULL))
+				    free (result);
+				  if (buf_malloced != NULL)
+				    free (buf_malloced);
+				  CLEANUP ();
+				  errno = EILSEQ;
+				  return NULL;
+				}
+			      arg_end += count;
+			      characters++;
+			    }
+			}
+		      else
+			{
+			  /* Use the entire string.  */
+			  arg_end = arg + u8_strlen (arg);
+			  /* The number of characters doesn't matter.  */
+			  characters = 0;
+			}
+
+		      if (has_width && width > characters
+			  && !(dp->flags & FLAG_LEFT))
+			{
+			  size_t n = width - characters;
+			  ENSURE_ALLOCATION (xsum (length, n));
+			  DCHAR_SET (result + length, ' ', n);
+			  length += n;
+			}
+
+# if DCHAR_IS_UINT8_T
+		      {
+			size_t n = arg_end - arg;
+			ENSURE_ALLOCATION (xsum (length, n));
+			DCHAR_CPY (result + length, arg, n);
+			length += n;
+		      }
+# else
+		      { /* Convert.  */
+			DCHAR_T *converted = result + length;
+			size_t converted_len = allocated - length;
+#  if DCHAR_IS_TCHAR
+			/* Convert from UTF-8 to locale encoding.  */
+			if (u8_conv_to_encoding (locale_charset (),
+						 iconveh_question_mark,
+						 arg, arg_end - arg, NULL,
+						 &converted, &converted_len)
+			    < 0)
+#  else
+			/* Convert from UTF-8 to UTF-16/UTF-32.  */
+			converted =
+			  U8_TO_DCHAR (arg, arg_end - arg,
+				       converted, &converted_len);
+			if (converted == NULL)
+#  endif
+			  {
+			    int saved_errno = errno;
+			    if (!(result == resultbuf || result == NULL))
+			      free (result);
+			    if (buf_malloced != NULL)
+			      free (buf_malloced);
+			    CLEANUP ();
+			    errno = saved_errno;
+			    return NULL;
+			  }
+			if (converted != result + length)
+			  {
+			    ENSURE_ALLOCATION (xsum (length, converted_len));
+			    DCHAR_CPY (result + length, converted, converted_len);
+			    free (converted);
+			  }
+			length += converted_len;
+		      }
+# endif
+
+		      if (has_width && width > characters
+			  && (dp->flags & FLAG_LEFT))
+			{
+			  size_t n = width - characters;
+			  ENSURE_ALLOCATION (xsum (length, n));
+			  DCHAR_SET (result + length, ' ', n);
+			  length += n;
+			}
+		    }
+		    break;
+
+		  case TYPE_U16_STRING:
+		    {
+		      const uint16_t *arg = a.arg[dp->arg_index].a.a_u16_string;
+		      const uint16_t *arg_end;
+		      size_t characters;
+
+		      if (has_precision)
+			{
+			  /* Use only PRECISION characters, from the left.  */
+			  arg_end = arg;
+			  characters = 0;
+			  for (; precision > 0; precision--)
+			    {
+			      int count = u16_strmblen (arg_end);
+			      if (count == 0)
+				break;
+			      if (count < 0)
+				{
+				  if (!(result == resultbuf || result == NULL))
+				    free (result);
+				  if (buf_malloced != NULL)
+				    free (buf_malloced);
+				  CLEANUP ();
+				  errno = EILSEQ;
+				  return NULL;
+				}
+			      arg_end += count;
+			      characters++;
+			    }
+			}
+		      else if (has_width)
+			{
+			  /* Use the entire string, and count the number of
+			     characters.  */
+			  arg_end = arg;
+			  characters = 0;
+			  for (;;)
+			    {
+			      int count = u16_strmblen (arg_end);
+			      if (count == 0)
+				break;
+			      if (count < 0)
+				{
+				  if (!(result == resultbuf || result == NULL))
+				    free (result);
+				  if (buf_malloced != NULL)
+				    free (buf_malloced);
+				  CLEANUP ();
+				  errno = EILSEQ;
+				  return NULL;
+				}
+			      arg_end += count;
+			      characters++;
+			    }
+			}
+		      else
+			{
+			  /* Use the entire string.  */
+			  arg_end = arg + u16_strlen (arg);
+			  /* The number of characters doesn't matter.  */
+			  characters = 0;
+			}
+
+		      if (has_width && width > characters
+			  && !(dp->flags & FLAG_LEFT))
+			{
+			  size_t n = width - characters;
+			  ENSURE_ALLOCATION (xsum (length, n));
+			  DCHAR_SET (result + length, ' ', n);
+			  length += n;
+			}
+
+# if DCHAR_IS_UINT16_T
+		      {
+			size_t n = arg_end - arg;
+			ENSURE_ALLOCATION (xsum (length, n));
+			DCHAR_CPY (result + length, arg, n);
+			length += n;
+		      }
+# else
+		      { /* Convert.  */
+			DCHAR_T *converted = result + length;
+			size_t converted_len = allocated - length;
+#  if DCHAR_IS_TCHAR
+			/* Convert from UTF-16 to locale encoding.  */
+			if (u16_conv_to_encoding (locale_charset (),
+						  iconveh_question_mark,
+						  arg, arg_end - arg, NULL,
+						  &converted, &converted_len)
+			    < 0)
+#  else
+			/* Convert from UTF-16 to UTF-8/UTF-32.  */
+			converted =
+			  U16_TO_DCHAR (arg, arg_end - arg,
+					converted, &converted_len);
+			if (converted == NULL)
+#  endif
+			  {
+			    int saved_errno = errno;
+			    if (!(result == resultbuf || result == NULL))
+			      free (result);
+			    if (buf_malloced != NULL)
+			      free (buf_malloced);
+			    CLEANUP ();
+			    errno = saved_errno;
+			    return NULL;
+			  }
+			if (converted != result + length)
+			  {
+			    ENSURE_ALLOCATION (xsum (length, converted_len));
+			    DCHAR_CPY (result + length, converted, converted_len);
+			    free (converted);
+			  }
+			length += converted_len;
+		      }
+# endif
+
+		      if (has_width && width > characters
+			  && (dp->flags & FLAG_LEFT))
+			{
+			  size_t n = width - characters;
+			  ENSURE_ALLOCATION (xsum (length, n));
+			  DCHAR_SET (result + length, ' ', n);
+			  length += n;
+			}
+		    }
+		    break;
+
+		  case TYPE_U32_STRING:
+		    {
+		      const uint32_t *arg = a.arg[dp->arg_index].a.a_u32_string;
+		      const uint32_t *arg_end;
+		      size_t characters;
+
+		      if (has_precision)
+			{
+			  /* Use only PRECISION characters, from the left.  */
+			  arg_end = arg;
+			  characters = 0;
+			  for (; precision > 0; precision--)
+			    {
+			      int count = u32_strmblen (arg_end);
+			      if (count == 0)
+				break;
+			      if (count < 0)
+				{
+				  if (!(result == resultbuf || result == NULL))
+				    free (result);
+				  if (buf_malloced != NULL)
+				    free (buf_malloced);
+				  CLEANUP ();
+				  errno = EILSEQ;
+				  return NULL;
+				}
+			      arg_end += count;
+			      characters++;
+			    }
+			}
+		      else if (has_width)
+			{
+			  /* Use the entire string, and count the number of
+			     characters.  */
+			  arg_end = arg;
+			  characters = 0;
+			  for (;;)
+			    {
+			      int count = u32_strmblen (arg_end);
+			      if (count == 0)
+				break;
+			      if (count < 0)
+				{
+				  if (!(result == resultbuf || result == NULL))
+				    free (result);
+				  if (buf_malloced != NULL)
+				    free (buf_malloced);
+				  CLEANUP ();
+				  errno = EILSEQ;
+				  return NULL;
+				}
+			      arg_end += count;
+			      characters++;
+			    }
+			}
+		      else
+			{
+			  /* Use the entire string.  */
+			  arg_end = arg + u32_strlen (arg);
+			  /* The number of characters doesn't matter.  */
+			  characters = 0;
+			}
+
+		      if (has_width && width > characters
+			  && !(dp->flags & FLAG_LEFT))
+			{
+			  size_t n = width - characters;
+			  ENSURE_ALLOCATION (xsum (length, n));
+			  DCHAR_SET (result + length, ' ', n);
+			  length += n;
+			}
+
+# if DCHAR_IS_UINT32_T
+		      {
+			size_t n = arg_end - arg;
+			ENSURE_ALLOCATION (xsum (length, n));
+			DCHAR_CPY (result + length, arg, n);
+			length += n;
+		      }
+# else
+		      { /* Convert.  */
+			DCHAR_T *converted = result + length;
+			size_t converted_len = allocated - length;
+#  if DCHAR_IS_TCHAR
+			/* Convert from UTF-32 to locale encoding.  */
+			if (u32_conv_to_encoding (locale_charset (),
+						  iconveh_question_mark,
+						  arg, arg_end - arg, NULL,
+						  &converted, &converted_len)
+			    < 0)
+#  else
+			/* Convert from UTF-32 to UTF-8/UTF-16.  */
+			converted =
+			  U32_TO_DCHAR (arg, arg_end - arg,
+					converted, &converted_len);
+			if (converted == NULL)
+#  endif
+			  {
+			    int saved_errno = errno;
+			    if (!(result == resultbuf || result == NULL))
+			      free (result);
+			    if (buf_malloced != NULL)
+			      free (buf_malloced);
+			    CLEANUP ();
+			    errno = saved_errno;
+			    return NULL;
+			  }
+			if (converted != result + length)
+			  {
+			    ENSURE_ALLOCATION (xsum (length, converted_len));
+			    DCHAR_CPY (result + length, converted, converted_len);
+			    free (converted);
+			  }
+			length += converted_len;
+		      }
+# endif
+
+		      if (has_width && width > characters
+			  && (dp->flags & FLAG_LEFT))
+			{
+			  size_t n = width - characters;
+			  ENSURE_ALLOCATION (xsum (length, n));
+			  DCHAR_SET (result + length, ' ', n);
+			  length += n;
+			}
+		    }
+		    break;
+
+		  default:
+		    abort ();
+		  }
+	      }
+#endif
+#if NEED_PRINTF_DIRECTIVE_A && !defined IN_LIBINTL
+	    else if (dp->conversion == 'a' || dp->conversion == 'A')
+	      {
+		arg_type type = a.arg[dp->arg_index].type;
+		int flags = dp->flags;
+		int has_width;
+		size_t width;
+		int has_precision;
+		size_t precision;
+		size_t tmp_length;
+		DCHAR_T tmpbuf[700];
+		DCHAR_T *tmp;
+		DCHAR_T *pad_ptr;
+		DCHAR_T *p;
+
+		has_width = 0;
+		width = 0;
+		if (dp->width_start != dp->width_end)
+		  {
+		    if (dp->width_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->width_arg_index].a.a_int;
+			if (arg < 0)
+			  {
+			    /* "A negative field width is taken as a '-' flag
+			        followed by a positive field width."  */
+			    flags |= FLAG_LEFT;
+			    width = (unsigned int) (-arg);
+			  }
+			else
+			  width = arg;
+		      }
+		    else
+		      {
+			const FCHAR_T *digitp = dp->width_start;
+
+			do
+			  width = xsum (xtimes (width, 10), *digitp++ - '0');
+			while (digitp != dp->width_end);
+		      }
+		    has_width = 1;
+		  }
+
+		has_precision = 0;
+		precision = 0;
+		if (dp->precision_start != dp->precision_end)
+		  {
+		    if (dp->precision_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->precision_arg_index].a.a_int;
+			/* "A negative precision is taken as if the precision
+			    were omitted."  */
+			if (arg >= 0)
+			  {
+			    precision = arg;
+			    has_precision = 1;
+			  }
+		      }
+		    else
+		      {
+			const FCHAR_T *digitp = dp->precision_start + 1;
+
+			precision = 0;
+			while (digitp != dp->precision_end)
+			  precision = xsum (xtimes (precision, 10), *digitp++ - '0');
+			has_precision = 1;
+		      }
+		  }
+
+		/* Allocate a temporary buffer of sufficient size.  */
+		if (type == TYPE_LONGDOUBLE)
+		  tmp_length =
+		    (unsigned int) ((LDBL_DIG + 1)
+				    * 0.831 /* decimal -> hexadecimal */
+				   )
+		    + 1; /* turn floor into ceil */
+		else
+		  tmp_length =
+		    (unsigned int) ((DBL_DIG + 1)
+				    * 0.831 /* decimal -> hexadecimal */
+				   )
+		    + 1; /* turn floor into ceil */
+		if (tmp_length < precision)
+		  tmp_length = precision;
+		/* Account for sign, decimal point etc. */
+		tmp_length = xsum (tmp_length, 12);
+
+		if (tmp_length < width)
+		  tmp_length = width;
+
+		tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */
+
+		if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))
+		  tmp = tmpbuf;
+		else
+		  {
+		    size_t tmp_memsize = xtimes (tmp_length, sizeof (DCHAR_T));
+
+		    if (size_overflow_p (tmp_memsize))
+		      /* Overflow, would lead to out of memory.  */
+		      goto out_of_memory;
+		    tmp = (DCHAR_T *) malloc (tmp_memsize);
+		    if (tmp == NULL)
+		      /* Out of memory.  */
+		      goto out_of_memory;
+		  }
+
+		pad_ptr = NULL;
+		p = tmp;
+		if (type == TYPE_LONGDOUBLE)
+		  {
+		    long double arg = a.arg[dp->arg_index].a.a_longdouble;
+
+		    if (isnanl (arg))
+		      {
+			if (dp->conversion == 'A')
+			  {
+			    *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
+			  }
+			else
+			  {
+			    *p++ = 'n'; *p++ = 'a'; *p++ = 'n';
+			  }
+		      }
+		    else
+		      {
+			int sign = 0;
+			DECL_LONG_DOUBLE_ROUNDING
+
+			BEGIN_LONG_DOUBLE_ROUNDING ();
+
+			if (signbit (arg)) /* arg < 0.0L or negative zero */
+			  {
+			    sign = -1;
+			    arg = -arg;
+			  }
+
+			if (sign < 0)
+			  *p++ = '-';
+			else if (flags & FLAG_SHOWSIGN)
+			  *p++ = '+';
+			else if (flags & FLAG_SPACE)
+			  *p++ = ' ';
+
+			if (arg > 0.0L && arg + arg == arg)
+			  {
+			    if (dp->conversion == 'A')
+			      {
+				*p++ = 'I'; *p++ = 'N'; *p++ = 'F';
+			      }
+			    else
+			      {
+				*p++ = 'i'; *p++ = 'n'; *p++ = 'f';
+			      }
+			  }
+			else
+			  {
+			    int exponent;
+			    long double mantissa;
+
+			    if (arg > 0.0L)
+			      mantissa = printf_frexpl (arg, &exponent);
+			    else
+			      {
+				exponent = 0;
+				mantissa = 0.0L;
+			      }
+
+			    if (has_precision
+				&& precision < (unsigned int) ((LDBL_DIG + 1) * 0.831) + 1)
+			      {
+				/* Round the mantissa.  */
+				long double tail = mantissa;
+				size_t q;
+
+				for (q = precision; ; q--)
+				  {
+				    int digit = (int) tail;
+				    tail -= digit;
+				    if (q == 0)
+				      {
+					if (digit & 1 ? tail >= 0.5L : tail > 0.5L)
+					  tail = 1 - tail;
+					else
+					  tail = - tail;
+					break;
+				      }
+				    tail *= 16.0L;
+				  }
+				if (tail != 0.0L)
+				  for (q = precision; q > 0; q--)
+				    tail *= 0.0625L;
+				mantissa += tail;
+			      }
+
+			    *p++ = '0';
+			    *p++ = dp->conversion - 'A' + 'X';
+			    pad_ptr = p;
+			    {
+			      int digit;
+
+			      digit = (int) mantissa;
+			      mantissa -= digit;
+			      *p++ = '0' + digit;
+			      if ((flags & FLAG_ALT)
+				  || mantissa > 0.0L || precision > 0)
+				{
+				  *p++ = decimal_point_char ();
+				  /* This loop terminates because we assume
+				     that FLT_RADIX is a power of 2.  */
+				  while (mantissa > 0.0L)
+				    {
+				      mantissa *= 16.0L;
+				      digit = (int) mantissa;
+				      mantissa -= digit;
+				      *p++ = digit
+					     + (digit < 10
+						? '0'
+						: dp->conversion - 10);
+				      if (precision > 0)
+					precision--;
+				    }
+				  while (precision > 0)
+				    {
+				      *p++ = '0';
+				      precision--;
+				    }
+				}
+			      }
+			      *p++ = dp->conversion - 'A' + 'P';
+# if WIDE_CHAR_VERSION
+			      {
+				static const wchar_t decimal_format[] =
+				  { '%', '+', 'd', '\0' };
+				SNPRINTF (p, 6 + 1, decimal_format, exponent);
+			      }
+			      while (*p != '\0')
+				p++;
+# else
+			      if (sizeof (DCHAR_T) == 1)
+				{
+				  sprintf ((char *) p, "%+d", exponent);
+				  while (*p != '\0')
+				    p++;
+				}
+			      else
+				{
+				  char expbuf[6 + 1];
+				  const char *ep;
+				  sprintf (expbuf, "%+d", exponent);
+				  for (ep = expbuf; (*p = *ep) != '\0'; ep++)
+				    p++;
+				}
+# endif
+			  }
+
+			END_LONG_DOUBLE_ROUNDING ();
+		      }
+		  }
+		else
+		  {
+		    double arg = a.arg[dp->arg_index].a.a_double;
+
+		    if (isnan (arg))
+		      {
+			if (dp->conversion == 'A')
+			  {
+			    *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
+			  }
+			else
+			  {
+			    *p++ = 'n'; *p++ = 'a'; *p++ = 'n';
+			  }
+		      }
+		    else
+		      {
+			int sign = 0;
+
+			if (signbit (arg)) /* arg < 0.0 or negative zero */
+			  {
+			    sign = -1;
+			    arg = -arg;
+			  }
+
+			if (sign < 0)
+			  *p++ = '-';
+			else if (flags & FLAG_SHOWSIGN)
+			  *p++ = '+';
+			else if (flags & FLAG_SPACE)
+			  *p++ = ' ';
+
+			if (arg > 0.0 && arg + arg == arg)
+			  {
+			    if (dp->conversion == 'A')
+			      {
+				*p++ = 'I'; *p++ = 'N'; *p++ = 'F';
+			      }
+			    else
+			      {
+				*p++ = 'i'; *p++ = 'n'; *p++ = 'f';
+			      }
+			  }
+			else
+			  {
+			    int exponent;
+			    double mantissa;
+
+			    if (arg > 0.0)
+			      mantissa = printf_frexp (arg, &exponent);
+			    else
+			      {
+				exponent = 0;
+				mantissa = 0.0;
+			      }
+
+			    if (has_precision
+				&& precision < (unsigned int) ((DBL_DIG + 1) * 0.831) + 1)
+			      {
+				/* Round the mantissa.  */
+				double tail = mantissa;
+				size_t q;
+
+				for (q = precision; ; q--)
+				  {
+				    int digit = (int) tail;
+				    tail -= digit;
+				    if (q == 0)
+				      {
+					if (digit & 1 ? tail >= 0.5 : tail > 0.5)
+					  tail = 1 - tail;
+					else
+					  tail = - tail;
+					break;
+				      }
+				    tail *= 16.0;
+				  }
+				if (tail != 0.0)
+				  for (q = precision; q > 0; q--)
+				    tail *= 0.0625;
+				mantissa += tail;
+			      }
+
+			    *p++ = '0';
+			    *p++ = dp->conversion - 'A' + 'X';
+			    pad_ptr = p;
+			    {
+			      int digit;
+
+			      digit = (int) mantissa;
+			      mantissa -= digit;
+			      *p++ = '0' + digit;
+			      if ((flags & FLAG_ALT)
+				  || mantissa > 0.0 || precision > 0)
+				{
+				  *p++ = decimal_point_char ();
+				  /* This loop terminates because we assume
+				     that FLT_RADIX is a power of 2.  */
+				  while (mantissa > 0.0)
+				    {
+				      mantissa *= 16.0;
+				      digit = (int) mantissa;
+				      mantissa -= digit;
+				      *p++ = digit
+					     + (digit < 10
+						? '0'
+						: dp->conversion - 10);
+				      if (precision > 0)
+					precision--;
+				    }
+				  while (precision > 0)
+				    {
+				      *p++ = '0';
+				      precision--;
+				    }
+				}
+			      }
+			      *p++ = dp->conversion - 'A' + 'P';
+# if WIDE_CHAR_VERSION
+			      {
+				static const wchar_t decimal_format[] =
+				  { '%', '+', 'd', '\0' };
+				SNPRINTF (p, 6 + 1, decimal_format, exponent);
+			      }
+			      while (*p != '\0')
+				p++;
+# else
+			      if (sizeof (DCHAR_T) == 1)
+				{
+				  sprintf ((char *) p, "%+d", exponent);
+				  while (*p != '\0')
+				    p++;
+				}
+			      else
+				{
+				  char expbuf[6 + 1];
+				  const char *ep;
+				  sprintf (expbuf, "%+d", exponent);
+				  for (ep = expbuf; (*p = *ep) != '\0'; ep++)
+				    p++;
+				}
+# endif
+			  }
+		      }
+		  }
+		/* The generated string now extends from tmp to p, with the
+		   zero padding insertion point being at pad_ptr.  */
+		if (has_width && p - tmp < width)
+		  {
+		    size_t pad = width - (p - tmp);
+		    DCHAR_T *end = p + pad;
+
+		    if (flags & FLAG_LEFT)
+		      {
+			/* Pad with spaces on the right.  */
+			for (; pad > 0; pad--)
+			  *p++ = ' ';
+		      }
+		    else if ((flags & FLAG_ZERO) && pad_ptr != NULL)
+		      {
+			/* Pad with zeroes.  */
+			DCHAR_T *q = end;
+
+			while (p > pad_ptr)
+			  *--q = *--p;
+			for (; pad > 0; pad--)
+			  *p++ = '0';
+		      }
+		    else
+		      {
+			/* Pad with spaces on the left.  */
+			DCHAR_T *q = end;
+
+			while (p > tmp)
+			  *--q = *--p;
+			for (; pad > 0; pad--)
+			  *p++ = ' ';
+		      }
+
+		    p = end;
+		  }
+
+		{
+		  size_t count = p - tmp;
+
+		  if (count >= tmp_length)
+		    /* tmp_length was incorrectly calculated - fix the
+		       code above!  */
+		    abort ();
+
+		  /* Make room for the result.  */
+		  if (count >= allocated - length)
+		    {
+		      size_t n = xsum (length, count);
+
+		      ENSURE_ALLOCATION (n);
+		    }
+
+		  /* Append the result.  */
+		  memcpy (result + length, tmp, count * sizeof (DCHAR_T));
+		  if (tmp != tmpbuf)
+		    free (tmp);
+		  length += count;
+		}
+	      }
+#endif
+#if (NEED_PRINTF_INFINITE_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE || NEED_PRINTF_LONG_DOUBLE) && !defined IN_LIBINTL
+	    else if ((dp->conversion == 'f' || dp->conversion == 'F'
+		      || dp->conversion == 'e' || dp->conversion == 'E'
+		      || dp->conversion == 'g' || dp->conversion == 'G'
+		      || dp->conversion == 'a' || dp->conversion == 'A')
+		     && (0
+# if NEED_PRINTF_INFINITE_DOUBLE
+			 || (a.arg[dp->arg_index].type == TYPE_DOUBLE
+			     /* The systems (mingw) which produce wrong output
+				for Inf, -Inf, and NaN also do so for -0.0.
+				Therefore we treat this case here as well.  */
+			     && is_infinite_or_zero (a.arg[dp->arg_index].a.a_double))
+# endif
+# if NEED_PRINTF_LONG_DOUBLE
+			 || a.arg[dp->arg_index].type == TYPE_LONGDOUBLE
+# elif NEED_PRINTF_INFINITE_LONG_DOUBLE
+			 || (a.arg[dp->arg_index].type == TYPE_LONGDOUBLE
+			     /* Some systems produce wrong output for Inf,
+				-Inf, and NaN.  */
+			     && is_infinitel (a.arg[dp->arg_index].a.a_longdouble))
+# endif
+			))
+	      {
+# if NEED_PRINTF_INFINITE_DOUBLE && (NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE)
+		arg_type type = a.arg[dp->arg_index].type;
+# endif
+		int flags = dp->flags;
+		int has_width;
+		size_t width;
+		int has_precision;
+		size_t precision;
+		size_t tmp_length;
+		DCHAR_T tmpbuf[700];
+		DCHAR_T *tmp;
+		DCHAR_T *pad_ptr;
+		DCHAR_T *p;
+
+		has_width = 0;
+		width = 0;
+		if (dp->width_start != dp->width_end)
+		  {
+		    if (dp->width_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->width_arg_index].a.a_int;
+			if (arg < 0)
+			  {
+			    /* "A negative field width is taken as a '-' flag
+			        followed by a positive field width."  */
+			    flags |= FLAG_LEFT;
+			    width = (unsigned int) (-arg);
+			  }
+			else
+			  width = arg;
+		      }
+		    else
+		      {
+			const FCHAR_T *digitp = dp->width_start;
+
+			do
+			  width = xsum (xtimes (width, 10), *digitp++ - '0');
+			while (digitp != dp->width_end);
+		      }
+		    has_width = 1;
+		  }
+
+		has_precision = 0;
+		precision = 0;
+		if (dp->precision_start != dp->precision_end)
+		  {
+		    if (dp->precision_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->precision_arg_index].a.a_int;
+			/* "A negative precision is taken as if the precision
+			    were omitted."  */
+			if (arg >= 0)
+			  {
+			    precision = arg;
+			    has_precision = 1;
+			  }
+		      }
+		    else
+		      {
+			const FCHAR_T *digitp = dp->precision_start + 1;
+
+			precision = 0;
+			while (digitp != dp->precision_end)
+			  precision = xsum (xtimes (precision, 10), *digitp++ - '0');
+			has_precision = 1;
+		      }
+		  }
+
+		/* POSIX specifies the default precision to be 6 for %f, %F,
+		   %e, %E, but not for %g, %G.  Implementations appear to use
+		   the same default precision also for %g, %G.  */
+		if (!has_precision)
+		  precision = 6;
+
+		/* Allocate a temporary buffer of sufficient size.  */
+# if NEED_PRINTF_INFINITE_DOUBLE && NEED_PRINTF_LONG_DOUBLE
+		tmp_length = (type == TYPE_LONGDOUBLE ? LDBL_DIG + 1 : 0);
+# elif NEED_PRINTF_LONG_DOUBLE
+		tmp_length = LDBL_DIG + 1;
+# else
+		tmp_length = 0;
+# endif
+		if (tmp_length < precision)
+		  tmp_length = precision;
+# if NEED_PRINTF_LONG_DOUBLE
+#  if NEED_PRINTF_INFINITE_DOUBLE
+		if (type == TYPE_LONGDOUBLE)
+#  endif
+		  if (dp->conversion == 'f' || dp->conversion == 'F')
+		    {
+		      long double arg = a.arg[dp->arg_index].a.a_longdouble;
+		      if (!(isnanl (arg) || arg + arg == arg))
+			{
+			  /* arg is finite and nonzero.  */
+			  int exponent = floorlog10l (arg < 0 ? -arg : arg);
+			  if (exponent >= 0 && tmp_length < exponent + precision)
+			    tmp_length = exponent + precision;
+			}
+		    }
+# endif
+		/* Account for sign, decimal point etc. */
+		tmp_length = xsum (tmp_length, 12);
+
+		if (tmp_length < width)
+		  tmp_length = width;
+
+		tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */
+
+		if (tmp_length <= sizeof (tmpbuf) / sizeof (DCHAR_T))
+		  tmp = tmpbuf;
+		else
+		  {
+		    size_t tmp_memsize = xtimes (tmp_length, sizeof (DCHAR_T));
+
+		    if (size_overflow_p (tmp_memsize))
+		      /* Overflow, would lead to out of memory.  */
+		      goto out_of_memory;
+		    tmp = (DCHAR_T *) malloc (tmp_memsize);
+		    if (tmp == NULL)
+		      /* Out of memory.  */
+		      goto out_of_memory;
+		  }
+
+		pad_ptr = NULL;
+		p = tmp;
+
+# if NEED_PRINTF_LONG_DOUBLE || NEED_PRINTF_INFINITE_LONG_DOUBLE
+#  if NEED_PRINTF_INFINITE_DOUBLE
+		if (type == TYPE_LONGDOUBLE)
+#  endif
+		  {
+		    long double arg = a.arg[dp->arg_index].a.a_longdouble;
+
+		    if (isnanl (arg))
+		      {
+			if (dp->conversion >= 'A' && dp->conversion <= 'Z')
+			  {
+			    *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
+			  }
+			else
+			  {
+			    *p++ = 'n'; *p++ = 'a'; *p++ = 'n';
+			  }
+		      }
+		    else
+		      {
+			int sign = 0;
+			DECL_LONG_DOUBLE_ROUNDING
+
+			BEGIN_LONG_DOUBLE_ROUNDING ();
+
+			if (signbit (arg)) /* arg < 0.0L or negative zero */
+			  {
+			    sign = -1;
+			    arg = -arg;
+			  }
+
+			if (sign < 0)
+			  *p++ = '-';
+			else if (flags & FLAG_SHOWSIGN)
+			  *p++ = '+';
+			else if (flags & FLAG_SPACE)
+			  *p++ = ' ';
+
+			if (arg > 0.0L && arg + arg == arg)
+			  {
+			    if (dp->conversion >= 'A' && dp->conversion <= 'Z')
+			      {
+				*p++ = 'I'; *p++ = 'N'; *p++ = 'F';
+			      }
+			    else
+			      {
+				*p++ = 'i'; *p++ = 'n'; *p++ = 'f';
+			      }
+			  }
+			else
+			  {
+#  if NEED_PRINTF_LONG_DOUBLE
+			    pad_ptr = p;
+
+			    if (dp->conversion == 'f' || dp->conversion == 'F')
+			      {
+				char *digits;
+				size_t ndigits;
+
+				digits =
+				  scale10_round_decimal_long_double (arg, precision);
+				if (digits == NULL)
+				  {
+				    END_LONG_DOUBLE_ROUNDING ();
+				    goto out_of_memory;
+				  }
+				ndigits = strlen (digits);
+
+				if (ndigits > precision)
+				  do
+				    {
+				      --ndigits;
+				      *p++ = digits[ndigits];
+				    }
+				  while (ndigits > precision);
+				else
+				  *p++ = '0';
+				/* Here ndigits <= precision.  */
+				if ((flags & FLAG_ALT) || precision > 0)
+				  {
+				    *p++ = decimal_point_char ();
+				    for (; precision > ndigits; precision--)
+				      *p++ = '0';
+				    while (ndigits > 0)
+				      {
+					--ndigits;
+					*p++ = digits[ndigits];
+				      }
+				  }
+
+				free (digits);
+			      }
+			    else if (dp->conversion == 'e' || dp->conversion == 'E')
+			      {
+				int exponent;
+
+				if (arg == 0.0L)
+				  {
+				    exponent = 0;
+				    *p++ = '0';
+				    if ((flags & FLAG_ALT) || precision > 0)
+				      {
+					*p++ = decimal_point_char ();
+					for (; precision > 0; precision--)
+					  *p++ = '0';
+				      }
+				  }
+				else
+				  {
+				    /* arg > 0.0L.  */
+				    int adjusted;
+				    char *digits;
+				    size_t ndigits;
+
+				    exponent = floorlog10l (arg);
+				    adjusted = 0;
+				    for (;;)
+				      {
+					digits =
+					  scale10_round_decimal_long_double (arg,
+									     (int)precision - exponent);
+					if (digits == NULL)
+					  {
+					    END_LONG_DOUBLE_ROUNDING ();
+					    goto out_of_memory;
+					  }
+					ndigits = strlen (digits);
+
+					if (ndigits == precision + 1)
+					  break;
+					if (ndigits < precision
+					    || ndigits > precision + 2)
+					  /* The exponent was not guessed
+					     precisely enough.  */
+					  abort ();
+					if (adjusted)
+					  /* None of two values of exponent is
+					     the right one.  Prevent an endless
+					     loop.  */
+					  abort ();
+					free (digits);
+					if (ndigits == precision)
+					  exponent -= 1;
+					else
+					  exponent += 1;
+					adjusted = 1;
+				      }
+
+				    /* Here ndigits = precision+1.  */
+				    *p++ = digits[--ndigits];
+				    if ((flags & FLAG_ALT) || precision > 0)
+				      {
+					*p++ = decimal_point_char ();
+					while (ndigits > 0)
+					  {
+					    --ndigits;
+					    *p++ = digits[ndigits];
+					  }
+				      }
+
+				    free (digits);
+				  }
+
+				*p++ = dp->conversion; /* 'e' or 'E' */
+#   if WIDE_CHAR_VERSION
+				{
+				  static const wchar_t decimal_format[] =
+				    { '%', '+', '.', '2', 'd', '\0' };
+				  SNPRINTF (p, 6 + 1, decimal_format, exponent);
+				}
+				while (*p != '\0')
+				  p++;
+#   else
+				if (sizeof (DCHAR_T) == 1)
+				  {
+				    sprintf ((char *) p, "%+.2d", exponent);
+				    while (*p != '\0')
+				      p++;
+				  }
+				else
+				  {
+				    char expbuf[6 + 1];
+				    const char *ep;
+				    sprintf (expbuf, "%+.2d", exponent);
+				    for (ep = expbuf; (*p = *ep) != '\0'; ep++)
+				      p++;
+				  }
+#   endif
+			      }
+			    else if (dp->conversion == 'g' || dp->conversion == 'G')
+			      {
+				if (precision == 0)
+				  precision = 1;
+				/* precision >= 1.  */
+
+				if (arg == 0.0L)
+				  /* The exponent is 0, >= -4, < precision.
+				     Use fixed-point notation.  */
+				  {
+				    size_t ndigits = precision;
+				    /* Number of trailing zeroes that have to be
+				       dropped.  */
+				    size_t nzeroes =
+				      (flags & FLAG_ALT ? 0 : precision - 1);
+
+				    --ndigits;
+				    *p++ = '0';
+				    if ((flags & FLAG_ALT) || ndigits > nzeroes)
+				      {
+					*p++ = decimal_point_char ();
+					while (ndigits > nzeroes)
+					  {
+					    --ndigits;
+					    *p++ = '0';
+					  }
+				      }
+				  }
+				else
+				  {
+				    /* arg > 0.0L.  */
+				    int exponent;
+				    int adjusted;
+				    char *digits;
+				    size_t ndigits;
+				    size_t nzeroes;
+
+				    exponent = floorlog10l (arg);
+				    adjusted = 0;
+				    for (;;)
+				      {
+					digits =
+					  scale10_round_decimal_long_double (arg,
+									     (int)(precision - 1) - exponent);
+					if (digits == NULL)
+					  {
+					    END_LONG_DOUBLE_ROUNDING ();
+					    goto out_of_memory;
+					  }
+					ndigits = strlen (digits);
+
+					if (ndigits == precision)
+					  break;
+					if (ndigits < precision - 1
+					    || ndigits > precision + 1)
+					  /* The exponent was not guessed
+					     precisely enough.  */
+					  abort ();
+					if (adjusted)
+					  /* None of two values of exponent is
+					     the right one.  Prevent an endless
+					     loop.  */
+					  abort ();
+					free (digits);
+					if (ndigits < precision)
+					  exponent -= 1;
+					else
+					  exponent += 1;
+					adjusted = 1;
+				      }
+				    /* Here ndigits = precision.  */
+
+				    /* Determine the number of trailing zeroes
+				       that have to be dropped.  */
+				    nzeroes = 0;
+				    if ((flags & FLAG_ALT) == 0)
+				      while (nzeroes < ndigits
+					     && digits[nzeroes] == '0')
+					nzeroes++;
+
+				    /* The exponent is now determined.  */
+				    if (exponent >= -4
+					&& exponent < (long)precision)
+				      {
+					/* Fixed-point notation:
+					   max(exponent,0)+1 digits, then the
+					   decimal point, then the remaining
+					   digits without trailing zeroes.  */
+					if (exponent >= 0)
+					  {
+					    size_t count = exponent + 1;
+					    /* Note: count <= precision = ndigits.  */
+					    for (; count > 0; count--)
+					      *p++ = digits[--ndigits];
+					    if ((flags & FLAG_ALT) || ndigits > nzeroes)
+					      {
+						*p++ = decimal_point_char ();
+						while (ndigits > nzeroes)
+						  {
+						    --ndigits;
+						    *p++ = digits[ndigits];
+						  }
+					      }
+					  }
+					else
+					  {
+					    size_t count = -exponent - 1;
+					    *p++ = '0';
+					    *p++ = decimal_point_char ();
+					    for (; count > 0; count--)
+					      *p++ = '0';
+					    while (ndigits > nzeroes)
+					      {
+						--ndigits;
+						*p++ = digits[ndigits];
+					      }
+					  }
+				      }
+				    else
+				      {
+					/* Exponential notation.  */
+					*p++ = digits[--ndigits];
+					if ((flags & FLAG_ALT) || ndigits > nzeroes)
+					  {
+					    *p++ = decimal_point_char ();
+					    while (ndigits > nzeroes)
+					      {
+						--ndigits;
+						*p++ = digits[ndigits];
+					      }
+					  }
+					*p++ = dp->conversion - 'G' + 'E'; /* 'e' or 'E' */
+#   if WIDE_CHAR_VERSION
+					{
+					  static const wchar_t decimal_format[] =
+					    { '%', '+', '.', '2', 'd', '\0' };
+					  SNPRINTF (p, 6 + 1, decimal_format, exponent);
+					}
+					while (*p != '\0')
+					  p++;
+#   else
+					if (sizeof (DCHAR_T) == 1)
+					  {
+					    sprintf ((char *) p, "%+.2d", exponent);
+					    while (*p != '\0')
+					      p++;
+					  }
+					else
+					  {
+					    char expbuf[6 + 1];
+					    const char *ep;
+					    sprintf (expbuf, "%+.2d", exponent);
+					    for (ep = expbuf; (*p = *ep) != '\0'; ep++)
+					      p++;
+					  }
+#   endif
+				      }
+
+				    free (digits);
+				  }
+			      }
+			    else
+			      abort ();
+#  else
+			    /* arg is finite.  */
+			    abort ();
+#  endif
+			  }
+
+			END_LONG_DOUBLE_ROUNDING ();
+		      }
+		  }
+#  if NEED_PRINTF_INFINITE_DOUBLE
+		else
+#  endif
+# endif
+# if NEED_PRINTF_INFINITE_DOUBLE
+		  {
+		    /* Simpler than above: handle only NaN, Infinity, zero.  */
+		    double arg = a.arg[dp->arg_index].a.a_double;
+
+		    if (isnan (arg))
+		      {
+			if (dp->conversion >= 'A' && dp->conversion <= 'Z')
+			  {
+			    *p++ = 'N'; *p++ = 'A'; *p++ = 'N';
+			  }
+			else
+			  {
+			    *p++ = 'n'; *p++ = 'a'; *p++ = 'n';
+			  }
+		      }
+		    else
+		      {
+			int sign = 0;
+
+			if (signbit (arg)) /* arg < 0.0L or negative zero */
+			  {
+			    sign = -1;
+			    arg = -arg;
+			  }
+
+			if (sign < 0)
+			  *p++ = '-';
+			else if (flags & FLAG_SHOWSIGN)
+			  *p++ = '+';
+			else if (flags & FLAG_SPACE)
+			  *p++ = ' ';
+
+			if (arg > 0.0 && arg + arg == arg)
+			  {
+			    if (dp->conversion >= 'A' && dp->conversion <= 'Z')
+			      {
+				*p++ = 'I'; *p++ = 'N'; *p++ = 'F';
+			      }
+			    else
+			      {
+				*p++ = 'i'; *p++ = 'n'; *p++ = 'f';
+			      }
+			  }
+			else
+			  {
+			    if (!(arg == 0.0))
+			      abort ();
+
+			    pad_ptr = p;
+
+			    if (dp->conversion == 'f' || dp->conversion == 'F')
+			      {
+				*p++ = '0';
+				if ((flags & FLAG_ALT) || precision > 0)
+				  {
+				    *p++ = decimal_point_char ();
+				    for (; precision > 0; precision--)
+				      *p++ = '0';
+				  }
+			      }
+			    else if (dp->conversion == 'e' || dp->conversion == 'E')
+			      {
+				*p++ = '0';
+				if ((flags & FLAG_ALT) || precision > 0)
+				  {
+				    *p++ = decimal_point_char ();
+				    for (; precision > 0; precision--)
+				      *p++ = '0';
+				  }
+				*p++ = dp->conversion; /* 'e' or 'E' */
+				*p++ = '+';
+				/* Produce the same number of exponent digits as
+				   the native printf implementation.  */
+#  if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+				*p++ = '0';
+#  endif
+				*p++ = '0';
+				*p++ = '0';
+			      }
+			    else if (dp->conversion == 'g' || dp->conversion == 'G')
+			      {
+				*p++ = '0';
+				if (flags & FLAG_ALT)
+				  {
+				    size_t ndigits =
+				      (precision > 0 ? precision - 1 : 0);
+				    *p++ = decimal_point_char ();
+				    for (; ndigits > 0; --ndigits)
+				      *p++ = '0';
+				  }
+			      }
+			    else
+			      abort ();
+			  }
+		      }
+		  }
+# endif
+
+		/* The generated string now extends from tmp to p, with the
+		   zero padding insertion point being at pad_ptr.  */
+		if (has_width && p - tmp < width)
+		  {
+		    size_t pad = width - (p - tmp);
+		    DCHAR_T *end = p + pad;
+
+		    if (flags & FLAG_LEFT)
+		      {
+			/* Pad with spaces on the right.  */
+			for (; pad > 0; pad--)
+			  *p++ = ' ';
+		      }
+		    else if ((flags & FLAG_ZERO) && pad_ptr != NULL)
+		      {
+			/* Pad with zeroes.  */
+			DCHAR_T *q = end;
+
+			while (p > pad_ptr)
+			  *--q = *--p;
+			for (; pad > 0; pad--)
+			  *p++ = '0';
+		      }
+		    else
+		      {
+			/* Pad with spaces on the left.  */
+			DCHAR_T *q = end;
+
+			while (p > tmp)
+			  *--q = *--p;
+			for (; pad > 0; pad--)
+			  *p++ = ' ';
+		      }
+
+		    p = end;
+		  }
+
+		{
+		  size_t count = p - tmp;
+
+		  if (count >= tmp_length)
+		    /* tmp_length was incorrectly calculated - fix the
+		       code above!  */
+		    abort ();
+
+		  /* Make room for the result.  */
+		  if (count >= allocated - length)
+		    {
+		      size_t n = xsum (length, count);
+
+		      ENSURE_ALLOCATION (n);
+		    }
+
+		  /* Append the result.  */
+		  memcpy (result + length, tmp, count * sizeof (DCHAR_T));
+		  if (tmp != tmpbuf)
+		    free (tmp);
+		  length += count;
+		}
+	      }
+#endif
+	    else
+	      {
+		arg_type type = a.arg[dp->arg_index].type;
+		int flags = dp->flags;
+#if !USE_SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO
+		int has_width;
+		size_t width;
+#endif
+#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO
+		int pad_ourselves;
+#else
+#		define pad_ourselves 0
+#endif
+		TCHAR_T *fbp;
+		unsigned int prefix_count;
+		int prefixes[2];
+#if !USE_SNPRINTF
+		size_t tmp_length;
+		TCHAR_T tmpbuf[700];
+		TCHAR_T *tmp;
+#endif
+
+#if !USE_SNPRINTF || !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO
+		has_width = 0;
+		width = 0;
+		if (dp->width_start != dp->width_end)
+		  {
+		    if (dp->width_arg_index != ARG_NONE)
+		      {
+			int arg;
+
+			if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
+			  abort ();
+			arg = a.arg[dp->width_arg_index].a.a_int;
+			if (arg < 0)
+			  {
+			    /* "A negative field width is taken as a '-' flag
+			        followed by a positive field width."  */
+			    flags |= FLAG_LEFT;
+			    width = (unsigned int) (-arg);
+			  }
+			else
+			  width = arg;
+		      }
+		    else
+		      {
+			const FCHAR_T *digitp = dp->width_start;
+
+			do
+			  width = xsum (xtimes (width, 10), *digitp++ - '0');
+			while (digitp != dp->width_end);
+		      }
+		    has_width = 1;
+		  }
+#endif
+
+#if !USE_SNPRINTF
+		/* Allocate a temporary buffer of sufficient size for calling
+		   sprintf.  */
+		{
+		  size_t precision;
+
+		  precision = 6;
+		  if (dp->precision_start != dp->precision_end)
+		    {
+		      if (dp->precision_arg_index != ARG_NONE)
+			{
+			  int arg;
+
+			  if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
+			    abort ();
+			  arg = a.arg[dp->precision_arg_index].a.a_int;
+			  precision = (arg < 0 ? 0 : arg);
+			}
+		      else
+			{
+			  const FCHAR_T *digitp = dp->precision_start + 1;
+
+			  precision = 0;
+			  while (digitp != dp->precision_end)
+			    precision = xsum (xtimes (precision, 10), *digitp++ - '0');
+			}
+		    }
+
+		  switch (dp->conversion)
+		    {
+
+		    case 'd': case 'i': case 'u':
+# if HAVE_LONG_LONG_INT
+		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
+					  * 0.30103 /* binary -> decimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      else
+# endif
+		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
+					  * 0.30103 /* binary -> decimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      else
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
+					  * 0.30103 /* binary -> decimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      if (tmp_length < precision)
+			tmp_length = precision;
+		      /* Multiply by 2, as an estimate for FLAG_GROUP.  */
+		      tmp_length = xsum (tmp_length, tmp_length);
+		      /* Add 1, to account for a leading sign.  */
+		      tmp_length = xsum (tmp_length, 1);
+		      break;
+
+		    case 'o':
+# if HAVE_LONG_LONG_INT
+		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
+					  * 0.333334 /* binary -> octal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      else
+# endif
+		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
+					  * 0.333334 /* binary -> octal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      else
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
+					  * 0.333334 /* binary -> octal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      if (tmp_length < precision)
+			tmp_length = precision;
+		      /* Add 1, to account for a leading sign.  */
+		      tmp_length = xsum (tmp_length, 1);
+		      break;
+
+		    case 'x': case 'X':
+# if HAVE_LONG_LONG_INT
+		      if (type == TYPE_LONGLONGINT || type == TYPE_ULONGLONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long long) * CHAR_BIT
+					  * 0.25 /* binary -> hexadecimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      else
+# endif
+		      if (type == TYPE_LONGINT || type == TYPE_ULONGINT)
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned long) * CHAR_BIT
+					  * 0.25 /* binary -> hexadecimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      else
+			tmp_length =
+			  (unsigned int) (sizeof (unsigned int) * CHAR_BIT
+					  * 0.25 /* binary -> hexadecimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      if (tmp_length < precision)
+			tmp_length = precision;
+		      /* Add 2, to account for a leading sign or alternate form.  */
+		      tmp_length = xsum (tmp_length, 2);
+		      break;
+
+		    case 'f': case 'F':
+		      if (type == TYPE_LONGDOUBLE)
+			tmp_length =
+			  (unsigned int) (LDBL_MAX_EXP
+					  * 0.30103 /* binary -> decimal */
+					  * 2 /* estimate for FLAG_GROUP */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 10; /* sign, decimal point etc. */
+		      else
+			tmp_length =
+			  (unsigned int) (DBL_MAX_EXP
+					  * 0.30103 /* binary -> decimal */
+					  * 2 /* estimate for FLAG_GROUP */
+					 )
+			  + 1 /* turn floor into ceil */
+			  + 10; /* sign, decimal point etc. */
+		      tmp_length = xsum (tmp_length, precision);
+		      break;
+
+		    case 'e': case 'E': case 'g': case 'G':
+		      tmp_length =
+			12; /* sign, decimal point, exponent etc. */
+		      tmp_length = xsum (tmp_length, precision);
+		      break;
+
+		    case 'a': case 'A':
+		      if (type == TYPE_LONGDOUBLE)
+			tmp_length =
+			  (unsigned int) (LDBL_DIG
+					  * 0.831 /* decimal -> hexadecimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      else
+			tmp_length =
+			  (unsigned int) (DBL_DIG
+					  * 0.831 /* decimal -> hexadecimal */
+					 )
+			  + 1; /* turn floor into ceil */
+		      if (tmp_length < precision)
+			tmp_length = precision;
+		      /* Account for sign, decimal point etc. */
+		      tmp_length = xsum (tmp_length, 12);
+		      break;
+
+		    case 'c':
+# if HAVE_WINT_T && !WIDE_CHAR_VERSION
+		      if (type == TYPE_WIDE_CHAR)
+			tmp_length = MB_CUR_MAX;
+		      else
+# endif
+			tmp_length = 1;
+		      break;
+
+		    case 's':
+# if HAVE_WCHAR_T
+		      if (type == TYPE_WIDE_STRING)
+			{
+			  tmp_length =
+			    local_wcslen (a.arg[dp->arg_index].a.a_wide_string);
+
+#  if !WIDE_CHAR_VERSION
+			  tmp_length = xtimes (tmp_length, MB_CUR_MAX);
+#  endif
+			}
+		      else
+# endif
+			tmp_length = strlen (a.arg[dp->arg_index].a.a_string);
+		      break;
+
+		    case 'p':
+		      tmp_length =
+			(unsigned int) (sizeof (void *) * CHAR_BIT
+					* 0.25 /* binary -> hexadecimal */
+				       )
+			  + 1 /* turn floor into ceil */
+			  + 2; /* account for leading 0x */
+		      break;
+
+		    default:
+		      abort ();
+		    }
+
+# if ENABLE_UNISTDIO
+		  /* Padding considers the number of characters, therefore the
+		     number of elements after padding may be
+		       > max (tmp_length, width)
+		     but is certainly
+		       <= tmp_length + width.  */
+		  tmp_length = xsum (tmp_length, width);
+# else
+		  /* Padding considers the number of elements, says POSIX.  */
+		  if (tmp_length < width)
+		    tmp_length = width;
+# endif
+
+		  tmp_length = xsum (tmp_length, 1); /* account for trailing NUL */
+		}
+
+		if (tmp_length <= sizeof (tmpbuf) / sizeof (TCHAR_T))
+		  tmp = tmpbuf;
+		else
+		  {
+		    size_t tmp_memsize = xtimes (tmp_length, sizeof (TCHAR_T));
+
+		    if (size_overflow_p (tmp_memsize))
+		      /* Overflow, would lead to out of memory.  */
+		      goto out_of_memory;
+		    tmp = (TCHAR_T *) malloc (tmp_memsize);
+		    if (tmp == NULL)
+		      /* Out of memory.  */
+		      goto out_of_memory;
+		  }
+#endif
+
+		/* Decide whether to perform the padding ourselves.  */
+#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO
+		switch (dp->conversion)
+		  {
+# if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO
+		  /* If we need conversion from TCHAR_T[] to DCHAR_T[], we need
+		     to perform the padding after this conversion.  Functions
+		     with unistdio extensions perform the padding based on
+		     character count rather than element count.  */
+		  case 'c': case 's':
+# endif
+# if NEED_PRINTF_FLAG_ZERO
+		  case 'f': case 'F': case 'e': case 'E': case 'g': case 'G':
+		  case 'a': case 'A':
+# endif
+		    pad_ourselves = 1;
+		    break;
+		  default:
+		    pad_ourselves = 0;
+		    break;
+		  }
+#endif
+
+		/* Construct the format string for calling snprintf or
+		   sprintf.  */
+		fbp = buf;
+		*fbp++ = '%';
+#if NEED_PRINTF_FLAG_GROUPING
+		/* The underlying implementation doesn't support the ' flag.
+		   Produce no grouping characters in this case; this is
+		   acceptable because the grouping is locale dependent.  */
+#else
+		if (flags & FLAG_GROUP)
+		  *fbp++ = '\'';
+#endif
+		if (flags & FLAG_LEFT)
+		  *fbp++ = '-';
+		if (flags & FLAG_SHOWSIGN)
+		  *fbp++ = '+';
+		if (flags & FLAG_SPACE)
+		  *fbp++ = ' ';
+		if (flags & FLAG_ALT)
+		  *fbp++ = '#';
+		if (!pad_ourselves)
+		  {
+		    if (flags & FLAG_ZERO)
+		      *fbp++ = '0';
+		    if (dp->width_start != dp->width_end)
+		      {
+			size_t n = dp->width_end - dp->width_start;
+			/* The width specification is known to consist only
+			   of standard ASCII characters.  */
+			if (sizeof (FCHAR_T) == sizeof (TCHAR_T))
+			  {
+			    memcpy (fbp, dp->width_start, n * sizeof (TCHAR_T));
+			    fbp += n;
+			  }
+			else
+			  {
+			    const FCHAR_T *mp = dp->width_start;
+			    do
+			      *fbp++ = (unsigned char) *mp++;
+			    while (--n > 0);
+			  }
+		      }
+		  }
+		if (dp->precision_start != dp->precision_end)
+		  {
+		    size_t n = dp->precision_end - dp->precision_start;
+		    /* The precision specification is known to consist only
+		       of standard ASCII characters.  */
+		    if (sizeof (FCHAR_T) == sizeof (TCHAR_T))
+		      {
+		        memcpy (fbp, dp->precision_start, n * sizeof (TCHAR_T));
+		        fbp += n;
+		      }
+		    else
+		      {
+			const FCHAR_T *mp = dp->precision_start;
+			do
+			  *fbp++ = (unsigned char) *mp++;
+			while (--n > 0);
+		      }
+		  }
+
+		switch (type)
+		  {
+#if HAVE_LONG_LONG_INT
+		  case TYPE_LONGLONGINT:
+		  case TYPE_ULONGLONGINT:
+# if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
+		    *fbp++ = 'I';
+		    *fbp++ = '6';
+		    *fbp++ = '4';
+		    break;
+# else
+		    *fbp++ = 'l';
+		    /*FALLTHROUGH*/
+# endif
+#endif
+		  case TYPE_LONGINT:
+		  case TYPE_ULONGINT:
+#if HAVE_WINT_T
+		  case TYPE_WIDE_CHAR:
+#endif
+#if HAVE_WCHAR_T
+		  case TYPE_WIDE_STRING:
+#endif
+		    *fbp++ = 'l';
+		    break;
+		  case TYPE_LONGDOUBLE:
+		    *fbp++ = 'L';
+		    break;
+		  default:
+		    break;
+		  }
+#if NEED_PRINTF_DIRECTIVE_F
+		if (dp->conversion == 'F')
+		  *fbp = 'f';
+		else
+#endif
+		  *fbp = dp->conversion;
+#if USE_SNPRINTF
+# if !(__GLIBC__ > 2 || (__GLIBC__ == 2 && __GLIBC_MINOR__ >= 3))
+		fbp[1] = '%';
+		fbp[2] = 'n';
+		fbp[3] = '\0';
+# else
+		/* On glibc2 systems from glibc >= 2.3 - probably also older
+		   ones - we know that snprintf's returns value conforms to
+		   ISO C 99: the gl_SNPRINTF_DIRECTIVE_N test passes.
+		   Therefore we can avoid using %n in this situation.
+		   On glibc2 systems from 2004-10-18 or newer, the use of %n
+		   in format strings in writable memory may crash the program
+		   (if compiled with _FORTIFY_SOURCE=2), so we should avoid it
+		   in this situation.  */
+		fbp[1] = '\0';
+# endif
+#else
+		fbp[1] = '\0';
+#endif
+
+		/* Construct the arguments for calling snprintf or sprintf.  */
+		prefix_count = 0;
+		if (!pad_ourselves && dp->width_arg_index != ARG_NONE)
+		  {
+		    if (!(a.arg[dp->width_arg_index].type == TYPE_INT))
+		      abort ();
+		    prefixes[prefix_count++] = a.arg[dp->width_arg_index].a.a_int;
+		  }
+		if (dp->precision_arg_index != ARG_NONE)
+		  {
+		    if (!(a.arg[dp->precision_arg_index].type == TYPE_INT))
+		      abort ();
+		    prefixes[prefix_count++] = a.arg[dp->precision_arg_index].a.a_int;
+		  }
+
+#if USE_SNPRINTF
+		/* The SNPRINTF result is appended after result[0..length].
+		   The latter is an array of DCHAR_T; SNPRINTF appends an
+		   array of TCHAR_T to it.  This is possible because
+		   sizeof (TCHAR_T) divides sizeof (DCHAR_T) and
+		   alignof (TCHAR_T) <= alignof (DCHAR_T).  */
+# define TCHARS_PER_DCHAR (sizeof (DCHAR_T) / sizeof (TCHAR_T))
+		/* Prepare checking whether snprintf returns the count
+		   via %n.  */
+		ENSURE_ALLOCATION (xsum (length, 1));
+		*(TCHAR_T *) (result + length) = '\0';
+#endif
+
+		for (;;)
+		  {
+		    int count = -1;
+
+#if USE_SNPRINTF
+		    int retcount = 0;
+		    size_t maxlen = allocated - length;
+		    /* SNPRINTF can fail if its second argument is
+		       > INT_MAX.  */
+		    if (maxlen > INT_MAX / TCHARS_PER_DCHAR)
+		      maxlen = INT_MAX / TCHARS_PER_DCHAR;
+		    maxlen = maxlen * TCHARS_PER_DCHAR;
+# define SNPRINTF_BUF(arg) \
+		    switch (prefix_count)				    \
+		      {							    \
+		      case 0:						    \
+			retcount = SNPRINTF ((TCHAR_T *) (result + length), \
+					     maxlen, buf,		    \
+					     arg, &count);		    \
+			break;						    \
+		      case 1:						    \
+			retcount = SNPRINTF ((TCHAR_T *) (result + length), \
+					     maxlen, buf,		    \
+					     prefixes[0], arg, &count);	    \
+			break;						    \
+		      case 2:						    \
+			retcount = SNPRINTF ((TCHAR_T *) (result + length), \
+					     maxlen, buf,		    \
+					     prefixes[0], prefixes[1], arg, \
+					     &count);			    \
+			break;						    \
+		      default:						    \
+			abort ();					    \
+		      }
+#else
+# define SNPRINTF_BUF(arg) \
+		    switch (prefix_count)				    \
+		      {							    \
+		      case 0:						    \
+			count = sprintf (tmp, buf, arg);		    \
+			break;						    \
+		      case 1:						    \
+			count = sprintf (tmp, buf, prefixes[0], arg);	    \
+			break;						    \
+		      case 2:						    \
+			count = sprintf (tmp, buf, prefixes[0], prefixes[1],\
+					 arg);				    \
+			break;						    \
+		      default:						    \
+			abort ();					    \
+		      }
+#endif
+
+		    switch (type)
+		      {
+		      case TYPE_SCHAR:
+			{
+			  int arg = a.arg[dp->arg_index].a.a_schar;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_UCHAR:
+			{
+			  unsigned int arg = a.arg[dp->arg_index].a.a_uchar;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_SHORT:
+			{
+			  int arg = a.arg[dp->arg_index].a.a_short;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_USHORT:
+			{
+			  unsigned int arg = a.arg[dp->arg_index].a.a_ushort;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_INT:
+			{
+			  int arg = a.arg[dp->arg_index].a.a_int;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_UINT:
+			{
+			  unsigned int arg = a.arg[dp->arg_index].a.a_uint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_LONGINT:
+			{
+			  long int arg = a.arg[dp->arg_index].a.a_longint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_ULONGINT:
+			{
+			  unsigned long int arg = a.arg[dp->arg_index].a.a_ulongint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#if HAVE_LONG_LONG_INT
+		      case TYPE_LONGLONGINT:
+			{
+			  long long int arg = a.arg[dp->arg_index].a.a_longlongint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_ULONGLONGINT:
+			{
+			  unsigned long long int arg = a.arg[dp->arg_index].a.a_ulonglongint;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#endif
+		      case TYPE_DOUBLE:
+			{
+			  double arg = a.arg[dp->arg_index].a.a_double;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_LONGDOUBLE:
+			{
+			  long double arg = a.arg[dp->arg_index].a.a_longdouble;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      case TYPE_CHAR:
+			{
+			  int arg = a.arg[dp->arg_index].a.a_char;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#if HAVE_WINT_T
+		      case TYPE_WIDE_CHAR:
+			{
+			  wint_t arg = a.arg[dp->arg_index].a.a_wide_char;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#endif
+		      case TYPE_STRING:
+			{
+			  const char *arg = a.arg[dp->arg_index].a.a_string;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#if HAVE_WCHAR_T
+		      case TYPE_WIDE_STRING:
+			{
+			  const wchar_t *arg = a.arg[dp->arg_index].a.a_wide_string;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+#endif
+		      case TYPE_POINTER:
+			{
+			  void *arg = a.arg[dp->arg_index].a.a_pointer;
+			  SNPRINTF_BUF (arg);
+			}
+			break;
+		      default:
+			abort ();
+		      }
+
+#if USE_SNPRINTF
+		    /* Portability: Not all implementations of snprintf()
+		       are ISO C 99 compliant.  Determine the number of
+		       bytes that snprintf() has produced or would have
+		       produced.  */
+		    if (count >= 0)
+		      {
+			/* Verify that snprintf() has NUL-terminated its
+			   result.  */
+			if (count < maxlen
+			    && ((TCHAR_T *) (result + length)) [count] != '\0')
+			  abort ();
+			/* Portability hack.  */
+			if (retcount > count)
+			  count = retcount;
+		      }
+		    else
+		      {
+			/* snprintf() doesn't understand the '%n'
+			   directive.  */
+			if (fbp[1] != '\0')
+			  {
+			    /* Don't use the '%n' directive; instead, look
+			       at the snprintf() return value.  */
+			    fbp[1] = '\0';
+			    continue;
+			  }
+			else
+			  {
+			    /* Look at the snprintf() return value.  */
+			    if (retcount < 0)
+			      {
+				/* HP-UX 10.20 snprintf() is doubly deficient:
+				   It doesn't understand the '%n' directive,
+				   *and* it returns -1 (rather than the length
+				   that would have been required) when the
+				   buffer is too small.  */
+				size_t bigger_need =
+				  xsum (xtimes (allocated, 2), 12);
+				ENSURE_ALLOCATION (bigger_need);
+				continue;
+			      }
+			    else
+			      count = retcount;
+			  }
+		      }
+#endif
+
+		    /* Attempt to handle failure.  */
+		    if (count < 0)
+		      {
+			if (!(result == resultbuf || result == NULL))
+			  free (result);
+			if (buf_malloced != NULL)
+			  free (buf_malloced);
+			CLEANUP ();
+			errno = EINVAL;
+			return NULL;
+		      }
+
+#if USE_SNPRINTF
+		    /* Handle overflow of the allocated buffer.  */
+		    if (count >= maxlen)
+		      {
+			/* If maxlen already has attained its allowed maximum,
+			   allocating more memory will not increase maxlen.
+			   Instead of looping, bail out.  */
+			if (maxlen == INT_MAX / TCHARS_PER_DCHAR)
+			  goto overflow;
+			else
+			  {
+			    /* Need at least count * sizeof (TCHAR_T) bytes.
+			       But allocate proportionally, to avoid looping
+			       eternally if snprintf() reports a too small
+			       count.  */
+			    size_t n =
+			      xmax (xsum (length,
+					  (count + TCHARS_PER_DCHAR - 1)
+					  / TCHARS_PER_DCHAR),
+				    xtimes (allocated, 2));
+
+			    ENSURE_ALLOCATION (n);
+			    continue;
+			  }
+		      }
+#endif
+
+#if !DCHAR_IS_TCHAR
+# if !USE_SNPRINTF
+		    if (count >= tmp_length)
+		      /* tmp_length was incorrectly calculated - fix the
+			 code above!  */
+		      abort ();
+# endif
+
+		    /* Convert from TCHAR_T[] to DCHAR_T[].  */
+		    if (dp->conversion == 'c' || dp->conversion == 's')
+		      {
+			/* type = TYPE_CHAR or TYPE_WIDE_CHAR or TYPE_STRING
+			   TYPE_WIDE_STRING.
+			   The result string is not certainly ASCII.  */
+			const TCHAR_T *tmpsrc;
+			DCHAR_T *tmpdst;
+			size_t tmpdst_len;
+			/* This code assumes that TCHAR_T is 'char'.  */
+			typedef int TCHAR_T_verify
+				    [2 * (sizeof (TCHAR_T) == 1) - 1];
+# if USE_SNPRINTF
+			tmpsrc = (TCHAR_T *) (result + length);
+# else
+			tmpsrc = tmp;
+# endif
+			tmpdst = NULL;
+			tmpdst_len = 0;
+			if (DCHAR_CONV_FROM_ENCODING (locale_charset (),
+						      iconveh_question_mark,
+						      tmpsrc, count,
+						      NULL,
+						      &tmpdst, &tmpdst_len)
+			    < 0)
+			  {
+			    int saved_errno = errno;
+			    if (!(result == resultbuf || result == NULL))
+			      free (result);
+			    if (buf_malloced != NULL)
+			      free (buf_malloced);
+			    CLEANUP ();
+			    errno = saved_errno;
+			    return NULL;
+			  }
+			ENSURE_ALLOCATION (xsum (length, tmpdst_len));
+			DCHAR_CPY (result + length, tmpdst, tmpdst_len);
+			free (tmpdst);
+			count = tmpdst_len;
+		      }
+		    else
+		      {
+			/* The result string is ASCII.
+			   Simple 1:1 conversion.  */
+# if USE_SNPRINTF
+			/* If sizeof (DCHAR_T) == sizeof (TCHAR_T), it's a
+			   no-op conversion, in-place on the array starting
+			   at (result + length).  */
+			if (sizeof (DCHAR_T) != sizeof (TCHAR_T))
+# endif
+			  {
+			    const TCHAR_T *tmpsrc;
+			    DCHAR_T *tmpdst;
+			    size_t n;
+
+# if USE_SNPRINTF
+			    if (result == resultbuf)
+			      {
+				tmpsrc = (TCHAR_T *) (result + length);
+				/* ENSURE_ALLOCATION will not move tmpsrc
+				   (because it's part of resultbuf).  */
+				ENSURE_ALLOCATION (xsum (length, count));
+			      }
+			    else
+			      {
+				/* ENSURE_ALLOCATION will move the array
+				   (because it uses realloc().  */
+				ENSURE_ALLOCATION (xsum (length, count));
+				tmpsrc = (TCHAR_T *) (result + length);
+			      }
+# else
+			    tmpsrc = tmp;
+			    ENSURE_ALLOCATION (xsum (length, count));
+# endif
+			    tmpdst = result + length;
+			    /* Copy backwards, because of overlapping.  */
+			    tmpsrc += count;
+			    tmpdst += count;
+			    for (n = count; n > 0; n--)
+			      *--tmpdst = (unsigned char) *--tmpsrc;
+			  }
+		      }
+#endif
+
+#if DCHAR_IS_TCHAR && !USE_SNPRINTF
+		    /* Make room for the result.  */
+		    if (count > allocated - length)
+		      {
+			/* Need at least count elements.  But allocate
+			   proportionally.  */
+			size_t n =
+			  xmax (xsum (length, count), xtimes (allocated, 2));
+
+			ENSURE_ALLOCATION (n);
+		      }
+#endif
+
+		    /* Here count <= allocated - length.  */
+
+		    /* Perform padding.  */
+#if !DCHAR_IS_TCHAR || ENABLE_UNISTDIO || NEED_PRINTF_FLAG_ZERO
+		    if (pad_ourselves && has_width)
+		      {
+			size_t w;
+# if ENABLE_UNISTDIO
+			/* Outside POSIX, it's preferrable to compare the width
+			   against the number of _characters_ of the converted
+			   value.  */
+			w = DCHAR_MBSNLEN (result + length, count);
+# else
+			/* The width is compared against the number of _bytes_
+			   of the converted value, says POSIX.  */
+			w = count;
+# endif
+			if (w < width)
+			  {
+			    size_t pad = width - w;
+# if USE_SNPRINTF
+			    /* Make room for the result.  */
+			    if (xsum (count, pad) > allocated - length)
+			      {
+				/* Need at least count + pad elements.  But
+				   allocate proportionally.  */
+				size_t n =
+				  xmax (xsum3 (length, count, pad),
+					xtimes (allocated, 2));
+
+				length += count;
+				ENSURE_ALLOCATION (n);
+				length -= count;
+			      }
+			    /* Here count + pad <= allocated - length.  */
+# endif
+			    {
+# if !DCHAR_IS_TCHAR || USE_SNPRINTF
+			      DCHAR_T * const rp = result + length;
+# else
+			      DCHAR_T * const rp = tmp;
+# endif
+			      DCHAR_T *p = rp + count;
+			      DCHAR_T *end = p + pad;
+# if NEED_PRINTF_FLAG_ZERO
+			      DCHAR_T *pad_ptr;
+#  if !DCHAR_IS_TCHAR
+			      if (dp->conversion == 'c'
+				  || dp->conversion == 's')
+				/* No zero-padding for string directives.  */
+				pad_ptr = NULL;
+			      else
+#  endif
+				{
+				  pad_ptr = (*rp == '-' ? rp + 1 : rp);
+				  /* No zero-padding of "inf" and "nan".  */
+				  if ((*pad_ptr >= 'A' && *pad_ptr <= 'Z')
+				      || (*pad_ptr >= 'a' && *pad_ptr <= 'z'))
+				    pad_ptr = NULL;
+				}
+# endif
+			      /* The generated string now extends from rp to p,
+				 with the zero padding insertion point being at
+				 pad_ptr.  */
+
+			      count = count + pad; /* = end - rp */
+
+			      if (flags & FLAG_LEFT)
+				{
+				  /* Pad with spaces on the right.  */
+				  for (; pad > 0; pad--)
+				    *p++ = ' ';
+				}
+# if NEED_PRINTF_FLAG_ZERO
+			      else if ((flags & FLAG_ZERO) && pad_ptr != NULL)
+				{
+				  /* Pad with zeroes.  */
+				  DCHAR_T *q = end;
+
+				  while (p > pad_ptr)
+				    *--q = *--p;
+				  for (; pad > 0; pad--)
+				    *p++ = '0';
+				}
+# endif
+			      else
+				{
+				  /* Pad with spaces on the left.  */
+				  DCHAR_T *q = end;
+
+				  while (p > rp)
+				    *--q = *--p;
+				  for (; pad > 0; pad--)
+				    *p++ = ' ';
+				}
+			    }
+			  }
+		      }
+#endif
+
+#if DCHAR_IS_TCHAR && !USE_SNPRINTF
+		    if (count >= tmp_length)
+		      /* tmp_length was incorrectly calculated - fix the
+			 code above!  */
+		      abort ();
+#endif
+
+		    /* Here still count <= allocated - length.  */
+
+#if !DCHAR_IS_TCHAR || USE_SNPRINTF
+		    /* The snprintf() result did fit.  */
+#else
+		    /* Append the sprintf() result.  */
+		    memcpy (result + length, tmp, count * sizeof (DCHAR_T));
+#endif
+#if !USE_SNPRINTF
+		    if (tmp != tmpbuf)
+		      free (tmp);
+#endif
+
+#if NEED_PRINTF_DIRECTIVE_F
+		    if (dp->conversion == 'F')
+		      {
+			/* Convert the %f result to upper case for %F.  */
+			DCHAR_T *rp = result + length;
+			size_t rc;
+			for (rc = count; rc > 0; rc--, rp++)
+			  if (*rp >= 'a' && *rp <= 'z')
+			    *rp = *rp - 'a' + 'A';
+		      }
+#endif
+
+		    length += count;
+		    break;
+		  }
+	      }
+	  }
+      }
+
+    /* Add the final NUL.  */
+    ENSURE_ALLOCATION (xsum (length, 1));
+    result[length] = '\0';
+
+    if (result != resultbuf && length + 1 < allocated)
+      {
+	/* Shrink the allocated memory if possible.  */
+	DCHAR_T *memory;
+
+	memory = (DCHAR_T *) realloc (result, (length + 1) * sizeof (DCHAR_T));
+	if (memory != NULL)
+	  result = memory;
+      }
+
+    if (buf_malloced != NULL)
+      free (buf_malloced);
+    CLEANUP ();
+    *lengthp = length;
+    /* Note that we can produce a big string of a length > INT_MAX.  POSIX
+       says that snprintf() fails with errno = EOVERFLOW in this case, but
+       that's only because snprintf() returns an 'int'.  This function does
+       not have this limitation.  */
+    return result;
+
+  overflow:
+    if (!(result == resultbuf || result == NULL))
+      free (result);
+    if (buf_malloced != NULL)
+      free (buf_malloced);
+    CLEANUP ();
+    errno = EOVERFLOW;
+    return NULL;
+
+  out_of_memory:
+    if (!(result == resultbuf || result == NULL))
+      free (result);
+    if (buf_malloced != NULL)
+      free (buf_malloced);
+  out_of_memory_1:
+    CLEANUP ();
+    errno = ENOMEM;
+    return NULL;
+  }
+}
+
+#undef TCHARS_PER_DCHAR
+#undef SNPRINTF
+#undef USE_SNPRINTF
+#undef PRINTF_PARSE
+#undef DIRECTIVES
+#undef DIRECTIVE
+#undef TCHAR_T
+#undef DCHAR_T
+#undef FCHAR_T
+#undef VASNPRINTF
Index: lib/vasnprintf.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/vasnprintf.h	2007-11-07 16:30:53.592323513 +0000
@@ -0,0 +1,81 @@
+/* vsprintf with automatic memory allocation.
+   Copyright (C) 2002-2004, 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _VASNPRINTF_H
+#define _VASNPRINTF_H
+
+/* Get va_list.  */
+#include <stdarg.h>
+
+/* Get size_t.  */
+#include <stddef.h>
+
+#ifndef __attribute__
+/* This feature is available in gcc versions 2.5 and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 5) || __STRICT_ANSI__
+#  define __attribute__(Spec) /* empty */
+# endif
+/* The __-protected variants of `format' and `printf' attributes
+   are accepted by gcc versions 2.6.4 (effectively 2.7) and later.  */
+# if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+#  define __format__ format
+#  define __printf__ printf
+# endif
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+/* Write formatted output to a string dynamically allocated with malloc().
+   You can pass a preallocated buffer for the result in RESULTBUF and its
+   size in *LENGTHP; otherwise you pass RESULTBUF = NULL.
+   If successful, return the address of the string (this may be = RESULTBUF
+   if no dynamic memory allocation was necessary) and set *LENGTHP to the
+   number of resulting bytes, excluding the trailing NUL.  Upon error, set
+   errno and return NULL.
+
+   When dynamic memory allocation occurs, the preallocated buffer is left
+   alone (with possibly modified contents).  This makes it possible to use
+   a statically allocated or stack-allocated buffer, like this:
+
+          char buf[100];
+          size_t len = sizeof (buf);
+          char *output = vasnprintf (buf, &len, format, args);
+          if (output == NULL)
+            ... error handling ...;
+          else
+            {
+              ... use the output string ...;
+              if (output != buf)
+                free (output);
+            }
+  */
+#if REPLACE_VASNPRINTF
+# define asnprintf rpl_asnprintf
+# define vasnprintf rpl_vasnprintf
+#endif
+extern char * asnprintf (char *resultbuf, size_t *lengthp, const char *format, ...)
+       __attribute__ ((__format__ (__printf__, 3, 4)));
+extern char * vasnprintf (char *resultbuf, size_t *lengthp, const char *format, va_list args)
+       __attribute__ ((__format__ (__printf__, 3, 0)));
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _VASNPRINTF_H */
Index: lib/vsnprintf.c
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/vsnprintf.c	2007-11-07 16:30:53.600889175 +0000
@@ -0,0 +1,76 @@
+/* Formatted output to strings.
+   Copyright (C) 2004, 2006-2007 Free Software Foundation, Inc.
+   Written by Simon Josefsson and Yoann Vandoorselaere <yoann@prelude-ids.org>.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License along
+   with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifdef HAVE_CONFIG_H
+# include <config.h>
+#endif
+
+/* Specification.  */
+#include <stdio.h>
+
+#include <errno.h>
+#include <limits.h>
+#include <stdarg.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include "vasnprintf.h"
+
+/* Some systems, like OSF/1 4.0 and Woe32, don't have EOVERFLOW.  */
+#ifndef EOVERFLOW
+# define EOVERFLOW E2BIG
+#endif
+
+/* Print formatted output to string STR.  Similar to vsprintf, but
+   additional length SIZE limit how much is written into STR.  Returns
+   string length of formatted string (which may be larger than SIZE).
+   STR may be NULL, in which case nothing will be written.  On error,
+   return a negative value.  */
+int
+vsnprintf (char *str, size_t size, const char *format, va_list args)
+{
+  char *output;
+  size_t len;
+  size_t lenbuf = size;
+
+  output = vasnprintf (str, &lenbuf, format, args);
+  len = lenbuf;
+
+  if (!output)
+    return -1;
+
+  if (output != str)
+    {
+      if (size)
+	{
+	  size_t pruned_len = (len < size ? len : size - 1);
+	  memcpy (str, output, pruned_len);
+	  str[pruned_len] = '\0';
+	}
+
+      free (output);
+    }
+
+  if (len > INT_MAX)
+    {
+      errno = EOVERFLOW;
+      return -1;
+    }
+
+  return len;
+}
Index: lib/wchar.in.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/wchar.in.h	2007-11-07 16:30:53.623060675 +0000
@@ -0,0 +1,82 @@
+/* A substitute for ISO C99 <wchar.h>, for platforms that have issues.
+
+   Copyright (C) 2007 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+/* Written by Eric Blake.  */
+
+/*
+ * ISO C 99 <wchar.h> for platforms that have issues.
+ * <http://www.opengroup.org/susv3xbd/wchar.h.html>
+ *
+ * For now, this just ensures proper prerequisite inclusion order and
+ * the declaration of wcwidth().
+ */
+
+#ifndef _GL_WCHAR_H
+
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+   included before <wchar.h>.  */
+#include <stddef.h>
+#include <stdio.h>
+#include <time.h>
+
+/* Include the original <wchar.h> if it exists.
+   Some builds of uClibc lack it.  */
+/* The include_next requires a split double-inclusion guard.  */
+#if @HAVE_WCHAR_H@
+# @INCLUDE_NEXT@ @NEXT_WCHAR_H@
+#endif
+
+#ifndef _GL_WCHAR_H
+#define _GL_WCHAR_H
+
+/* The definition of GL_LINK_WARNING is copied here.  */
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+
+/* Return the number of screen columns needed for WC.  */
+#if @GNULIB_WCWIDTH@
+# if @REPLACE_WCWIDTH@
+#  undef wcwidth
+#  define wcwidth rpl_wcwidth
+extern int wcwidth (wchar_t);
+# else
+#  if !defined wcwidth && !@HAVE_DECL_WCWIDTH@
+/* wcwidth exists but is not declared.  */
+extern int wcwidth (int /* actually wchar_t */);
+#  endif
+# endif
+#elif defined GNULIB_POSIXCHECK
+# undef wcwidth
+# define wcwidth(w) \
+    (GL_LINK_WARNING ("wcwidth is unportable - " \
+                      "use gnulib module wcwidth for portability"), \
+     wcwidth (w))
+#endif
+
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif /* _GL_WCHAR_H */
+#endif /* _GL_WCHAR_H */
Index: lib/xsize.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ lib/xsize.h	2007-11-07 16:30:53.641659517 +0000
@@ -0,0 +1,108 @@
+/* xsize.h -- Checked size_t computations.
+
+   Copyright (C) 2003 Free Software Foundation, Inc.
+
+   This program is free software; you can redistribute it and/or modify
+   it under the terms of the GNU Lesser General Public License as published by
+   the Free Software Foundation; either version 2.1, or (at your option)
+   any later version.
+
+   This program is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+   GNU Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public License
+   along with this program; if not, write to the Free Software Foundation,
+   Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301, USA.  */
+
+#ifndef _XSIZE_H
+#define _XSIZE_H
+
+/* Get size_t.  */
+#include <stddef.h>
+
+/* Get SIZE_MAX.  */
+#include <limits.h>
+#if HAVE_STDINT_H
+# include <stdint.h>
+#endif
+
+/* The size of memory objects is often computed through expressions of
+   type size_t. Example:
+      void* p = malloc (header_size + n * element_size).
+   These computations can lead to overflow.  When this happens, malloc()
+   returns a piece of memory that is way too small, and the program then
+   crashes while attempting to fill the memory.
+   To avoid this, the functions and macros in this file check for overflow.
+   The convention is that SIZE_MAX represents overflow.
+   malloc (SIZE_MAX) is not guaranteed to fail -- think of a malloc
+   implementation that uses mmap --, it's recommended to use size_overflow_p()
+   or size_in_bounds_p() before invoking malloc().
+   The example thus becomes:
+      size_t size = xsum (header_size, xtimes (n, element_size));
+      void *p = (size_in_bounds_p (size) ? malloc (size) : NULL);
+*/
+
+/* Convert an arbitrary value >= 0 to type size_t.  */
+#define xcast_size_t(N) \
+  ((N) <= SIZE_MAX ? (size_t) (N) : SIZE_MAX)
+
+/* Sum of two sizes, with overflow check.  */
+static inline size_t
+#if __GNUC__ >= 3
+__attribute__ ((__pure__))
+#endif
+xsum (size_t size1, size_t size2)
+{
+  size_t sum = size1 + size2;
+  return (sum >= size1 ? sum : SIZE_MAX);
+}
+
+/* Sum of three sizes, with overflow check.  */
+static inline size_t
+#if __GNUC__ >= 3
+__attribute__ ((__pure__))
+#endif
+xsum3 (size_t size1, size_t size2, size_t size3)
+{
+  return xsum (xsum (size1, size2), size3);
+}
+
+/* Sum of four sizes, with overflow check.  */
+static inline size_t
+#if __GNUC__ >= 3
+__attribute__ ((__pure__))
+#endif
+xsum4 (size_t size1, size_t size2, size_t size3, size_t size4)
+{
+  return xsum (xsum (xsum (size1, size2), size3), size4);
+}
+
+/* Maximum of two sizes, with overflow check.  */
+static inline size_t
+#if __GNUC__ >= 3
+__attribute__ ((__pure__))
+#endif
+xmax (size_t size1, size_t size2)
+{
+  /* No explicit check is needed here, because for any n:
+     max (SIZE_MAX, n) == SIZE_MAX and max (n, SIZE_MAX) == SIZE_MAX.  */
+  return (size1 >= size2 ? size1 : size2);
+}
+
+/* Multiplication of a count with an element size, with overflow check.
+   The count must be >= 0 and the element size must be > 0.
+   This is a macro, not an inline function, so that it works correctly even
+   when N is of a wider tupe and N > SIZE_MAX.  */
+#define xtimes(N, ELSIZE) \
+  ((N) <= SIZE_MAX / (ELSIZE) ? (size_t) (N) * (ELSIZE) : SIZE_MAX)
+
+/* Check for overflow.  */
+#define size_overflow_p(SIZE) \
+  ((SIZE) == SIZE_MAX)
+/* Check against overflow.  */
+#define size_in_bounds_p(SIZE) \
+  ((SIZE) != SIZE_MAX)
+
+#endif /* _XSIZE_H */
Index: link-warning.h
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ link-warning.h	2007-11-07 16:30:53.655909329 +0000
@@ -0,0 +1,28 @@
+/* GL_LINK_WARNING("literal string") arranges to emit the literal string as
+   a linker warning on most glibc systems.
+   We use a linker warning rather than a preprocessor warning, because
+   #warning cannot be used inside macros.  */
+#ifndef GL_LINK_WARNING
+  /* This works on platforms with GNU ld and ELF object format.
+     Testing __GLIBC__ is sufficient for asserting that GNU ld is in use.
+     Testing __ELF__ guarantees the ELF object format.
+     Testing __GNUC__ is necessary for the compound expression syntax.  */
+# if defined __GLIBC__ && defined __ELF__ && defined __GNUC__
+#  define GL_LINK_WARNING(message) \
+     GL_LINK_WARNING1 (__FILE__, __LINE__, message)
+#  define GL_LINK_WARNING1(file, line, message) \
+     GL_LINK_WARNING2 (file, line, message)  /* macroexpand file and line */
+#  define GL_LINK_WARNING2(file, line, message) \
+     GL_LINK_WARNING3 (file ":" #line ": warning: " message)
+#  define GL_LINK_WARNING3(message) \
+     ({ static const char warning[sizeof (message)]		\
+          __attribute__ ((__unused__,				\
+                          __section__ (".gnu.warning"),		\
+                          __aligned__ (1)))			\
+          = message "\n";					\
+        (void)0;						\
+     })
+# else
+#  define GL_LINK_WARNING(message) ((void) 0)
+# endif
+#endif
Index: m4/alloca.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/alloca.m4	2007-11-07 16:30:53.676534852 +0000
@@ -0,0 +1,50 @@
+# alloca.m4 serial 7
+dnl Copyright (C) 2002-2004, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_ALLOCA],
+[
+  dnl Work around a bug of AC_EGREP_CPP in autoconf-2.57.
+  AC_REQUIRE([AC_PROG_CPP])
+  AC_REQUIRE([AC_PROG_EGREP])
+
+  AC_REQUIRE([AC_FUNC_ALLOCA])
+  if test $ac_cv_func_alloca_works = no; then
+    gl_PREREQ_ALLOCA
+  fi
+
+  # Define an additional variable used in the Makefile substitution.
+  if test $ac_cv_working_alloca_h = yes; then
+    AC_CACHE_CHECK([for alloca as a compiler built-in], [gl_cv_rpl_alloca], [
+      AC_EGREP_CPP([Need own alloca], [
+#if defined __GNUC__ || defined _AIX || defined _MSC_VER
+        Need own alloca
+#endif
+        ], [gl_cv_rpl_alloca=yes], [gl_cv_rpl_alloca=no])
+    ])
+    if test $gl_cv_rpl_alloca = yes; then
+      dnl OK, alloca can be implemented through a compiler built-in.
+      AC_DEFINE([HAVE_ALLOCA], 1,
+        [Define to 1 if you have 'alloca' after including <alloca.h>,
+         a header that may be supplied by this distribution.])
+      ALLOCA_H=alloca.h
+    else
+      dnl alloca exists as a library function, i.e. it is slow and probably
+      dnl a memory leak. Don't define HAVE_ALLOCA in this case.
+      ALLOCA_H=
+    fi
+  else
+    ALLOCA_H=alloca.h
+  fi
+  AC_SUBST([ALLOCA_H])
+
+  AC_DEFINE(HAVE_ALLOCA_H, 1,
+    [Define HAVE_ALLOCA_H for backward compatibility with older code
+     that includes <alloca.h> only if HAVE_ALLOCA_H is defined.])
+])
+
+# Prerequisites of lib/alloca.c.
+# STACK_DIRECTION is already handled by AC_FUNC_ALLOCA.
+AC_DEFUN([gl_PREREQ_ALLOCA], [:])
Index: m4/eoverflow.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/eoverflow.m4	2007-11-07 16:30:53.684463597 +0000
@@ -0,0 +1,70 @@
+# eoverflow.m4 serial 2
+dnl Copyright (C) 2004, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+# The EOVERFLOW errno value ought to be defined in <errno.h>, according to
+# POSIX.  But some systems (like AIX 3) don't define it, and some systems
+# (like OSF/1) define it when _XOPEN_SOURCE_EXTENDED is defined.
+
+# Define EOVERFLOW as a C macro and as a substituted macro in such a way that
+# 1. on all systems, after inclusion of <errno.h>, EOVERFLOW is usable,
+# 2. on systems where EOVERFLOW is defined elsewhere, we use the same numeric
+#    value.
+
+AC_DEFUN([gl_EOVERFLOW],
+[
+  AC_REQUIRE([AC_PROG_CC])dnl
+
+  AC_CACHE_CHECK([for EOVERFLOW], ac_cv_decl_EOVERFLOW, [
+    AC_EGREP_CPP(yes,[
+#include <errno.h>
+#ifdef EOVERFLOW
+yes
+#endif
+      ], have_eoverflow=1)
+    if test -n "$have_eoverflow"; then
+      dnl EOVERFLOW exists in <errno.h>. Don't need to define EOVERFLOW ourselves.
+      ac_cv_decl_EOVERFLOW=yes
+    else
+      AC_EGREP_CPP(yes,[
+#define _XOPEN_SOURCE_EXTENDED 1
+#include <errno.h>
+#ifdef EOVERFLOW
+yes
+#endif
+        ], have_eoverflow=1)
+      if test -n "$have_eoverflow"; then
+        dnl EOVERFLOW exists but is hidden.
+        dnl Define it to the same value.
+        AC_COMPUTE_INT([ac_cv_decl_EOVERFLOW], [EOVERFLOW], [
+#define _XOPEN_SOURCE_EXTENDED 1
+#include <errno.h>
+/* The following two lines are a workaround against an autoconf-2.52 bug.  */
+#include <stdio.h>
+#include <stdlib.h>
+])
+      else
+        dnl EOVERFLOW isn't defined by the system. Define EOVERFLOW ourselves, but
+        dnl don't define it as EINVAL, because snprintf() callers want to
+        dnl distinguish EINVAL and EOVERFLOW.
+        ac_cv_decl_EOVERFLOW=E2BIG
+      fi
+    fi
+  ])
+  if test "$ac_cv_decl_EOVERFLOW" != yes; then
+    AC_DEFINE_UNQUOTED([EOVERFLOW], [$ac_cv_decl_EOVERFLOW],
+                       [Define as good substitute value for EOVERFLOW.])
+    EOVERFLOW="$ac_cv_decl_EOVERFLOW"
+    AC_SUBST(EOVERFLOW)
+  fi
+])
+
+dnl Autoconf >= 2.61 has AC_COMPUTE_INT built-in.
+dnl Remove this when we can assume autoconf >= 2.61.
+m4_ifdef([AC_COMPUTE_INT], [], [
+  AC_DEFUN([AC_COMPUTE_INT], [_AC_COMPUTE_INT([$2],[$1],[$3],[$4])])
+])
Index: m4/float_h.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/float_h.m4	2007-11-07 16:30:53.691524332 +0000
@@ -0,0 +1,19 @@
+# float_h.m4 serial 2
+dnl Copyright (C) 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FLOAT_H],
+[
+  AC_REQUIRE([AC_PROG_CC])
+  AC_REQUIRE([AC_CANONICAL_HOST])
+  FLOAT_H=
+  case "$host_os" in
+    beos*)
+      FLOAT_H=float.h
+      gl_CHECK_NEXT_HEADERS([float.h])
+      ;;
+  esac
+  AC_SUBST([FLOAT_H])
+])
Index: m4/gnulib-cache.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/gnulib-cache.m4	2007-11-07 16:30:53.698207296 +0000
@@ -0,0 +1,34 @@
+# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+#
+# This file is free software, distributed under the terms of the GNU
+# General Public License.  As a special exception to the GNU General
+# Public License, this file may be distributed as part of a program
+# that contains a configuration script generated by Autoconf, under
+# the same distribution terms as the rest of that program.
+#
+# Generated by gnulib-tool.
+#
+# This file represents the specification of how gnulib-tool is used.
+# It acts as a cache: It is written and read by gnulib-tool.
+# In projects using CVS, this file is meant to be stored in CVS,
+# like the configure.ac and various Makefile.am files.
+
+
+# Specification in the form of a command-line invocation:
+#   gnulib-tool --import --dir=. --lib=libgnu --source-base=lib --m4-base=m4 --doc-base=doc --aux-dir=. --lgpl=2 --libtool --macro-prefix=gl snprintf vsnprintf
+
+# Specification in the form of a few gnulib-tool.m4 macro invocations:
+gl_LOCAL_DIR([])
+gl_MODULES([snprintf vsnprintf])
+gl_AVOID([])
+gl_SOURCE_BASE([lib])
+gl_M4_BASE([m4])
+gl_PO_BASE([])
+gl_DOC_BASE([doc])
+gl_TESTS_BASE([tests])
+gl_LIB([libgnu])
+gl_LGPL([2])
+gl_MAKEFILE_NAME([])
+gl_LIBTOOL
+gl_MACRO_PREFIX([gl])
+gl_PO_DOMAIN([])
Index: m4/gnulib-common.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/gnulib-common.m4	2007-11-07 16:30:53.704567439 +0000
@@ -0,0 +1,65 @@
+# gnulib-common.m4 serial 3
+dnl Copyright (C) 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+# gl_MODULE_INDICATOR([modulename])
+# defines a C macro indicating the presence of the given module.
+AC_DEFUN([gl_MODULE_INDICATOR],
+[
+  AC_DEFINE([GNULIB_]translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___]), [1],
+    [Define to 1 when using the gnulib module ]$1[.])
+])
+
+# AC_PROG_MKDIR_P
+# is a backport of autoconf-2.60's AC_PROG_MKDIR_P.
+# Remove this macro when we can assume autoconf >= 2.60.
+m4_ifdef([AC_PROG_MKDIR_P], [], [
+  AC_DEFUN([AC_PROG_MKDIR_P],
+    [AC_REQUIRE([AM_PROG_MKDIR_P])dnl defined by automake
+     MKDIR_P='$(mkdir_p)'
+     AC_SUBST([MKDIR_P])])])
+
+# AC_C_RESTRICT
+# This definition overrides the AC_C_RESTRICT macro from autoconf 2.60..2.61,
+# so that mixed use of GNU C and GNU C++ and mixed use of Sun C and Sun C++
+# works.
+# This definition can be removed once autoconf >= 2.62 can be assumed.
+AC_DEFUN([AC_C_RESTRICT],
+[AC_CACHE_CHECK([for C/C++ restrict keyword], ac_cv_c_restrict,
+  [ac_cv_c_restrict=no
+   # The order here caters to the fact that C++ does not require restrict.
+   for ac_kw in __restrict __restrict__ _Restrict restrict; do
+     AC_COMPILE_IFELSE([AC_LANG_PROGRAM(
+      [[typedef int * int_ptr;
+	int foo (int_ptr $ac_kw ip) {
+	return ip[0];
+       }]],
+      [[int s[1];
+	int * $ac_kw t = s;
+	t[0] = 0;
+	return foo(t)]])],
+      [ac_cv_c_restrict=$ac_kw])
+     test "$ac_cv_c_restrict" != no && break
+   done
+  ])
+ AH_VERBATIM([restrict],
+[/* Define to the equivalent of the C99 'restrict' keyword, or to
+   nothing if this is not supported.  Do not define if restrict is
+   supported directly.  */
+#undef restrict
+/* Work around a bug in Sun C++: it does not support _Restrict, even
+   though the corresponding Sun C compiler does, which causes
+   "#define restrict _Restrict" in the previous line.  Perhaps some future
+   version of Sun C++ will work with _Restrict; if so, it'll probably
+   define __RESTRICT, just as Sun C does.  */
+#if defined __SUNPRO_CC && !defined __RESTRICT
+# define _Restrict
+#endif])
+ case $ac_cv_c_restrict in
+   restrict) ;;
+   no) AC_DEFINE([restrict], []) ;;
+   *)  AC_DEFINE_UNQUOTED([restrict], [$ac_cv_c_restrict]) ;;
+ esac
+])
Index: m4/gnulib-tool.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/gnulib-tool.m4	2007-11-07 16:30:53.711604256 +0000
@@ -0,0 +1,33 @@
+# gnulib-tool.m4 serial 1
+dnl Copyright (C) 2004-2005 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl The following macros need not be invoked explicitly.
+dnl Invoking them does nothing except to declare default arguments
+dnl for "gnulib-tool --import".
+
+dnl Usage: gl_MODULES([module1 module2 ...])
+AC_DEFUN([gl_MODULES], [])
+
+dnl Usage: gl_AVOID([module1 module2 ...])
+AC_DEFUN([gl_AVOID], [])
+
+dnl Usage: gl_SOURCE_BASE([DIR])
+AC_DEFUN([gl_SOURCE_BASE], [])
+
+dnl Usage: gl_M4_BASE([DIR])
+AC_DEFUN([gl_M4_BASE], [])
+
+dnl Usage: gl_LIB([LIBNAME])
+AC_DEFUN([gl_LIB], [])
+
+dnl Usage: gl_LGPL
+AC_DEFUN([gl_LGPL], [])
+
+dnl Usage: gl_LIBTOOL
+AC_DEFUN([gl_LIBTOOL], [])
+
+dnl Usage: gl_MACRO_PREFIX([PREFIX])
+AC_DEFUN([gl_MACRO_PREFIX], [])
Index: m4/include_next.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/include_next.m4	2007-11-07 16:30:53.718083342 +0000
@@ -0,0 +1,107 @@
+# include_next.m4 serial 4
+dnl Copyright (C) 2006, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert and Derek Price.
+
+AC_DEFUN([gl_INCLUDE_NEXT],
+[
+  AC_LANG_PREPROC_REQUIRE()
+  AC_CACHE_CHECK([whether the preprocessor supports include_next],
+    [gl_cv_have_include_next],
+    [rm -rf conftestd1 conftestd2
+     mkdir conftestd1 conftestd2
+     cat <<EOF > conftestd1/conftest.h
+#define DEFINED_IN_CONFTESTD1
+#include_next <conftest.h>
+#ifdef DEFINED_IN_CONFTESTD2
+int foo;
+#else
+#error "include_next doesn't work"
+#endif
+EOF
+     cat <<EOF > conftestd2/conftest.h
+#ifndef DEFINED_IN_CONFTESTD1
+#error "include_next test doesn't work"
+#endif
+#define DEFINED_IN_CONFTESTD2
+EOF
+     save_CPPFLAGS="$CPPFLAGS"
+     CPPFLAGS="$CPPFLAGS -Iconftestd1 -Iconftestd2"
+     AC_COMPILE_IFELSE([#include <conftest.h>],
+       [gl_cv_have_include_next=yes],
+       [gl_cv_have_include_next=no])
+     CPPFLAGS="$save_CPPFLAGS"
+     rm -rf conftestd1 conftestd2
+    ])
+  if test $gl_cv_have_include_next = yes; then
+
+    dnl FIXME: Remove HAVE_INCLUDE_NEXT and update everything that uses it
+    dnl to use @INCLUDE_NEXT@ instead.
+    AC_DEFINE([HAVE_INCLUDE_NEXT], 1,
+	      [Define if your compiler supports the #include_next directive.])
+
+    INCLUDE_NEXT=include_next
+  else
+    INCLUDE_NEXT=include
+  fi
+  AC_SUBST([INCLUDE_NEXT])
+])
+
+# gl_CHECK_NEXT_HEADERS(HEADER1 HEADER2 ...)
+# ------------------------------------------
+# For each arg foo.h, if #include_next works, define NEXT_FOO_H to be
+# '<foo.h>'; otherwise define it to be
+# '"///usr/include/foo.h"', or whatever other absolute file name is suitable.
+# That way, a header file with the following line:
+#	#@INCLUDE_NEXT@ @NEXT_FOO_H@
+# behaves (after sed substitution) as if it contained
+#	#include_next <foo.h>
+# even if the compiler does not support include_next.
+# The three "///" are to pacify Sun C 5.8, which otherwise would say
+# "warning: #include of /usr/include/... may be non-portable".
+# Use `""', not `<>', so that the /// cannot be confused with a C99 comment.
+AC_DEFUN([gl_CHECK_NEXT_HEADERS],
+[
+  AC_REQUIRE([gl_INCLUDE_NEXT])
+  AC_CHECK_HEADERS_ONCE([$1])
+
+  AC_FOREACH([gl_HEADER_NAME], [$1],
+    [AS_VAR_PUSHDEF([gl_next_header],
+		    [gl_cv_next_]m4_quote(m4_defn([gl_HEADER_NAME])))
+     if test $gl_cv_have_include_next = yes; then
+       AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
+     else
+       AC_CACHE_CHECK(
+	 [absolute name of <]m4_quote(m4_defn([gl_HEADER_NAME]))[>],
+	 m4_quote(m4_defn([gl_next_header])),
+	 [AS_VAR_PUSHDEF([gl_header_exists],
+			 [ac_cv_header_]m4_quote(m4_defn([gl_HEADER_NAME])))
+	  if test AS_VAR_GET(gl_header_exists) = yes; then
+	    AC_LANG_CONFTEST(
+	      [AC_LANG_SOURCE(
+		 [[#include <]]m4_dquote(m4_defn([gl_HEADER_NAME]))[[>]]
+	       )])
+	    dnl eval is necessary to expand ac_cpp.
+	    dnl Ultrix and Pyramid sh refuse to redirect output of eval,
+	    dnl so use subshell.
+	    AS_VAR_SET([gl_next_header],
+	      ['"'`(eval "$ac_cpp conftest.$ac_ext") 2>&AS_MESSAGE_LOG_FD |
+	       sed -n '\#/]m4_quote(m4_defn([gl_HEADER_NAME]))[#{
+		 s#.*"\(.*/]m4_quote(m4_defn([gl_HEADER_NAME]))[\)".*#\1#
+		 s#^/[^/]#//&#
+		 p
+		 q
+	       }'`'"'])
+	  else
+	    AS_VAR_SET([gl_next_header], ['<'gl_HEADER_NAME'>'])
+	  fi
+	  AS_VAR_POPDEF([gl_header_exists])])
+     fi
+     AC_SUBST(
+       AS_TR_CPP([NEXT_]m4_quote(m4_defn([gl_HEADER_NAME]))),
+       [AS_VAR_GET([gl_next_header])])
+     AS_VAR_POPDEF([gl_next_header])])
+])
Index: m4/intmax_t.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/intmax_t.m4	2007-11-07 16:30:53.724951252 +0000
@@ -0,0 +1,61 @@
+# intmax_t.m4 serial 6
+dnl Copyright (C) 1997-2004, 2006-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert.
+
+AC_PREREQ(2.13)
+
+# Define intmax_t to 'long' or 'long long'
+# if it is not already defined in <stdint.h> or <inttypes.h>.
+
+AC_DEFUN([gl_AC_TYPE_INTMAX_T],
+[
+  dnl For simplicity, we assume that a header file defines 'intmax_t' if and
+  dnl only if it defines 'uintmax_t'.
+  AC_REQUIRE([gl_AC_HEADER_INTTYPES_H])
+  AC_REQUIRE([gl_AC_HEADER_STDINT_H])
+  if test $gl_cv_header_inttypes_h = no && test $gl_cv_header_stdint_h = no; then
+    AC_REQUIRE([AC_TYPE_LONG_LONG_INT])
+    test $ac_cv_type_long_long_int = yes \
+      && ac_type='long long' \
+      || ac_type='long'
+    AC_DEFINE_UNQUOTED(intmax_t, $ac_type,
+     [Define to long or long long if <inttypes.h> and <stdint.h> don't define.])
+  else
+    AC_DEFINE(HAVE_INTMAX_T, 1,
+      [Define if you have the 'intmax_t' type in <stdint.h> or <inttypes.h>.])
+  fi
+])
+
+dnl An alternative would be to explicitly test for 'intmax_t'.
+
+AC_DEFUN([gt_AC_TYPE_INTMAX_T],
+[
+  AC_REQUIRE([gl_AC_HEADER_INTTYPES_H])
+  AC_REQUIRE([gl_AC_HEADER_STDINT_H])
+  AC_CACHE_CHECK(for intmax_t, gt_cv_c_intmax_t,
+    [AC_TRY_COMPILE([
+#include <stddef.h>
+#include <stdlib.h>
+#if HAVE_STDINT_H_WITH_UINTMAX
+#include <stdint.h>
+#endif
+#if HAVE_INTTYPES_H_WITH_UINTMAX
+#include <inttypes.h>
+#endif
+], [intmax_t x = -1; return !x;], gt_cv_c_intmax_t=yes, gt_cv_c_intmax_t=no)])
+  if test $gt_cv_c_intmax_t = yes; then
+    AC_DEFINE(HAVE_INTMAX_T, 1,
+      [Define if you have the 'intmax_t' type in <stdint.h> or <inttypes.h>.])
+  else
+    AC_REQUIRE([AC_TYPE_LONG_LONG_INT])
+    test $ac_cv_type_long_long_int = yes \
+      && ac_type='long long' \
+      || ac_type='long'
+    AC_DEFINE_UNQUOTED(intmax_t, $ac_type,
+     [Define to long or long long if <stdint.h> and <inttypes.h> don't define.])
+  fi
+])
Index: m4/inttypes_h.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/inttypes_h.m4	2007-11-07 16:30:53.731557750 +0000
@@ -0,0 +1,26 @@
+# inttypes_h.m4 serial 7
+dnl Copyright (C) 1997-2004, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert.
+
+# Define HAVE_INTTYPES_H_WITH_UINTMAX if <inttypes.h> exists,
+# doesn't clash with <sys/types.h>, and declares uintmax_t.
+
+AC_DEFUN([gl_AC_HEADER_INTTYPES_H],
+[
+  AC_CACHE_CHECK([for inttypes.h], gl_cv_header_inttypes_h,
+  [AC_TRY_COMPILE(
+    [#include <sys/types.h>
+#include <inttypes.h>],
+    [uintmax_t i = (uintmax_t) -1; return !i;],
+    gl_cv_header_inttypes_h=yes,
+    gl_cv_header_inttypes_h=no)])
+  if test $gl_cv_header_inttypes_h = yes; then
+    AC_DEFINE_UNQUOTED(HAVE_INTTYPES_H_WITH_UINTMAX, 1,
+      [Define if <inttypes.h> exists, doesn't clash with <sys/types.h>,
+       and declares uintmax_t. ])
+  fi
+])
Index: m4/longlong.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/longlong.m4	2007-11-07 16:30:53.795819254 +0000
@@ -0,0 +1,109 @@
+# longlong.m4 serial 13
+dnl Copyright (C) 1999-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert.
+
+# Define HAVE_LONG_LONG_INT if 'long long int' works.
+# This fixes a bug in Autoconf 2.61, but can be removed once we
+# assume 2.62 everywhere.
+
+# Note: If the type 'long long int' exists but is only 32 bits large
+# (as on some very old compilers), HAVE_LONG_LONG_INT will not be
+# defined. In this case you can treat 'long long int' like 'long int'.
+
+AC_DEFUN([AC_TYPE_LONG_LONG_INT],
+[
+  AC_CACHE_CHECK([for long long int], [ac_cv_type_long_long_int],
+    [AC_LINK_IFELSE(
+       [_AC_TYPE_LONG_LONG_SNIPPET],
+       [dnl This catches a bug in Tandem NonStop Kernel (OSS) cc -O circa 2004.
+	dnl If cross compiling, assume the bug isn't important, since
+	dnl nobody cross compiles for this platform as far as we know.
+	AC_RUN_IFELSE(
+	  [AC_LANG_PROGRAM(
+	     [[@%:@include <limits.h>
+	       @%:@ifndef LLONG_MAX
+	       @%:@ define HALF \
+			(1LL << (sizeof (long long int) * CHAR_BIT - 2))
+	       @%:@ define LLONG_MAX (HALF - 1 + HALF)
+	       @%:@endif]],
+	     [[long long int n = 1;
+	       int i;
+	       for (i = 0; ; i++)
+		 {
+		   long long int m = n << i;
+		   if (m >> i != n)
+		     return 1;
+		   if (LLONG_MAX / 2 < m)
+		     break;
+		 }
+	       return 0;]])],
+	  [ac_cv_type_long_long_int=yes],
+	  [ac_cv_type_long_long_int=no],
+	  [ac_cv_type_long_long_int=yes])],
+       [ac_cv_type_long_long_int=no])])
+  if test $ac_cv_type_long_long_int = yes; then
+    AC_DEFINE([HAVE_LONG_LONG_INT], 1,
+      [Define to 1 if the system has the type `long long int'.])
+  fi
+])
+
+# Define HAVE_UNSIGNED_LONG_LONG_INT if 'unsigned long long int' works.
+# This fixes a bug in Autoconf 2.61, but can be removed once we
+# assume 2.62 everywhere.
+
+# Note: If the type 'unsigned long long int' exists but is only 32 bits
+# large (as on some very old compilers), AC_TYPE_UNSIGNED_LONG_LONG_INT
+# will not be defined. In this case you can treat 'unsigned long long int'
+# like 'unsigned long int'.
+
+AC_DEFUN([AC_TYPE_UNSIGNED_LONG_LONG_INT],
+[
+  AC_CACHE_CHECK([for unsigned long long int],
+    [ac_cv_type_unsigned_long_long_int],
+    [AC_LINK_IFELSE(
+       [_AC_TYPE_LONG_LONG_SNIPPET],
+       [ac_cv_type_unsigned_long_long_int=yes],
+       [ac_cv_type_unsigned_long_long_int=no])])
+  if test $ac_cv_type_unsigned_long_long_int = yes; then
+    AC_DEFINE([HAVE_UNSIGNED_LONG_LONG_INT], 1,
+      [Define to 1 if the system has the type `unsigned long long int'.])
+  fi
+])
+
+# Expands to a C program that can be used to test for simultaneous support
+# of 'long long' and 'unsigned long long'. We don't want to say that
+# 'long long' is available if 'unsigned long long' is not, or vice versa,
+# because too many programs rely on the symmetry between signed and unsigned
+# integer types (excluding 'bool').
+AC_DEFUN([_AC_TYPE_LONG_LONG_SNIPPET],
+[
+  AC_LANG_PROGRAM(
+    [[/* Test preprocessor.  */
+      #if ! (-9223372036854775807LL < 0 && 0 < 9223372036854775807ll)
+        error in preprocessor;
+      #endif
+      #if ! (18446744073709551615ULL <= -1ull)
+        error in preprocessor;
+      #endif
+      /* Test literals.  */
+      long long int ll = 9223372036854775807ll;
+      long long int nll = -9223372036854775807LL;
+      unsigned long long int ull = 18446744073709551615ULL;
+      /* Test constant expressions.   */
+      typedef int a[((-9223372036854775807LL < 0 && 0 < 9223372036854775807ll)
+		     ? 1 : -1)];
+      typedef int b[(18446744073709551615ULL <= (unsigned long long int) -1
+		     ? 1 : -1)];
+      int i = 63;]],
+    [[/* Test availability of runtime routines for shift and division.  */
+      long long int llmax = 9223372036854775807ll;
+      unsigned long long int ullmax = 18446744073709551615ull;
+      return ((ll << 63) | (ll >> 63) | (ll < i) | (ll > i)
+	      | (llmax / ll) | (llmax % ll)
+	      | (ull << 63) | (ull >> 63) | (ull << i) | (ull >> i)
+	      | (ullmax / ull) | (ullmax % ull));]])
+])
Index: m4/onceonly_2_57.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/onceonly_2_57.m4	2007-11-07 16:30:53.804190415 +0000
@@ -0,0 +1,86 @@
+# onceonly_2_57.m4 serial 4
+dnl Copyright (C) 2002-2003, 2005-2006 Free Software Foundation, Inc.
+dnl This file is free software, distributed under the terms of the GNU
+dnl General Public License.  As a special exception to the GNU General
+dnl Public License, this file may be distributed as part of a program
+dnl that contains a configuration script generated by Autoconf, under
+dnl the same distribution terms as the rest of that program.
+
+dnl This file defines some "once only" variants of standard autoconf macros.
+dnl   AC_CHECK_HEADERS_ONCE          like  AC_CHECK_HEADERS
+dnl   AC_CHECK_FUNCS_ONCE            like  AC_CHECK_FUNCS
+dnl   AC_CHECK_DECLS_ONCE            like  AC_CHECK_DECLS
+dnl   AC_REQUIRE([AC_FUNC_STRCOLL])  like  AC_FUNC_STRCOLL
+dnl The advantage is that the check for each of the headers/functions/decls
+dnl will be put only once into the 'configure' file. It keeps the size of
+dnl the 'configure' file down, and avoids redundant output when 'configure'
+dnl is run.
+dnl The drawback is that the checks cannot be conditionalized. If you write
+dnl   if some_condition; then gl_CHECK_HEADERS(stdlib.h); fi
+dnl inside an AC_DEFUNed function, the gl_CHECK_HEADERS macro call expands to
+dnl empty, and the check will be inserted before the body of the AC_DEFUNed
+dnl function.
+
+dnl This is like onceonly.m4, except that it uses diversions to named sections
+dnl DEFAULTS and INIT_PREPARE in order to check all requested headers at once,
+dnl thus reducing the size of 'configure'. Works with autoconf-2.57. The
+dnl size reduction is ca. 9%.
+
+dnl Autoconf version 2.57 or newer is recommended.
+AC_PREREQ(2.57)
+
+# AC_CHECK_HEADERS_ONCE(HEADER1 HEADER2 ...) is a once-only variant of
+# AC_CHECK_HEADERS(HEADER1 HEADER2 ...).
+AC_DEFUN([AC_CHECK_HEADERS_ONCE], [
+  :
+  AC_FOREACH([gl_HEADER_NAME], [$1], [
+    AC_DEFUN([gl_CHECK_HEADER_]m4_quote(translit(gl_HEADER_NAME,
+                                                 [./-], [___])), [
+      m4_divert_text([INIT_PREPARE],
+        [gl_header_list="$gl_header_list gl_HEADER_NAME"])
+      gl_HEADERS_EXPANSION
+      AH_TEMPLATE(AS_TR_CPP([HAVE_]m4_defn([gl_HEADER_NAME])),
+        [Define to 1 if you have the <]m4_defn([gl_HEADER_NAME])[> header file.])
+    ])
+    AC_REQUIRE([gl_CHECK_HEADER_]m4_quote(translit(gl_HEADER_NAME,
+                                                   [./-], [___])))
+  ])
+])
+m4_define([gl_HEADERS_EXPANSION], [
+  m4_divert_text([DEFAULTS], [gl_header_list=])
+  AC_CHECK_HEADERS([$gl_header_list])
+  m4_define([gl_HEADERS_EXPANSION], [])
+])
+
+# AC_CHECK_FUNCS_ONCE(FUNC1 FUNC2 ...) is a once-only variant of
+# AC_CHECK_FUNCS(FUNC1 FUNC2 ...).
+AC_DEFUN([AC_CHECK_FUNCS_ONCE], [
+  :
+  AC_FOREACH([gl_FUNC_NAME], [$1], [
+    AC_DEFUN([gl_CHECK_FUNC_]m4_defn([gl_FUNC_NAME]), [
+      m4_divert_text([INIT_PREPARE],
+        [gl_func_list="$gl_func_list gl_FUNC_NAME"])
+      gl_FUNCS_EXPANSION
+      AH_TEMPLATE(AS_TR_CPP([HAVE_]m4_defn([gl_FUNC_NAME])),
+        [Define to 1 if you have the `]m4_defn([gl_FUNC_NAME])[' function.])
+    ])
+    AC_REQUIRE([gl_CHECK_FUNC_]m4_defn([gl_FUNC_NAME]))
+  ])
+])
+m4_define([gl_FUNCS_EXPANSION], [
+  m4_divert_text([DEFAULTS], [gl_func_list=])
+  AC_CHECK_FUNCS([$gl_func_list])
+  m4_define([gl_FUNCS_EXPANSION], [])
+])
+
+# AC_CHECK_DECLS_ONCE(DECL1 DECL2 ...) is a once-only variant of
+# AC_CHECK_DECLS(DECL1, DECL2, ...).
+AC_DEFUN([AC_CHECK_DECLS_ONCE], [
+  :
+  AC_FOREACH([gl_DECL_NAME], [$1], [
+    AC_DEFUN([gl_CHECK_DECL_]m4_defn([gl_DECL_NAME]), [
+      AC_CHECK_DECLS(m4_defn([gl_DECL_NAME]))
+    ])
+    AC_REQUIRE([gl_CHECK_DECL_]m4_defn([gl_DECL_NAME]))
+  ])
+])
Index: m4/size_max.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/size_max.m4	2007-11-07 16:30:53.811270453 +0000
@@ -0,0 +1,68 @@
+# size_max.m4 serial 6
+dnl Copyright (C) 2003, 2005-2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+
+AC_DEFUN([gl_SIZE_MAX],
+[
+  AC_CHECK_HEADERS(stdint.h)
+  dnl First test whether the system already has SIZE_MAX.
+  AC_MSG_CHECKING([for SIZE_MAX])
+  AC_CACHE_VAL([gl_cv_size_max], [
+    gl_cv_size_max=
+    AC_EGREP_CPP([Found it], [
+#include <limits.h>
+#if HAVE_STDINT_H
+#include <stdint.h>
+#endif
+#ifdef SIZE_MAX
+Found it
+#endif
+], gl_cv_size_max=yes)
+    if test -z "$gl_cv_size_max"; then
+      dnl Define it ourselves. Here we assume that the type 'size_t' is not wider
+      dnl than the type 'unsigned long'. Try hard to find a definition that can
+      dnl be used in a preprocessor #if, i.e. doesn't contain a cast.
+      AC_COMPUTE_INT([size_t_bits_minus_1], [sizeof (size_t) * CHAR_BIT - 1],
+        [#include <stddef.h>
+#include <limits.h>], size_t_bits_minus_1=)
+      AC_COMPUTE_INT([fits_in_uint], [sizeof (size_t) <= sizeof (unsigned int)],
+        [#include <stddef.h>], fits_in_uint=)
+      if test -n "$size_t_bits_minus_1" && test -n "$fits_in_uint"; then
+        if test $fits_in_uint = 1; then
+          dnl Even though SIZE_MAX fits in an unsigned int, it must be of type
+          dnl 'unsigned long' if the type 'size_t' is the same as 'unsigned long'.
+          AC_TRY_COMPILE([#include <stddef.h>
+            extern size_t foo;
+            extern unsigned long foo;
+            ], [], fits_in_uint=0)
+        fi
+        dnl We cannot use 'expr' to simplify this expression, because 'expr'
+        dnl works only with 'long' integers in the host environment, while we
+        dnl might be cross-compiling from a 32-bit platform to a 64-bit platform.
+        if test $fits_in_uint = 1; then
+          gl_cv_size_max="(((1U << $size_t_bits_minus_1) - 1) * 2 + 1)"
+        else
+          gl_cv_size_max="(((1UL << $size_t_bits_minus_1) - 1) * 2 + 1)"
+        fi
+      else
+        dnl Shouldn't happen, but who knows...
+        gl_cv_size_max='((size_t)~(size_t)0)'
+      fi
+    fi
+  ])
+  AC_MSG_RESULT([$gl_cv_size_max])
+  if test "$gl_cv_size_max" != yes; then
+    AC_DEFINE_UNQUOTED([SIZE_MAX], [$gl_cv_size_max],
+      [Define as the maximum value of type 'size_t', if the system doesn't define it.])
+  fi
+])
+
+dnl Autoconf >= 2.61 has AC_COMPUTE_INT built-in.
+dnl Remove this when we can assume autoconf >= 2.61.
+m4_ifdef([AC_COMPUTE_INT], [], [
+  AC_DEFUN([AC_COMPUTE_INT], [_AC_COMPUTE_INT([$2],[$1],[$3],[$4])])
+])
Index: m4/snprintf.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/snprintf.m4	2007-11-07 16:30:53.817744845 +0000
@@ -0,0 +1,31 @@
+# snprintf.m4 serial 4
+dnl Copyright (C) 2002, 2003, 2004, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_SNPRINTF],
+[
+  AC_REQUIRE([gl_STDIO_H_DEFAULTS])
+  AC_CHECK_FUNCS([snprintf])
+  if test $ac_cv_func_snprintf = no; then
+    gl_REPLACE_SNPRINTF
+  fi
+  AC_CHECK_DECLS_ONCE([snprintf])
+  if test $ac_cv_have_decl_snprintf = no; then
+    HAVE_DECL_SNPRINTF=0
+  fi
+])
+
+AC_DEFUN([gl_REPLACE_SNPRINTF],
+[
+  AC_REQUIRE([gl_STDIO_H_DEFAULTS])
+  AC_LIBOBJ([snprintf])
+  if test $ac_cv_func_snprintf = yes; then
+    REPLACE_SNPRINTF=1
+  fi
+  gl_PREREQ_SNPRINTF
+])
+
+# Prerequisites of lib/snprintf.c.
+AC_DEFUN([gl_PREREQ_SNPRINTF], [:])
Index: m4/stdint.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/stdint.m4	2007-11-07 16:30:53.825168704 +0000
@@ -0,0 +1,395 @@
+# stdint.m4 serial 29
+dnl Copyright (C) 2001-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert and Bruno Haible.
+dnl Test whether <stdint.h> is supported or must be substituted.
+
+AC_DEFUN([gl_STDINT_H],
+[
+  AC_PREREQ(2.59)dnl
+
+  dnl Check for long long int and unsigned long long int.
+  AC_REQUIRE([AC_TYPE_LONG_LONG_INT])
+  if test $ac_cv_type_long_long_int = yes; then
+    HAVE_LONG_LONG_INT=1
+  else
+    HAVE_LONG_LONG_INT=0
+  fi
+  AC_SUBST([HAVE_LONG_LONG_INT])
+  AC_REQUIRE([AC_TYPE_UNSIGNED_LONG_LONG_INT])
+  if test $ac_cv_type_unsigned_long_long_int = yes; then
+    HAVE_UNSIGNED_LONG_LONG_INT=1
+  else
+    HAVE_UNSIGNED_LONG_LONG_INT=0
+  fi
+  AC_SUBST([HAVE_UNSIGNED_LONG_LONG_INT])
+
+  dnl Check for <inttypes.h>.
+  dnl AC_INCLUDES_DEFAULT defines $ac_cv_header_inttypes_h.
+  if test $ac_cv_header_inttypes_h = yes; then
+    HAVE_INTTYPES_H=1
+  else
+    HAVE_INTTYPES_H=0
+  fi
+  AC_SUBST([HAVE_INTTYPES_H])
+
+  dnl Check for <sys/types.h>.
+  dnl AC_INCLUDES_DEFAULT defines $ac_cv_header_sys_types_h.
+  if test $ac_cv_header_sys_types_h = yes; then
+    HAVE_SYS_TYPES_H=1
+  else
+    HAVE_SYS_TYPES_H=0
+  fi
+  AC_SUBST([HAVE_SYS_TYPES_H])
+
+  gl_CHECK_NEXT_HEADERS([stdint.h])
+  if test $ac_cv_header_stdint_h = yes; then
+    HAVE_STDINT_H=1
+  else
+    HAVE_STDINT_H=0
+  fi
+  AC_SUBST([HAVE_STDINT_H])
+
+  dnl Now see whether we need a substitute <stdint.h>.
+  if test $ac_cv_header_stdint_h = yes; then
+    AC_CACHE_CHECK([whether stdint.h conforms to C99],
+      [gl_cv_header_working_stdint_h],
+      [gl_cv_header_working_stdint_h=no
+       AC_COMPILE_IFELSE([
+         AC_LANG_PROGRAM([[
+#define __STDC_LIMIT_MACROS 1 /* to make it work also in C++ mode */
+#define __STDC_CONSTANT_MACROS 1 /* to make it work also in C++ mode */
+#define _GL_JUST_INCLUDE_SYSTEM_STDINT_H 1 /* work if build isn't clean */
+#include <stdint.h>
+/* Dragonfly defines WCHAR_MIN, WCHAR_MAX only in <wchar.h>.  */
+#if !(defined WCHAR_MIN && defined WCHAR_MAX)
+#error "WCHAR_MIN, WCHAR_MAX not defined in <stdint.h>"
+#endif
+]
+gl_STDINT_INCLUDES
+[
+#ifdef INT8_MAX
+int8_t a1 = INT8_MAX;
+int8_t a1min = INT8_MIN;
+#endif
+#ifdef INT16_MAX
+int16_t a2 = INT16_MAX;
+int16_t a2min = INT16_MIN;
+#endif
+#ifdef INT32_MAX
+int32_t a3 = INT32_MAX;
+int32_t a3min = INT32_MIN;
+#endif
+#ifdef INT64_MAX
+int64_t a4 = INT64_MAX;
+int64_t a4min = INT64_MIN;
+#endif
+#ifdef UINT8_MAX
+uint8_t b1 = UINT8_MAX;
+#else
+typedef int b1[(unsigned char) -1 != 255 ? 1 : -1];
+#endif
+#ifdef UINT16_MAX
+uint16_t b2 = UINT16_MAX;
+#endif
+#ifdef UINT32_MAX
+uint32_t b3 = UINT32_MAX;
+#endif
+#ifdef UINT64_MAX
+uint64_t b4 = UINT64_MAX;
+#endif
+int_least8_t c1 = INT8_C (0x7f);
+int_least8_t c1max = INT_LEAST8_MAX;
+int_least8_t c1min = INT_LEAST8_MIN;
+int_least16_t c2 = INT16_C (0x7fff);
+int_least16_t c2max = INT_LEAST16_MAX;
+int_least16_t c2min = INT_LEAST16_MIN;
+int_least32_t c3 = INT32_C (0x7fffffff);
+int_least32_t c3max = INT_LEAST32_MAX;
+int_least32_t c3min = INT_LEAST32_MIN;
+int_least64_t c4 = INT64_C (0x7fffffffffffffff);
+int_least64_t c4max = INT_LEAST64_MAX;
+int_least64_t c4min = INT_LEAST64_MIN;
+uint_least8_t d1 = UINT8_C (0xff);
+uint_least8_t d1max = UINT_LEAST8_MAX;
+uint_least16_t d2 = UINT16_C (0xffff);
+uint_least16_t d2max = UINT_LEAST16_MAX;
+uint_least32_t d3 = UINT32_C (0xffffffff);
+uint_least32_t d3max = UINT_LEAST32_MAX;
+uint_least64_t d4 = UINT64_C (0xffffffffffffffff);
+uint_least64_t d4max = UINT_LEAST64_MAX;
+int_fast8_t e1 = INT_FAST8_MAX;
+int_fast8_t e1min = INT_FAST8_MIN;
+int_fast16_t e2 = INT_FAST16_MAX;
+int_fast16_t e2min = INT_FAST16_MIN;
+int_fast32_t e3 = INT_FAST32_MAX;
+int_fast32_t e3min = INT_FAST32_MIN;
+int_fast64_t e4 = INT_FAST64_MAX;
+int_fast64_t e4min = INT_FAST64_MIN;
+uint_fast8_t f1 = UINT_FAST8_MAX;
+uint_fast16_t f2 = UINT_FAST16_MAX;
+uint_fast32_t f3 = UINT_FAST32_MAX;
+uint_fast64_t f4 = UINT_FAST64_MAX;
+#ifdef INTPTR_MAX
+intptr_t g = INTPTR_MAX;
+intptr_t gmin = INTPTR_MIN;
+#endif
+#ifdef UINTPTR_MAX
+uintptr_t h = UINTPTR_MAX;
+#endif
+intmax_t i = INTMAX_MAX;
+uintmax_t j = UINTMAX_MAX;
+
+#include <limits.h> /* for CHAR_BIT */
+#define TYPE_MINIMUM(t) \
+  ((t) ((t) 0 < (t) -1 ? (t) 0 : ~ (t) 0 << (sizeof (t) * CHAR_BIT - 1)))
+#define TYPE_MAXIMUM(t) \
+  ((t) ((t) 0 < (t) -1 ? (t) -1 : ~ (~ (t) 0 << (sizeof (t) * CHAR_BIT - 1))))
+struct s {
+  int check_PTRDIFF:
+      PTRDIFF_MIN == TYPE_MINIMUM (ptrdiff_t)
+      && PTRDIFF_MAX == TYPE_MAXIMUM (ptrdiff_t)
+      ? 1 : -1;
+  /* Detect bug in FreeBSD 6.0 / ia64.  */
+  int check_SIG_ATOMIC:
+      SIG_ATOMIC_MIN == TYPE_MINIMUM (sig_atomic_t)
+      && SIG_ATOMIC_MAX == TYPE_MAXIMUM (sig_atomic_t)
+      ? 1 : -1;
+  int check_SIZE: SIZE_MAX == TYPE_MAXIMUM (size_t) ? 1 : -1;
+  int check_WCHAR:
+      WCHAR_MIN == TYPE_MINIMUM (wchar_t)
+      && WCHAR_MAX == TYPE_MAXIMUM (wchar_t)
+      ? 1 : -1;
+  /* Detect bug in mingw.  */
+  int check_WINT:
+      WINT_MIN == TYPE_MINIMUM (wint_t)
+      && WINT_MAX == TYPE_MAXIMUM (wint_t)
+      ? 1 : -1;
+
+  /* Detect bugs in glibc 2.4 and Solaris 10 stdint.h, among others.  */
+  int check_UINT8_C:
+        (-1 < UINT8_C (0)) == (-1 < (uint_least8_t) 0) ? 1 : -1;
+  int check_UINT16_C:
+        (-1 < UINT16_C (0)) == (-1 < (uint_least16_t) 0) ? 1 : -1;
+
+  /* Detect bugs in OpenBSD 3.9 stdint.h.  */
+#ifdef UINT8_MAX
+  int check_uint8: (uint8_t) -1 == UINT8_MAX ? 1 : -1;
+#endif
+#ifdef UINT16_MAX
+  int check_uint16: (uint16_t) -1 == UINT16_MAX ? 1 : -1;
+#endif
+#ifdef UINT32_MAX
+  int check_uint32: (uint32_t) -1 == UINT32_MAX ? 1 : -1;
+#endif
+#ifdef UINT64_MAX
+  int check_uint64: (uint64_t) -1 == UINT64_MAX ? 1 : -1;
+#endif
+  int check_uint_least8: (uint_least8_t) -1 == UINT_LEAST8_MAX ? 1 : -1;
+  int check_uint_least16: (uint_least16_t) -1 == UINT_LEAST16_MAX ? 1 : -1;
+  int check_uint_least32: (uint_least32_t) -1 == UINT_LEAST32_MAX ? 1 : -1;
+  int check_uint_least64: (uint_least64_t) -1 == UINT_LEAST64_MAX ? 1 : -1;
+  int check_uint_fast8: (uint_fast8_t) -1 == UINT_FAST8_MAX ? 1 : -1;
+  int check_uint_fast16: (uint_fast16_t) -1 == UINT_FAST16_MAX ? 1 : -1;
+  int check_uint_fast32: (uint_fast32_t) -1 == UINT_FAST32_MAX ? 1 : -1;
+  int check_uint_fast64: (uint_fast64_t) -1 == UINT_FAST64_MAX ? 1 : -1;
+  int check_uintptr: (uintptr_t) -1 == UINTPTR_MAX ? 1 : -1;
+  int check_uintmax: (uintmax_t) -1 == UINTMAX_MAX ? 1 : -1;
+  int check_size: (size_t) -1 == SIZE_MAX ? 1 : -1;
+};
+         ]])],
+         [gl_cv_header_working_stdint_h=yes])])
+  fi
+  if test "$gl_cv_header_working_stdint_h" = yes; then
+    STDINT_H=
+  else
+    dnl Check for <sys/inttypes.h>, and for
+    dnl <sys/bitypes.h> (used in Linux libc4 >= 4.6.7 and libc5).
+    AC_CHECK_HEADERS([sys/inttypes.h sys/bitypes.h])
+    if test $ac_cv_header_sys_inttypes_h = yes; then
+      HAVE_SYS_INTTYPES_H=1
+    else
+      HAVE_SYS_INTTYPES_H=0
+    fi
+    AC_SUBST([HAVE_SYS_INTTYPES_H])
+    if test $ac_cv_header_sys_bitypes_h = yes; then
+      HAVE_SYS_BITYPES_H=1
+    else
+      HAVE_SYS_BITYPES_H=0
+    fi
+    AC_SUBST([HAVE_SYS_BITYPES_H])
+
+    dnl Check for <wchar.h> (missing in Linux uClibc when built without wide
+    dnl character support).
+    AC_CHECK_HEADERS_ONCE([wchar.h])
+
+    gl_STDINT_TYPE_PROPERTIES
+    STDINT_H=stdint.h
+  fi
+  AC_SUBST(STDINT_H)
+])
+
+dnl gl_STDINT_BITSIZEOF(TYPES, INCLUDES)
+dnl Determine the size of each of the given types in bits.
+AC_DEFUN([gl_STDINT_BITSIZEOF],
+[
+  dnl Use a shell loop, to avoid bloating configure, and
+  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
+  dnl   config.h.in,
+  dnl - extra AC_SUBST calls, so that the right substitutions are made.
+  AC_FOREACH([gltype], [$1],
+    [AH_TEMPLATE([BITSIZEOF_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
+       [Define to the number of bits in type ']gltype['.])])
+  for gltype in $1 ; do
+    AC_CACHE_CHECK([for bit size of $gltype], [gl_cv_bitsizeof_${gltype}],
+      [AC_COMPUTE_INT([result], [sizeof ($gltype) * CHAR_BIT],
+         [$2
+#include <limits.h>], [result=unknown])
+       eval gl_cv_bitsizeof_${gltype}=\$result
+      ])
+    eval result=\$gl_cv_bitsizeof_${gltype}
+    if test $result = unknown; then
+      dnl Use a nonempty default, because some compilers, such as IRIX 5 cc,
+      dnl do a syntax check even on unused #if conditions and give an error
+      dnl on valid C code like this:
+      dnl   #if 0
+      dnl   # if  > 32
+      dnl   # endif
+      dnl   #endif
+      result=0
+    fi
+    GLTYPE=`echo "$gltype" | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`
+    AC_DEFINE_UNQUOTED([BITSIZEOF_${GLTYPE}], [$result])
+    eval BITSIZEOF_${GLTYPE}=\$result
+  done
+  AC_FOREACH([gltype], [$1],
+    [AC_SUBST([BITSIZEOF_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
+])
+
+dnl gl_CHECK_TYPES_SIGNED(TYPES, INCLUDES)
+dnl Determine the signedness of each of the given types.
+dnl Define HAVE_SIGNED_TYPE if type is signed.
+AC_DEFUN([gl_CHECK_TYPES_SIGNED],
+[
+  dnl Use a shell loop, to avoid bloating configure, and
+  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
+  dnl   config.h.in,
+  dnl - extra AC_SUBST calls, so that the right substitutions are made.
+  AC_FOREACH([gltype], [$1],
+    [AH_TEMPLATE([HAVE_SIGNED_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]),
+       [Define to 1 if ']gltype[' is a signed integer type.])])
+  for gltype in $1 ; do
+    AC_CACHE_CHECK([whether $gltype is signed], [gl_cv_type_${gltype}_signed],
+      [AC_COMPILE_IFELSE(
+         [AC_LANG_PROGRAM([$2[
+            int verify[2 * (($gltype) -1 < ($gltype) 0) - 1];]])],
+         result=yes, result=no)
+       eval gl_cv_type_${gltype}_signed=\$result
+      ])
+    eval result=\$gl_cv_type_${gltype}_signed
+    GLTYPE=`echo $gltype | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`
+    if test "$result" = yes; then
+      AC_DEFINE_UNQUOTED([HAVE_SIGNED_${GLTYPE}], 1)
+      eval HAVE_SIGNED_${GLTYPE}=1
+    else
+      eval HAVE_SIGNED_${GLTYPE}=0
+    fi
+  done
+  AC_FOREACH([gltype], [$1],
+    [AC_SUBST([HAVE_SIGNED_]translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_]))])
+])
+
+dnl gl_INTEGER_TYPE_SUFFIX(TYPES, INCLUDES)
+dnl Determine the suffix to use for integer constants of the given types.
+dnl Define t_SUFFIX for each such type.
+AC_DEFUN([gl_INTEGER_TYPE_SUFFIX],
+[
+  dnl Use a shell loop, to avoid bloating configure, and
+  dnl - extra AH_TEMPLATE calls, so that autoheader knows what to put into
+  dnl   config.h.in,
+  dnl - extra AC_SUBST calls, so that the right substitutions are made.
+  AC_FOREACH([gltype], [$1],
+    [AH_TEMPLATE(translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX],
+       [Define to l, ll, u, ul, ull, etc., as suitable for
+        constants of type ']gltype['.])])
+  for gltype in $1 ; do
+    AC_CACHE_CHECK([for $gltype integer literal suffix],
+      [gl_cv_type_${gltype}_suffix],
+      [eval gl_cv_type_${gltype}_suffix=no
+       eval result=\$gl_cv_type_${gltype}_signed
+       if test "$result" = yes; then
+         glsufu=
+       else
+         glsufu=u
+       fi
+       for glsuf in "$glsufu" ${glsufu}l ${glsufu}ll ${glsufu}i64; do
+         case $glsuf in
+           '')  gltype1='int';;
+           l)	gltype1='long int';;
+           ll)	gltype1='long long int';;
+           i64)	gltype1='__int64';;
+           u)	gltype1='unsigned int';;
+           ul)	gltype1='unsigned long int';;
+           ull)	gltype1='unsigned long long int';;
+           ui64)gltype1='unsigned __int64';;
+         esac
+         AC_COMPILE_IFELSE(
+           [AC_LANG_PROGRAM([$2
+              extern $gltype foo;
+              extern $gltype1 foo;])],
+           [eval gl_cv_type_${gltype}_suffix=\$glsuf])
+         eval result=\$gl_cv_type_${gltype}_suffix
+         test "$result" != no && break
+       done])
+    GLTYPE=`echo $gltype | tr 'abcdefghijklmnopqrstuvwxyz ' 'ABCDEFGHIJKLMNOPQRSTUVWXYZ_'`
+    eval result=\$gl_cv_type_${gltype}_suffix
+    test "$result" = no && result=
+    eval ${GLTYPE}_SUFFIX=\$result
+    AC_DEFINE_UNQUOTED([${GLTYPE}_SUFFIX], $result)
+  done
+  AC_FOREACH([gltype], [$1],
+    [AC_SUBST(translit(gltype,[abcdefghijklmnopqrstuvwxyz ],[ABCDEFGHIJKLMNOPQRSTUVWXYZ_])[_SUFFIX])])
+])
+
+dnl gl_STDINT_INCLUDES
+AC_DEFUN([gl_STDINT_INCLUDES],
+[[
+  /* BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be
+     included before <wchar.h>.  */
+  #include <stddef.h>
+  #include <signal.h>
+  #if HAVE_WCHAR_H
+  # include <stdio.h>
+  # include <time.h>
+  # include <wchar.h>
+  #endif
+]])
+
+dnl gl_STDINT_TYPE_PROPERTIES
+dnl Compute HAVE_SIGNED_t, BITSIZEOF_t and t_SUFFIX, for all the types t
+dnl of interest to stdint.in.h.
+AC_DEFUN([gl_STDINT_TYPE_PROPERTIES],
+[
+  gl_STDINT_BITSIZEOF([ptrdiff_t sig_atomic_t size_t wchar_t wint_t],
+    [gl_STDINT_INCLUDES])
+  gl_CHECK_TYPES_SIGNED([sig_atomic_t wchar_t wint_t],
+    [gl_STDINT_INCLUDES])
+  gl_cv_type_ptrdiff_t_signed=yes
+  gl_cv_type_size_t_signed=no
+  gl_INTEGER_TYPE_SUFFIX([ptrdiff_t sig_atomic_t size_t wchar_t wint_t],
+    [gl_STDINT_INCLUDES])
+])
+
+dnl Autoconf >= 2.61 has AC_COMPUTE_INT built-in.
+dnl Remove this when we can assume autoconf >= 2.61.
+m4_ifdef([AC_COMPUTE_INT], [], [
+  AC_DEFUN([AC_COMPUTE_INT], [_AC_COMPUTE_INT([$2],[$1],[$3],[$4])])
+])
+
+# Hey Emacs!
+# Local Variables:
+# indent-tabs-mode: nil
+# End:
Index: m4/stdint_h.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/stdint_h.m4	2007-11-07 16:30:54.194522151 +0000
@@ -0,0 +1,26 @@
+# stdint_h.m4 serial 6
+dnl Copyright (C) 1997-2004, 2006 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Paul Eggert.
+
+# Define HAVE_STDINT_H_WITH_UINTMAX if <stdint.h> exists,
+# doesn't clash with <sys/types.h>, and declares uintmax_t.
+
+AC_DEFUN([gl_AC_HEADER_STDINT_H],
+[
+  AC_CACHE_CHECK([for stdint.h], gl_cv_header_stdint_h,
+  [AC_TRY_COMPILE(
+    [#include <sys/types.h>
+#include <stdint.h>],
+    [uintmax_t i = (uintmax_t) -1; return !i;],
+    gl_cv_header_stdint_h=yes,
+    gl_cv_header_stdint_h=no)])
+  if test $gl_cv_header_stdint_h = yes; then
+    AC_DEFINE_UNQUOTED(HAVE_STDINT_H_WITH_UINTMAX, 1,
+      [Define if <stdint.h> exists, doesn't clash with <sys/types.h>,
+       and declares uintmax_t. ])
+  fi
+])
Index: m4/stdio_h.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/stdio_h.m4	2007-11-07 16:30:54.204096472 +0000
@@ -0,0 +1,86 @@
+# stdio_h.m4 serial 8
+dnl Copyright (C) 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_STDIO_H],
+[
+  AC_REQUIRE([gl_STDIO_H_DEFAULTS])
+  gl_CHECK_NEXT_HEADERS([stdio.h])
+])
+
+AC_DEFUN([gl_STDIO_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_STDIO_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_STDIO_H_DEFAULTS],
+[
+  GNULIB_FPRINTF_POSIX=0;  AC_SUBST([GNULIB_FPRINTF_POSIX])
+  GNULIB_PRINTF_POSIX=0;   AC_SUBST([GNULIB_PRINTF_POSIX])
+  GNULIB_SNPRINTF=0;       AC_SUBST([GNULIB_SNPRINTF])
+  GNULIB_SPRINTF_POSIX=0;  AC_SUBST([GNULIB_SPRINTF_POSIX])
+  GNULIB_VFPRINTF_POSIX=0; AC_SUBST([GNULIB_VFPRINTF_POSIX])
+  GNULIB_VPRINTF_POSIX=0;  AC_SUBST([GNULIB_VPRINTF_POSIX])
+  GNULIB_VSNPRINTF=0;      AC_SUBST([GNULIB_VSNPRINTF])
+  GNULIB_VSPRINTF_POSIX=0; AC_SUBST([GNULIB_VSPRINTF_POSIX])
+  GNULIB_VASPRINTF=0;      AC_SUBST([GNULIB_VASPRINTF])
+  GNULIB_FOPEN=0;          AC_SUBST([GNULIB_FOPEN])
+  GNULIB_FREOPEN=0;        AC_SUBST([GNULIB_FREOPEN])
+  GNULIB_FSEEK=0;          AC_SUBST([GNULIB_FSEEK])
+  GNULIB_FSEEKO=0;         AC_SUBST([GNULIB_FSEEKO])
+  GNULIB_FTELL=0;          AC_SUBST([GNULIB_FTELL])
+  GNULIB_FTELLO=0;         AC_SUBST([GNULIB_FTELLO])
+  GNULIB_FFLUSH=0;         AC_SUBST([GNULIB_FFLUSH])
+  GNULIB_GETDELIM=0;       AC_SUBST([GNULIB_GETDELIM])
+  GNULIB_GETLINE=0;        AC_SUBST([GNULIB_GETLINE])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  REPLACE_FPRINTF=0;       AC_SUBST([REPLACE_FPRINTF])
+  REPLACE_VFPRINTF=0;      AC_SUBST([REPLACE_VFPRINTF])
+  REPLACE_PRINTF=0;        AC_SUBST([REPLACE_PRINTF])
+  REPLACE_VPRINTF=0;       AC_SUBST([REPLACE_VPRINTF])
+  REPLACE_SNPRINTF=0;      AC_SUBST([REPLACE_SNPRINTF])
+  HAVE_DECL_SNPRINTF=1;    AC_SUBST([HAVE_DECL_SNPRINTF])
+  REPLACE_VSNPRINTF=0;     AC_SUBST([REPLACE_VSNPRINTF])
+  HAVE_DECL_VSNPRINTF=1;   AC_SUBST([HAVE_DECL_VSNPRINTF])
+  REPLACE_SPRINTF=0;       AC_SUBST([REPLACE_SPRINTF])
+  REPLACE_VSPRINTF=0;      AC_SUBST([REPLACE_VSPRINTF])
+  HAVE_VASPRINTF=1;        AC_SUBST([HAVE_VASPRINTF])
+  REPLACE_VASPRINTF=0;     AC_SUBST([REPLACE_VASPRINTF])
+  REPLACE_FOPEN=0;         AC_SUBST([REPLACE_FOPEN])
+  REPLACE_FREOPEN=0;       AC_SUBST([REPLACE_FREOPEN])
+  HAVE_FSEEKO=1;           AC_SUBST([HAVE_FSEEKO])
+  REPLACE_FSEEKO=0;        AC_SUBST([REPLACE_FSEEKO])
+  REPLACE_FSEEK=0;         AC_SUBST([REPLACE_FSEEK])
+  HAVE_FTELLO=1;           AC_SUBST([HAVE_FTELLO])
+  REPLACE_FTELLO=0;        AC_SUBST([REPLACE_FTELLO])
+  REPLACE_FTELL=0;         AC_SUBST([REPLACE_FTELL])
+  REPLACE_FFLUSH=0;        AC_SUBST([REPLACE_FFLUSH])
+  HAVE_DECL_GETDELIM=1;    AC_SUBST([HAVE_DECL_GETDELIM])
+  HAVE_DECL_GETLINE=1;     AC_SUBST([HAVE_DECL_GETLINE])
+  REPLACE_GETLINE=0;       AC_SUBST([REPLACE_GETLINE])
+])
+
+dnl Code shared by fseeko and ftello.  Determine if large files are supported,
+dnl but stdin does not start as a large file by default.
+AC_DEFUN([gl_STDIN_LARGE_OFFSET],
+  [
+    AC_CACHE_CHECK([whether stdin defaults to large file offsets],
+      [gl_cv_var_stdin_large_offset],
+      [AC_LINK_IFELSE([AC_LANG_PROGRAM([#include <stdio.h>],
+[#if defined __SL64 && defined __SCLE /* cygwin */
+  /* Cygwin 1.5.24 and earlier fail to put stdin in 64-bit mode, making
+     fseeko/ftello needlessly fail.  This bug was fixed at the same time
+     that cygwin started exporting asnprintf (cygwin 1.7.0), so we use
+     that as a link-time test for cross-compiles rather than building
+     a runtime test.  */
+  size_t s;
+  if (asnprintf (NULL, &s, ""))
+    return 0;
+#endif])],
+	[gl_cv_var_stdin_large_offset=yes],
+	[gl_cv_var_stdin_large_offset=no])])
+])
Index: m4/vasnprintf.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/vasnprintf.m4	2007-11-07 16:30:54.211973133 +0000
@@ -0,0 +1,197 @@
+# vasnprintf.m4 serial 20
+dnl Copyright (C) 2002-2004, 2006-2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_VASNPRINTF],
+[
+  AC_REQUIRE([gl_EOVERFLOW])
+  AC_CHECK_FUNCS_ONCE([vasnprintf])
+  if test $ac_cv_func_vasnprintf = no; then
+    gl_REPLACE_VASNPRINTF
+  fi
+])
+
+AC_DEFUN([gl_REPLACE_VASNPRINTF],
+[
+  AC_CHECK_FUNCS_ONCE([vasnprintf])
+  AC_LIBOBJ([vasnprintf])
+  AC_LIBOBJ([printf-args])
+  AC_LIBOBJ([printf-parse])
+  AC_LIBOBJ([asnprintf])
+  if test $ac_cv_func_vasnprintf = yes; then
+    AC_DEFINE([REPLACE_VASNPRINTF], 1,
+      [Define if vasnprintf exists but is overridden by gnulib.])
+  fi
+  gl_PREREQ_PRINTF_ARGS
+  gl_PREREQ_PRINTF_PARSE
+  gl_PREREQ_VASNPRINTF
+  gl_PREREQ_ASNPRINTF
+])
+
+# Prequisites of lib/printf-args.h, lib/printf-args.c.
+AC_DEFUN([gl_PREREQ_PRINTF_ARGS],
+[
+  AC_REQUIRE([AC_TYPE_LONG_LONG_INT])
+  AC_REQUIRE([gt_TYPE_WCHAR_T])
+  AC_REQUIRE([gt_TYPE_WINT_T])
+])
+
+# Prequisites of lib/printf-parse.h, lib/printf-parse.c.
+AC_DEFUN([gl_PREREQ_PRINTF_PARSE],
+[
+  AC_REQUIRE([AC_TYPE_LONG_LONG_INT])
+  AC_REQUIRE([gt_TYPE_WCHAR_T])
+  AC_REQUIRE([gt_TYPE_WINT_T])
+  AC_REQUIRE([AC_TYPE_SIZE_T])
+  AC_CHECK_TYPES(ptrdiff_t)
+  AC_REQUIRE([gt_AC_TYPE_INTMAX_T])
+])
+
+# Prerequisites of lib/vasnprintf.c.
+AC_DEFUN([gl_PREREQ_VASNPRINTF],
+[
+  AC_REQUIRE([AC_FUNC_ALLOCA])
+  AC_REQUIRE([AC_TYPE_LONG_LONG_INT])
+  AC_REQUIRE([gt_TYPE_WCHAR_T])
+  AC_REQUIRE([gt_TYPE_WINT_T])
+  AC_CHECK_FUNCS(snprintf wcslen)
+  dnl Use the _snprintf function only if it is declared (because on NetBSD it
+  dnl is defined as a weak alias of snprintf; we prefer to use the latter).
+  AC_CHECK_DECLS([_snprintf], , , [#include <stdio.h>])
+])
+
+# Extra prerequisites of lib/vasnprintf.c for supporting 'long double'
+# arguments.
+AC_DEFUN([gl_PREREQ_VASNPRINTF_LONG_DOUBLE],
+[
+  AC_REQUIRE([gl_PRINTF_LONG_DOUBLE])
+  case "$gl_cv_func_printf_long_double" in
+    *yes)
+      ;;
+    *)
+      AC_DEFINE([NEED_PRINTF_LONG_DOUBLE], 1,
+        [Define if the vasnprintf implementation needs special code for
+         'long double' arguments.])
+      ;;
+  esac
+])
+
+# Extra prerequisites of lib/vasnprintf.c for supporting infinite 'double'
+# arguments.
+AC_DEFUN([gl_PREREQ_VASNPRINTF_INFINITE_DOUBLE],
+[
+  AC_REQUIRE([gl_PRINTF_INFINITE])
+  case "$gl_cv_func_printf_infinite" in
+    *yes)
+      ;;
+    *)
+      AC_DEFINE([NEED_PRINTF_INFINITE_DOUBLE], 1,
+        [Define if the vasnprintf implementation needs special code for
+         infinite 'double' arguments.])
+      ;;
+  esac
+])
+
+# Extra prerequisites of lib/vasnprintf.c for supporting infinite 'long double'
+# arguments.
+AC_DEFUN([gl_PREREQ_VASNPRINTF_INFINITE_LONG_DOUBLE],
+[
+  AC_REQUIRE([gl_PRINTF_INFINITE_LONG_DOUBLE])
+  dnl There is no need to set NEED_PRINTF_INFINITE_LONG_DOUBLE if
+  dnl NEED_PRINTF_LONG_DOUBLE is already set.
+  AC_REQUIRE([gl_PREREQ_VASNPRINTF_LONG_DOUBLE])
+  case "$gl_cv_func_printf_long_double" in
+    *yes)
+      case "$gl_cv_func_printf_infinite_long_double" in
+        *yes)
+          ;;
+        *)
+          AC_DEFINE([NEED_PRINTF_INFINITE_LONG_DOUBLE], 1,
+            [Define if the vasnprintf implementation needs special code for
+             infinite 'long double' arguments.])
+          ;;
+      esac
+      ;;
+  esac
+])
+
+# Extra prerequisites of lib/vasnprintf.c for supporting the 'a' directive.
+AC_DEFUN([gl_PREREQ_VASNPRINTF_DIRECTIVE_A],
+[
+  AC_REQUIRE([gl_PRINTF_DIRECTIVE_A])
+  case "$gl_cv_func_printf_directive_a" in
+    *yes)
+      ;;
+    *)
+      AC_DEFINE([NEED_PRINTF_DIRECTIVE_A], 1,
+        [Define if the vasnprintf implementation needs special code for
+         the 'a' and 'A' directives.])
+      AC_CHECK_FUNCS([nl_langinfo])
+      ;;
+  esac
+])
+
+# Extra prerequisites of lib/vasnprintf.c for supporting the 'F' directive.
+AC_DEFUN([gl_PREREQ_VASNPRINTF_DIRECTIVE_F],
+[
+  AC_REQUIRE([gl_PRINTF_DIRECTIVE_F])
+  case "$gl_cv_func_printf_directive_f" in
+    *yes)
+      ;;
+    *)
+      AC_DEFINE([NEED_PRINTF_DIRECTIVE_F], 1,
+        [Define if the vasnprintf implementation needs special code for
+         the 'F' directive.])
+      ;;
+  esac
+])
+
+# Extra prerequisites of lib/vasnprintf.c for supporting the ' flag.
+AC_DEFUN([gl_PREREQ_VASNPRINTF_FLAG_GROUPING],
+[
+  AC_REQUIRE([gl_PRINTF_FLAG_GROUPING])
+  case "$gl_cv_func_printf_flag_grouping" in
+    *yes)
+      ;;
+    *)
+      AC_DEFINE([NEED_PRINTF_FLAG_GROUPING], 1,
+        [Define if the vasnprintf implementation needs special code for the
+         ' flag.])
+      ;;
+  esac
+])
+
+# Extra prerequisites of lib/vasnprintf.c for supporting the 0 flag.
+AC_DEFUN([gl_PREREQ_VASNPRINTF_FLAG_ZERO],
+[
+  AC_REQUIRE([gl_PRINTF_FLAG_ZERO])
+  case "$gl_cv_func_printf_flag_zero" in
+    *yes)
+      ;;
+    *)
+      AC_DEFINE([NEED_PRINTF_FLAG_ZERO], 1,
+        [Define if the vasnprintf implementation needs special code for the
+         0 flag.])
+      ;;
+  esac
+])
+
+# Prerequisites of lib/vasnprintf.c including all extras for POSIX compliance.
+AC_DEFUN([gl_PREREQ_VASNPRINTF_WITH_EXTRAS],
+[
+  AC_REQUIRE([gl_PREREQ_VASNPRINTF])
+  gl_PREREQ_VASNPRINTF_LONG_DOUBLE
+  gl_PREREQ_VASNPRINTF_INFINITE_DOUBLE
+  gl_PREREQ_VASNPRINTF_INFINITE_LONG_DOUBLE
+  gl_PREREQ_VASNPRINTF_DIRECTIVE_A
+  gl_PREREQ_VASNPRINTF_DIRECTIVE_F
+  gl_PREREQ_VASNPRINTF_FLAG_GROUPING
+  gl_PREREQ_VASNPRINTF_FLAG_ZERO
+])
+
+# Prerequisites of lib/asnprintf.c.
+AC_DEFUN([gl_PREREQ_ASNPRINTF],
+[
+])
Index: m4/vsnprintf.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/vsnprintf.m4	2007-11-07 16:30:54.219287014 +0000
@@ -0,0 +1,31 @@
+# vsnprintf.m4 serial 4
+dnl Copyright (C) 2002, 2003, 2004, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_FUNC_VSNPRINTF],
+[
+  AC_REQUIRE([gl_STDIO_H_DEFAULTS])
+  AC_CHECK_FUNCS([vsnprintf])
+  if test $ac_cv_func_vsnprintf = no; then
+    gl_REPLACE_VSNPRINTF
+  fi
+  AC_CHECK_DECLS_ONCE([vsnprintf])
+  if test $ac_cv_have_decl_vsnprintf = no; then
+    HAVE_DECL_VSNPRINTF=0
+  fi
+])
+
+AC_DEFUN([gl_REPLACE_VSNPRINTF],
+[
+  AC_REQUIRE([gl_STDIO_H_DEFAULTS])
+  AC_LIBOBJ([vsnprintf])
+  if test $ac_cv_func_vsnprintf = yes; then
+    REPLACE_VSNPRINTF=1
+  fi
+  gl_PREREQ_VSNPRINTF
+])
+
+# Prerequisites of lib/vsnprintf.c.
+AC_DEFUN([gl_PREREQ_VSNPRINTF], [:])
Index: m4/wchar.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/wchar.m4	2007-11-07 16:30:54.225912055 +0000
@@ -0,0 +1,54 @@
+dnl A placeholder for ISO C99 <wchar.h>, for platforms that have issues.
+
+dnl Copyright (C) 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl Written by Eric Blake.
+
+# wchar.m4 serial 4
+
+AC_DEFUN([gl_WCHAR_H],
+[
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  AC_CACHE_CHECK([whether <wchar.h> is standalone],
+    [gl_cv_header_wchar_h_standalone],
+    [AC_COMPILE_IFELSE([[#include <wchar.h>
+wchar_t w;]],
+      [gl_cv_header_wchar_h_standalone=yes],
+      [gl_cv_header_wchar_h_standalone=no])])
+  if test $gl_cv_header_wchar_h_standalone != yes; then
+    WCHAR_H=wchar.h
+  fi
+
+  dnl Prepare for creating substitute <wchar.h>.
+  dnl Do it always: WCHAR_H may be empty here but can be set later.
+  dnl Check for <wchar.h> (missing in Linux uClibc when built without wide
+  dnl character support).
+  AC_CHECK_HEADERS_ONCE([wchar.h])
+  if test $ac_cv_header_wchar_h = yes; then
+    HAVE_WCHAR_H=1
+  else
+    HAVE_WCHAR_H=0
+  fi
+  AC_SUBST([HAVE_WCHAR_H])
+  gl_CHECK_NEXT_HEADERS([wchar.h])
+])
+
+AC_DEFUN([gl_WCHAR_MODULE_INDICATOR],
+[
+  dnl Use AC_REQUIRE here, so that the default settings are expanded once only.
+  AC_REQUIRE([gl_WCHAR_H_DEFAULTS])
+  GNULIB_[]m4_translit([$1],[abcdefghijklmnopqrstuvwxyz./-],[ABCDEFGHIJKLMNOPQRSTUVWXYZ___])=1
+])
+
+AC_DEFUN([gl_WCHAR_H_DEFAULTS],
+[
+  GNULIB_WCWIDTH=0; AC_SUBST([GNULIB_WCWIDTH])
+  dnl Assume proper GNU behavior unless another module says otherwise.
+  HAVE_DECL_WCWIDTH=1; AC_SUBST([HAVE_DECL_WCWIDTH])
+  REPLACE_WCWIDTH=0;   AC_SUBST([REPLACE_WCWIDTH])
+  WCHAR_H=
+  AC_SUBST([WCHAR_H])
+])
Index: m4/wchar_t.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/wchar_t.m4	2007-11-07 16:30:54.232389030 +0000
@@ -0,0 +1,20 @@
+# wchar_t.m4 serial 1 (gettext-0.12)
+dnl Copyright (C) 2002-2003 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+dnl Test whether <stddef.h> has the 'wchar_t' type.
+dnl Prerequisite: AC_PROG_CC
+
+AC_DEFUN([gt_TYPE_WCHAR_T],
+[
+  AC_CACHE_CHECK([for wchar_t], gt_cv_c_wchar_t,
+    [AC_TRY_COMPILE([#include <stddef.h>
+       wchar_t foo = (wchar_t)'\0';], ,
+       gt_cv_c_wchar_t=yes, gt_cv_c_wchar_t=no)])
+  if test $gt_cv_c_wchar_t = yes; then
+    AC_DEFINE(HAVE_WCHAR_T, 1, [Define if you have the 'wchar_t' type.])
+  fi
+])
Index: m4/wint_t.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/wint_t.m4	2007-11-07 16:30:54.239282668 +0000
@@ -0,0 +1,28 @@
+# wint_t.m4 serial 2 (gettext-0.16.2)
+dnl Copyright (C) 2003, 2007 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+dnl From Bruno Haible.
+dnl Test whether <wchar.h> has the 'wint_t' type.
+dnl Prerequisite: AC_PROG_CC
+
+AC_DEFUN([gt_TYPE_WINT_T],
+[
+  AC_CACHE_CHECK([for wint_t], gt_cv_c_wint_t,
+    [AC_TRY_COMPILE([
+/* Tru64 with Desktop Toolkit C has a bug: <stdio.h> must be included before
+   <wchar.h>.
+   BSD/OS 4.0.1 has a bug: <stddef.h>, <stdio.h> and <time.h> must be included
+   before <wchar.h>.  */
+#include <stddef.h>
+#include <stdio.h>
+#include <time.h>
+#include <wchar.h>
+       wint_t foo = (wchar_t)'\0';], ,
+       gt_cv_c_wint_t=yes, gt_cv_c_wint_t=no)])
+  if test $gt_cv_c_wint_t = yes; then
+    AC_DEFINE(HAVE_WINT_T, 1, [Define if you have the 'wint_t' type.])
+  fi
+])
Index: m4/xsize.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/xsize.m4	2007-11-07 16:30:54.253508242 +0000
@@ -0,0 +1,13 @@
+# xsize.m4 serial 3
+dnl Copyright (C) 2003-2004 Free Software Foundation, Inc.
+dnl This file is free software; the Free Software Foundation
+dnl gives unlimited permission to copy and/or distribute it,
+dnl with or without modifications, as long as this notice is preserved.
+
+AC_DEFUN([gl_XSIZE],
+[
+  dnl Prerequisites of lib/xsize.h.
+  AC_REQUIRE([gl_SIZE_MAX])
+  AC_REQUIRE([AC_C_INLINE])
+  AC_CHECK_HEADERS(stdint.h)
+])
Index: m4/gnulib-comp.m4
===================================================================
--- /dev/null	1970-01-01 00:00:00.000000000 +0000
+++ m4/gnulib-comp.m4	2007-11-07 16:30:54.260529307 +0000
@@ -0,0 +1,141 @@
+# DO NOT EDIT! GENERATED AUTOMATICALLY!
+# Copyright (C) 2004-2007 Free Software Foundation, Inc.
+#
+# This file is free software, distributed under the terms of the GNU
+# General Public License.  As a special exception to the GNU General
+# Public License, this file may be distributed as part of a program
+# that contains a configuration script generated by Autoconf, under
+# the same distribution terms as the rest of that program.
+#
+# Generated by gnulib-tool.
+#
+# This file represents the compiled summary of the specification in
+# gnulib-cache.m4. It lists the computed macro invocations that need
+# to be invoked from configure.ac.
+# In projects using CVS, this file can be treated like other built files.
+
+
+# This macro should be invoked from ./configure.ac, in the section
+# "Checks for programs", right after AC_PROG_CC, and certainly before
+# any checks for libraries, header files, types and library functions.
+AC_DEFUN([gl_EARLY],
+[
+  m4_pattern_forbid([^gl_[A-Z]])dnl the gnulib macro namespace
+  m4_pattern_allow([^gl_ES$])dnl a valid locale name
+  m4_pattern_allow([^gl_LIBOBJS$])dnl a variable
+  m4_pattern_allow([^gl_LTLIBOBJS$])dnl a variable
+  AC_REQUIRE([AC_PROG_RANLIB])
+])
+
+# This macro should be invoked from ./configure.ac, in the section
+# "Check for header files, types and library functions".
+AC_DEFUN([gl_INIT],
+[
+  m4_pushdef([AC_LIBOBJ], m4_defn([gl_LIBOBJ]))
+  m4_pushdef([AC_REPLACE_FUNCS], m4_defn([gl_REPLACE_FUNCS]))
+  m4_pushdef([AC_LIBSOURCES], m4_defn([gl_LIBSOURCES]))
+  AM_CONDITIONAL([GL_COND_LIBTOOL], [true])
+  gl_cond_libtool=true
+  gl_source_base='lib'
+  gl_FUNC_ALLOCA
+  gl_FLOAT_H
+  gl_SIZE_MAX
+  gl_FUNC_SNPRINTF
+  gl_STDIO_MODULE_INDICATOR([snprintf])
+  gl_STDINT_H
+  gl_STDIO_H
+  gl_FUNC_VASNPRINTF
+  gl_FUNC_VSNPRINTF
+  gl_STDIO_MODULE_INDICATOR([vsnprintf])
+  gl_WCHAR_H
+  gl_XSIZE
+  m4_popdef([AC_LIBSOURCES])
+  m4_popdef([AC_REPLACE_FUNCS])
+  m4_popdef([AC_LIBOBJ])
+  AC_CONFIG_COMMANDS_PRE([
+    gl_libobjs=
+    gl_ltlibobjs=
+    if test -n "$gl_LIBOBJS"; then
+      # Remove the extension.
+      sed_drop_objext='s/\.o$//;s/\.obj$//'
+      for i in `for i in $gl_LIBOBJS; do echo "$i"; done | sed "$sed_drop_objext" | sort | uniq`; do
+        gl_libobjs="$gl_libobjs $i.$ac_objext"
+        gl_ltlibobjs="$gl_ltlibobjs $i.lo"
+      done
+    fi
+    AC_SUBST([gl_LIBOBJS], [$gl_libobjs])
+    AC_SUBST([gl_LTLIBOBJS], [$gl_ltlibobjs])
+  ])
+])
+
+# Like AC_LIBOBJ, except that the module name goes
+# into gl_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([gl_LIBOBJ], [
+  AS_LITERAL_IF([$1], [gl_LIBSOURCES([$1.c])])dnl
+  gl_LIBOBJS="$gl_LIBOBJS $1.$ac_objext"
+])
+
+# Like AC_REPLACE_FUNCS, except that the module name goes
+# into gl_LIBOBJS instead of into LIBOBJS.
+AC_DEFUN([gl_REPLACE_FUNCS], [
+  m4_foreach_w([gl_NAME], [$1], [AC_LIBSOURCES(gl_NAME[.c])])dnl
+  AC_CHECK_FUNCS([$1], , [gl_LIBOBJ($ac_func)])
+])
+
+# Like AC_LIBSOURCES, except the directory where the source file is
+# expected is derived from the gnulib-tool parametrization,
+# and alloca is special cased (for the alloca-opt module).
+# We could also entirely rely on EXTRA_lib..._SOURCES.
+AC_DEFUN([gl_LIBSOURCES], [
+  m4_foreach([_gl_NAME], [$1], [
+    m4_if(_gl_NAME, [alloca.c], [], [
+      m4_syscmd([test -r lib/]_gl_NAME[ || test ! -d lib])dnl
+      m4_if(m4_sysval, [0], [],
+        [AC_FATAL([missing lib/]_gl_NAME)])
+    ])
+  ])
+])
+
+# This macro records the list of files which have been installed by
+# gnulib-tool and may be removed by future gnulib-tool invocations.
+AC_DEFUN([gl_FILE_LIST], [
+  build-aux/link-warning.h
+  lib/alloca.in.h
+  lib/asnprintf.c
+  lib/dummy.c
+  lib/float+.h
+  lib/float.in.h
+  lib/printf-args.c
+  lib/printf-args.h
+  lib/printf-parse.c
+  lib/printf-parse.h
+  lib/size_max.h
+  lib/snprintf.c
+  lib/stdint.in.h
+  lib/stdio.in.h
+  lib/vasnprintf.c
+  lib/vasnprintf.h
+  lib/vsnprintf.c
+  lib/wchar.in.h
+  lib/xsize.h
+  m4/alloca.m4
+  m4/eoverflow.m4
+  m4/float_h.m4
+  m4/gnulib-common.m4
+  m4/include_next.m4
+  m4/intmax_t.m4
+  m4/inttypes_h.m4
+  m4/longlong.m4
+  m4/onceonly_2_57.m4
+  m4/size_max.m4
+  m4/snprintf.m4
+  m4/stdint.m4
+  m4/stdint_h.m4
+  m4/stdio_h.m4
+  m4/vasnprintf.m4
+  m4/vsnprintf.m4
+  m4/wchar.m4
+  m4/wchar_t.m4
+  m4/wint_t.m4
+  m4/xsize.m4
+])
